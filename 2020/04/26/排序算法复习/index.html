<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="更新中，未完待续考研凉凉的结果就是不仅失去了应届生走校招的机会，而且还因为疫情走不了，僵。因为接下来准备找一份安全相关的C&#x2F;C++开发工作，所以在刷了段时间题后，把排序算法重新复习整理一下。之前虽然学习过，但是现在一些不经常用的东西很快就忘了细结了，只能偶尔复习一下。 本文主要以十大经典排序算法为参考文章来进行复习，使用C++实现，代码都经过了测试。 冒泡排序(Bubble Sort)冒泡排序，选">
<meta property="og:type" content="article">
<meta property="og:title" content="排序算法复习">
<meta property="og:url" content="http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="1nv0k3r&#39;s notebook">
<meta property="og:description" content="更新中，未完待续考研凉凉的结果就是不仅失去了应届生走校招的机会，而且还因为疫情走不了，僵。因为接下来准备找一份安全相关的C&#x2F;C++开发工作，所以在刷了段时间题后，把排序算法重新复习整理一下。之前虽然学习过，但是现在一些不经常用的东西很快就忘了细结了，只能偶尔复习一下。 本文主要以十大经典排序算法为参考文章来进行复习，使用C++实现，代码都经过了测试。 冒泡排序(Bubble Sort)冒泡排序，选">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-26T11:36:36.000Z">
<meta property="article:modified_time" content="2021-02-28T09:42:51.154Z">
<meta property="article:author" content="1nv0k3r">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>排序算法复习</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/05/16/De1CTF-2020-Qualifier-pwn/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&text=排序算法复习"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&is_video=false&description=排序算法复习"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=排序算法复习&body=Check out this article: http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&name=排序算法复习&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#更新中，未完待续"><span class="toc-number">1.</span> <span class="toc-text">更新中，未完待续</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序-Bubble-Sort"><span class="toc-number">1.1.</span> <span class="toc-text">冒泡排序(Bubble Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序-Selection-Sort"><span class="toc-number">1.2.</span> <span class="toc-text">选择排序(Selection Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序-Insertion-Sort"><span class="toc-number">1.3.</span> <span class="toc-text">插入排序(Insertion Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序-Shell-Sort"><span class="toc-number">1.4.</span> <span class="toc-text">希尔排序(Shell Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序-Quick-Sort"><span class="toc-number">1.5.</span> <span class="toc-text">快速排序(Quick Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序-Heap-Sort"><span class="toc-number">1.6.</span> <span class="toc-text">堆排序(Heap Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序-Merge-Sort"><span class="toc-number">1.7.</span> <span class="toc-text">归并排序(Merge Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数排序-Counting-Sort"><span class="toc-number">1.8.</span> <span class="toc-text">计数排序(Counting Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排-Bucket-Sort"><span class="toc-number">1.9.</span> <span class="toc-text">桶排(Bucket Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序-Radix-Sort"><span class="toc-number">1.10.</span> <span class="toc-text">基数排序(Radix Sort)</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        排序算法复习
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">1nv0k3r's notebook</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-04-26T11:36:36.000Z" itemprop="datePublished">2020-04-26</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="更新中，未完待续"><a href="#更新中，未完待续" class="headerlink" title="更新中，未完待续"></a>更新中，未完待续</h1><p>考研凉凉的结果就是不仅失去了应届生走校招的机会，而且还因为疫情走不了，僵。因为接下来准备找一份安全相关的C/C++开发工作，所以在刷了段时间题后，把排序算法重新复习整理一下。之前虽然学习过，但是现在一些不经常用的东西很快就忘了细结了，只能偶尔复习一下。</p>
<p>本文主要以<a href="https://www.cnblogs.com/onepixel/articles/7674659.html">十大经典排序算法</a>为参考文章来进行复习，使用C++实现，代码都经过了测试。</p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p>冒泡排序，选择排序和插入排序算是我使用最多的三种排序方法了，因为实现起来简单，惭愧惭愧。</p>
<p>流程就是比较相邻的元素，如果前面的比后面的大，就把他们交换一下。</p>
<p>这样一轮交换结束后，最后一个元素是所有数字里最大的，最坏情况下即数组是逆序的情况下，所有第一轮需要比较和交换n-1次，第二轮是n-2次，以此类推，最后总的比较和交换的次数是1+2+..+n-1=n(n-1)/2次，时间复杂度是O($n^2$)，每次对换需要一个temp，所以空间复杂度是O(1)，由于对换的时候可以对相同元素选择不对换，所以是稳定的排序。</p>
<p>i = n - 2<br>j = n - 1<br>代码实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">BubbleSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = <span class="built_in">array</span>[j];</span><br><span class="line">                    <span class="built_in">array</span>[j] = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">                    <span class="built_in">array</span>[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h2><p>找到最小的一个元素放在第一个位置，然后循环剩下的元素，或者找最大的放最后一个位置。</p>
<p>比较次数和冒泡实际上是一样的，也是n-1 + n-2 + … + 1 = n * (n - 1) / 2次，时间复杂度是O($n^2$)，空间复杂度是O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">SelectionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[i])&#123;</span><br><span class="line">                    <span class="built_in">min</span> = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[<span class="built_in">min</span>];</span><br><span class="line">            <span class="built_in">array</span>[<span class="built_in">min</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序(Insertion Sort)"></a>插入排序(Insertion Sort)</h2><p>插入排序是对每一个元素，从开头开始扫描，找到合适的位置插入</p>
<p>由于对每个元素，都需要向后移动1+2+..+n-1=n*(n-1) / 2次数据，所以时间复杂度也是O($n^2$)，空间复杂度是O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">InsertionSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">int</span> front = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (front &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[front] &gt; temp) &#123;</span><br><span class="line">                <span class="built_in">array</span>[front + <span class="number">1</span>] = <span class="built_in">array</span>[front];</span><br><span class="line">                front--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">array</span>[front + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>插入排序的改进，优先比较距离近的元素，所以又叫缩小增量排序，说白了就是把插入排序中，一个一个比较改成从第n个开始比较，作为增量，直到这个增量变为1，因此增量序列是$t_1，t_2，t_3…t_n$，当i &lt; j时有$t_i &gt; t_j$，$t_n = 1$</p>
<p>目前为止还没有一个最好的增量序列，希尔提出的序列是$t<em>1=n/2$, $t</em>{i+1}=t_i/2$，最坏情况下的时间复杂度是O($n^2$)，n在特定范围的时候，时间复杂度是O($n^1.3$)，空间复杂度是O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ShellSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> t = n / <span class="number">2</span>; t &gt; <span class="number">0</span>; t /= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i ++)&#123;<span class="comment">// 循环每一组</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i + t; j &lt; n; j += t)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - t])&#123;</span><br><span class="line">                        <span class="keyword">int</span> temp = <span class="built_in">array</span>[j], k;</span><br><span class="line">                        <span class="keyword">for</span>(k = j - t; k &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[k] &gt; temp; k -= t)&#123;</span><br><span class="line">                            <span class="built_in">array</span>[k + t] = <span class="built_in">array</span>[k];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">array</span>[k + t] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h2><p>快速排序是对冒泡排序的改进，基于分治法思想，先选取一个元素作为基准，通过一趟排序，把整个列表划分为独立的两部分，前半部分均小于基准，后半部分大于基准，这时，基准所在的位置是最终结果的位置，整个过程称为一趟快速排序，接下来分别对前后两个子表递归重复上述过程，直至每个部分只有一个元素或者为空为止。</p>
<p>快速排序的空间复杂度取决于递归调用栈的深度，最好情况下是$\lceil\log_2(n+1)\rceil$，最坏情况下需要进行n-1次递归，栈深度为O(n)，因此空间复杂度在最坏情况下为O(n)，评价情况下为O($\log_2n$)。</p>
<p>时间复杂度在最坏情况下，划分的两个部分完全不对称，即一部分是n-1个元素，另一部分是0个元素，在数组完全逆序或者基本有序的情况下，得到最坏情况的时间复杂度O($n^2$)。<br>在理想状态下，每次划分都是最平衡时，得到的两个子排序的时间复杂度都不超过n/2，此时排序的时间复杂度为O($n\log_2n$)。<br>若存在两个相同元素在右端区间，且均小于基准，在这两个元素移动到左边区间时，相对位置会发生替换，因此是不稳定的排序。</p>
<p>有很多方法可以提高快速排序的效率。第一种方法是在子序列的规模较小的时候就换用直接插入排序。第二方法是尽量选择一个可以均匀划分序列的基准，比如从头尾及中间选取三个元素，然后取其中间值作为基准，或者随机从序列中选择一个基准。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* 保持和前面排序函数相同的接口 */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        QuickSortRecursion(<span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/* 用来递归的函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">QuickSortRecursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123; <span class="comment">// 递归结束条件</span></span><br><span class="line">            <span class="keyword">int</span> pivotpos = Partition(<span class="built_in">array</span>, low, high);</span><br><span class="line">            QuickSortRecursion(<span class="built_in">array</span>, low, pivotpos - <span class="number">1</span>);</span><br><span class="line">            QuickSortRecursion(<span class="built_in">array</span>, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 用来划分的函数 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = <span class="built_in">array</span>[low]; <span class="comment">// 第一个元素设置为基准</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; <span class="built_in">array</span>[high] &gt;= pivot) --high; <span class="comment">// 从后往前找一个比基准小的元素</span></span><br><span class="line">            <span class="built_in">array</span>[low] = <span class="built_in">array</span>[high]; <span class="comment">// 放在最前面</span></span><br><span class="line">            <span class="keyword">while</span> (low &lt; high &amp;&amp; <span class="built_in">array</span>[low] &lt;= pivot) ++low; <span class="comment">// 从前往后找一个比基准大的元素</span></span><br><span class="line">            <span class="built_in">array</span>[high] = <span class="built_in">array</span>[low]; <span class="comment">// 放在最后面</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[low] = pivot; <span class="comment">// 基准放到最终位置</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h2><p>堆排序是一种树形的选择排序，在排序过程中，把待排序的序列看作一颗完全二叉树的顺序存储结构，利用二叉树来选择值最大或最小的元素。</p>
<p>堆存在两种情况：</p>
<ol>
<li>根结点小于左右子结点，称为小根堆</li>
<li>根结点大于左右子结点，称为大根堆</li>
</ol>
<p>首先要建立一个大根堆，方法就是先找到最后一个结点的父结点，由于堆是一个完全二叉树，所以最后一个结点的下标的父结点应该是$\lfloor length/2 - 1 \rfloor$(下标从0开始)，接着比较最后一个结点和其父结点的值，若大于父结点则交换。对这个父结点和它前面的结点重复上述过程，就完成了初始建堆。</p>
<p>建堆完成后，所有的数据组成一个大根堆，根结点是最大的元素，将其放在数组末尾，也就是把根结点和最后一个结点交换，交换完成后，堆的结构被破坏，需要重新调整。</p>
<p>除去已经排好序的最大的结点，其他结点作为一个堆重新进行调整直至成为大根堆。由于只修改了根结点，所以只需要对根结点进行一次向下调整即可。重复把最大元素调整到数组末尾，即可得到一个有序序列。</p>
<p>建堆的时间复杂度为O(n)，所以可以利用建堆找出很多数中的最大的几个数字。建好堆后对堆调整了n-1次，每次调整的时间复杂度取决于二叉树的高度，所以堆排序的时间复杂度为O($n\log_2(n)$)，由于使用了常数个辅助单位，所以空间复杂度是O(1)，由于在筛选的时候可能把值相同的元素互相调换，所以是一种不稳定的排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">HeapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        BuildMaxHeap(<span class="built_in">array</span>, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="built_in">array</span>[i] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="built_in">array</span>[<span class="number">0</span>] = temp;</span><br><span class="line">            AdjustDown(<span class="built_in">array</span>, <span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            AdjustDown(<span class="built_in">array</span>, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">array</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k * <span class="number">2</span> + <span class="number">1</span>; i &lt; len; i = i * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span>&lt; len &amp;&amp; <span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i + <span class="number">1</span>]) &#123;    <span class="comment">// 判断子结点哪个大</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="built_in">array</span>[i]) &#123;                         <span class="comment">// 比较根结点和较大的子结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">array</span>[k] = <span class="built_in">array</span>[i];                        <span class="comment">// 把较大的子结点放在根结点的位置</span></span><br><span class="line">                k = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h2><p>归并排序基于一种全新的思想，即将两个或两个以上的有序表组合成一个新的有序表，假定有n个元素待排序，可以看作是n个有序表，然后两个两个归并，得到$\lceil n/2 \rceil$个长度为1或2的有序表，继续两两归并直到合并为一个长度为n的有序表，这种方法称为二路归并，如果是多个有序表归并则称为n路归并。</p>
<p>由于需要用到n个辅助空间，所以空间复杂度是O(n)，每趟归并的时间复杂度是O(n)，进行$\lceil log_2n \rceil$次归并，所以时间复杂度是O($n\log_2n$)$，因为排序不会改变相同元素的相对位置，所以是稳定的排序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sort</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Merge用来合并两个相邻的有序表</span></span><br><span class="line"><span class="comment">        一个是temp，一个是array</span></span><br><span class="line"><span class="comment">        合并结果存入结果数组array中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = low; i &lt;= high; i ++)&#123;</span><br><span class="line">            temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temp[i] &lt;= temp[j])&#123;</span><br><span class="line">                <span class="built_in">array</span>[k] = temp[i ++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">array</span>[k] = temp[j ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            <span class="built_in">array</span>[k ++] = temp[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= high)&#123;</span><br><span class="line">            <span class="built_in">array</span>[k ++] = temp[j ++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        实际的排序函数，用于递归</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">MergeSortTemp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;temp, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">           <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">           MergeSortTemp(temp, <span class="built_in">array</span>, low, mid);</span><br><span class="line">           MergeSortTemp(temp, <span class="built_in">array</span>, mid + <span class="number">1</span>, high);</span><br><span class="line">           Merge(temp, <span class="built_in">array</span>, low, mid, high);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    排序函数的接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">temp</span><span class="params">(<span class="built_in">array</span>.<span class="built_in">size</span>(), <span class="number">0</span>)</span></span>; <span class="comment">// 创建一个辅助数组，初始化为0</span></span><br><span class="line">        MergeSortTemp(temp, <span class="built_in">array</span>, <span class="number">0</span>, <span class="built_in">array</span>.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序(Counting Sort)"></a>计数排序(Counting Sort)</h2><h2 id="桶排-Bucket-Sort"><a href="#桶排-Bucket-Sort" class="headerlink" title="桶排(Bucket Sort)"></a>桶排(Bucket Sort)</h2><h2 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序(Radix Sort)"></a>基数排序(Radix Sort)</h2>
  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#更新中，未完待续"><span class="toc-number">1.</span> <span class="toc-text">更新中，未完待续</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序-Bubble-Sort"><span class="toc-number">1.1.</span> <span class="toc-text">冒泡排序(Bubble Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序-Selection-Sort"><span class="toc-number">1.2.</span> <span class="toc-text">选择排序(Selection Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序-Insertion-Sort"><span class="toc-number">1.3.</span> <span class="toc-text">插入排序(Insertion Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序-Shell-Sort"><span class="toc-number">1.4.</span> <span class="toc-text">希尔排序(Shell Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序-Quick-Sort"><span class="toc-number">1.5.</span> <span class="toc-text">快速排序(Quick Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆排序-Heap-Sort"><span class="toc-number">1.6.</span> <span class="toc-text">堆排序(Heap Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序-Merge-Sort"><span class="toc-number">1.7.</span> <span class="toc-text">归并排序(Merge Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数排序-Counting-Sort"><span class="toc-number">1.8.</span> <span class="toc-text">计数排序(Counting Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排-Bucket-Sort"><span class="toc-number">1.9.</span> <span class="toc-text">桶排(Bucket Sort)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序-Radix-Sort"><span class="toc-number">1.10.</span> <span class="toc-text">基数排序(Radix Sort)</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&text=排序算法复习"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&is_video=false&description=排序算法复习"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=排序算法复习&body=Check out this article: http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&title=排序算法复习"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/&name=排序算法复习&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 1nv0k3r
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-131778492-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?da32760b25f029bfe0c4abfc646f5f7a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'blog-tw5j2p4htr';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


