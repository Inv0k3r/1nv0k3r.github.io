<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="背景cve-2020-0022是安卓蓝牙模块的一个漏洞，出现在Bluedroid蓝牙协议栈的HCI层，影响安卓10以下的系统，并在安卓10上造成DoS 分析记录android内核调试环境搞不起来。。orz先把坑开了慢慢搞 国外公布了漏洞详情，给了一个没有ROP的exp，我翻译了一下文章 参考文章 https:&#x2F;&#x2F;insinuator.net&#x2F;2020&#x2F;04&#x2F;cve-2020-0022-an-and">
<meta property="og:type" content="article">
<meta property="og:title" content="Cve-2020-0022 简单分析记录">
<meta property="og:url" content="http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="1nv0k3r&#39;s blog">
<meta property="og:description" content="背景cve-2020-0022是安卓蓝牙模块的一个漏洞，出现在Bluedroid蓝牙协议栈的HCI层，影响安卓10以下的系统，并在安卓10上造成DoS 分析记录android内核调试环境搞不起来。。orz先把坑开了慢慢搞 国外公布了漏洞详情，给了一个没有ROP的exp，我翻译了一下文章 参考文章 https:&#x2F;&#x2F;insinuator.net&#x2F;2020&#x2F;04&#x2F;cve-2020-0022-an-and">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-15-33-14.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-16-02-51.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-16-23-37.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-16-24-55.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-27-15.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-38-40.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-40-33.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-41-14.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-46-07.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-49-05.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-52-28.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-54-55.png">
<meta property="og:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-17-56-29.png">
<meta property="article:published_time" content="2020-02-24T14:47:21.000Z">
<meta property="article:modified_time" content="2021-04-15T06:30:36.624Z">
<meta property="article:author" content="1nv0k3r">
<meta property="article:tag" content="1nv0k3r">
<meta property="article:tag" content=" blog">
<meta property="article:tag" content=" pwn">
<meta property="article:tag" content=" binary">
<meta property="article:tag" content=" exploit">
<meta property="article:tag" content=" vuln">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1nv0k3r.fun/images/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/2020-04-23-15-33-14.png">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Cve-2020-0022 简单分析记录</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2020/04/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/10/03/cve-2019-16928-exim-%E5%A0%86%E6%BA%A2%E5%87%BA%E5%88%86%E6%9E%90/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&text=Cve-2020-0022 简单分析记录"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&is_video=false&description=Cve-2020-0022 简单分析记录"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cve-2020-0022 简单分析记录&body=Check out this article: http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&name=Cve-2020-0022 简单分析记录&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析记录"><span class="toc-number">2.</span> <span class="toc-text">分析记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">3.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#国外的分析文章翻译"><span class="toc-number">4.</span> <span class="toc-text">国外的分析文章翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前期工作"><span class="toc-number">4.1.</span> <span class="toc-text">前期工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-ACL"><span class="toc-number">4.2.</span> <span class="toc-text">Fuzzing ACL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L2CAP-分片"><span class="toc-number">4.3.</span> <span class="toc-text">L2CAP 分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#意料之外的Leak"><span class="toc-number">4.4.</span> <span class="toc-text">意料之外的Leak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memwtf-2"><span class="toc-number">4.5.</span> <span class="toc-text">memwtf(,,-2);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泄露更多数据"><span class="toc-number">4.6.</span> <span class="toc-text">泄露更多数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制执行流，Payload的位置"><span class="toc-number">4.7.</span> <span class="toc-text">控制执行流，Payload的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用System"><span class="toc-number">4.8.</span> <span class="toc-text">调用System()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#披露和结束语"><span class="toc-number">4.9.</span> <span class="toc-text">披露和结束语</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Cve-2020-0022 简单分析记录
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">1nv0k3r's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-02-24T14:47:21.000Z" itemprop="datePublished">2020-02-24</time>
        
      
    </div>


      

      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>cve-2020-0022是安卓蓝牙模块的一个漏洞，出现在Bluedroid蓝牙协议栈的HCI层，影响安卓10以下的系统，<br>并在安卓10上造成DoS</p>
<h2 id="分析记录"><a href="#分析记录" class="headerlink" title="分析记录"></a>分析记录</h2><p>android内核调试环境搞不起来。。orz先把坑开了慢慢搞</p>
<p>国外公布了漏洞详情，给了一个没有ROP的exp，我翻译了一下文章</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://insinuator.net/2020/04/cve-2020-0022-an-android-8-0-9-0-bluetooth-zero-click-rce-bluefrag/">https://insinuator.net/2020/04/cve-2020-0022-an-android-8-0-9-0-bluetooth-zero-click-rce-bluefrag/</a></li>
<li><a href="https://mp.weixin.qq.com/s/MgttHkorVd5UrW1Cnlc5Xw">Android蓝牙子系统“BlueFrag”漏洞分析（CVE-2020-0022） 启明星辰</a></li>
<li><a href="https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/">https://insinuator.net/2020/02/critical-bluetooth-vulnerability-in-android-cve-2020-0022/</a></li>
<li><a href="https://akhozo.blogspot.com/2020/02/critical-android-bluetooth-flaw-cve.html?spref=tw">https://akhozo.blogspot.com/2020/02/critical-android-bluetooth-flaw-cve.html?spref=tw</a></li>
<li><a href="https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/#F0">https://android.googlesource.com/platform/system/bt/+/3cb7149d8fed2d7d77ceaa95bf845224c4db3baf%5E%21/#F0</a></li>
<li><a href="https://source.android.com/security/bulletin/2020-02-01.html">https://source.android.com/security/bulletin/2020-02-01.html</a></li>
<li><a href="http://androidxref.com/8.1.0_r33/xref/system/bt/hci/src/packet_fragmenter.cc">http://androidxref.com/8.1.0_r33/xref/system/bt/hci/src/packet_fragmenter.cc</a></li>
<li>Bluetooth_Core_v4.2蓝牙官方文档</li>
</ul>
<h2 id="国外的分析文章翻译"><a href="#国外的分析文章翻译" class="headerlink" title="国外的分析文章翻译"></a>国外的分析文章翻译</h2><p>原文链接：<a href="https://insinuator.net/2020/04/cve-2020-0022-an-android-8-0-9-0-bluetooth-zero-click-rce-bluefrag/">CVE-2020-0022 an Android 8.0-9.0 Bluetooth Zero-Click RCE – BlueFrag</a></p>
<p>蓝牙是移动设备的一个主要部分，智能机和智能手表/耳机通过蓝牙连接，但是有很多设备会默认接受附近的任何未授权设备的连接。蓝牙数据包会在蓝牙芯片（也叫控制器）中进行处理，然后传递给主机（Android，Linux等)，因此蓝牙芯片的固件和主机的蓝牙子系统是黑客们想实现RCE的目标之一。</p>
<p>在大部分传统蓝牙的实现代码中，都有一个特性是通过蓝牙的ping进行应答。攻击者只需要知道蓝牙设备的地址，即使是目标设备设置为不可见，也通常会在收到通过地址的连接请求后接受连接，例如攻击者可以运行L2PING与目标建立一个L2CAP连接，发送ECHO请求。</p>
<p>接下来我们会讲解一个Android 9中蓝牙的zero-click近距离RCE的利用代码，CVE编号是CVE-2020-0022，在2019年11月3日报告该问题前，我们完成了最新版本的三星Galaxy S10e上拿到一个远程shell的全部步骤。这个漏洞的利用点在Android 10中仍然存在，但是我们在Bionic（Android的Libc）中用了另一个漏洞，让漏洞利用起来更容易了。这个漏洞在1.2.2020，A-143894715的安全补丁中被修复。这里有个完整的PoC的演示视频：</p>
<h3 id="前期工作"><a href="#前期工作" class="headerlink" title="前期工作"></a>前期工作</h3><p>通过SEEMOO实验室（德国的一个移动网络安全实验室）的开源项目<a href="https://github.com/seemoo-lab/internalblue">internalblue</a>，<a href="https://github.com/seemoo-lab/frankenstein">frankenstein</a>，我们花了很多时间去研究Braodcom的蓝牙固件，Internalblue是由Dennis Mant编写的，通过交互的方式来调试固件。在这个项目中通过逆向工程的方法来理解固件的工作细节。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-15-33-14.png" alt=""></p>
<p>在进一步的分析中，我们构建了Frankenstein，用来仿真固件来进行fuzz。要实现固件仿真，一个关键部分是理解蓝牙核心调度器（BCS，Bluetooth Core Scheduler）。这个组件很有意思，它处理了数据包和payload的头部，并且管理实时任务（time-critical task）。这些低级功能无法通过主机来访问，甚至在固件本身的线程组件中也无法访问。通过访问BCS，我们甚至可以将原始的无线数据帧注入到仿真的固件中。</p>
<p>在Frankenstein的fuzz中，我们更关注的是在蓝牙配对前产生的漏洞。在协议部分我们发现了两个漏洞，一个在传统的蓝牙中，一个在低功耗的蓝牙（BLE，Bluetooth Low Energy）中。第一个堆溢出的漏洞是在蓝牙扫描结果（EIR，Extended Inquiry Result）的过程处理中产生，影响在2010-2018年构建的固件中，甚至可能更早<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-11516">CVE-2019-11516</a>，我们在2019年4月向Broadcom提供了完整的RCE的PoC，在报告提交后，Broadcom表示他们已经知道这个问题，实际上最新的三星Galaxy S10e中有一个我们不知道的补丁，因为它刚发布。第二个堆溢出的漏洞影响蓝牙4.2后的所有的BLE分组数据单元（PDUs，Packet Data Units）。我们在2019年6月向Boardcom提供了PoC，它破坏了堆，但是遗漏了一个通过更多数据吞吐实现的原语。据我们所知，这个问题到2020年2月还没有修复。</p>
<p>在研究PoCs和如何将大量数据放入堆中的办法时，我们还研究了传统蓝牙的异步无连接数据包（ACL，Asynchronous Connection-Less）。它主要用于数据传输，如音乐流，数据共享或者更常见的L2CAP。在固件中，ACL的处理相对简单一些。还有更复杂的处理程序和专有协议扩展，比如Jiska Classen发现的链接管理协议（LMP，Link Management Protocol）的类型混淆漏洞<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-19860">CVE-2018-19860</a></p>
<h3 id="Fuzzing-ACL"><a href="#Fuzzing-ACL" class="headerlink" title="Fuzzing ACL"></a>Fuzzing ACL</h3><p>本文中描述的这个漏洞是在ACL中触发的。我们对这个协议进行了Fuzz测试，对数据包的payload头和包进行了位翻转。最初的fuzzer是通过在固件中hook函数bcs_dmaRxEnable实现的。该函数由BCS ACL任务调用。bcs_dmaRxEnable能将无线数据帧复制到传输缓冲区，在此函数之前，数据包和payload头已经写入了相应的硬件寄存器中了。因此我们可以通过在传输之前就修改整个数据包，从而在固件中构建一个简单的蓝牙fuzz工具。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-16-02-51.png" alt=""></p>
<p>在一开始的设置中，我们通过无线方式，在Linux主机上对Android设备运行L2PING，并且对蓝牙固件fuzzer中随机翻转头部的比特位。当我们试图崩溃蓝牙设备时，安卓的蓝牙守护进程却崩溃了。在日志中我们观察到几个这样的崩溃报告：</p>
<pre><code>pid: 14808, tid: 14858, name: HwBinder:14808_  &gt;&gt;&gt; com.android.bluetooth &lt;&lt;&lt;
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x79cde00000
    x0  00000079d18360e1  x1  00000079cddfffcb  x2  fffffffffff385ef  x3  00000079d18fda60
    x4  00000079cdd3860a  x5  00000079d18360df  x6  0000000000000000  x7  0000000000000000
    x8  0000000000000000  x9  0000000000000000  x10 0000000000000000  x11 0000000000000000
    x12 0000000000000000  x13 0000000000000000  x14 ffffffffffffffff  x15 2610312e00000000
    x16 00000079bf1a02b8  x17 0000007a5891dcb0  x18 00000079bd818fda  x19 00000079cdd38600
    x20 00000079d1836000  x21 0000000000000097  x22 00000000000000db  x23 00000079bd81a588
    x24 00000079bd819c60  x25 00000079bd81a588  x26 0000000000000028  x27 0000000000000041
    x28 0000000000002019  x29 00000079bd819df0
    sp  00000079bd819c50  lr  00000079beef4124  pc  0000007a5891ddd4

backtrace:
    #00 pc 000000000001ddd4  /system/lib64/libc.so (memcpy+292)
    #01 pc 0000000000233120  /system/lib64/libbluetooth.so (reassemble_and_dispatch(BT_HDR*) [clone .cfi]+1408)
    #02 pc 000000000022fc7c  /system/lib64/libbluetooth.so (BluetoothHciCallbacks::aclDataReceived(android::hardware::hidl_vec&lt;unsigned char&gt; const&amp;)+144)
    [...]
</code></pre><p>看起来似乎是reassemble_and_dispatch函数中的memcpy以负数长度执行了。memcpy的简单实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">char</span> *dest; <span class="keyword">char</span> *src, <span class="keyword">size_t</span> *n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    dst[i] = src[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数中的长度n的类型是size_t，是一个无符号整数，如果我们传一个负数n进去，它会因为补码表示法变成一个很大的正数，导致了memcpy在一个无限循环中不断复制内存，进而遇到一些未映射的内存而崩溃。</p>
<h3 id="L2CAP-分片"><a href="#L2CAP-分片" class="headerlink" title="L2CAP 分片"></a>L2CAP 分片</h3><p>蓝牙在不同的层中进行分段，在分析整个崩溃时，我们主要关注蓝牙控制器和主机之间传递的L2CAP数据包的分片。对于主机和蓝牙控制器之间的命令和配置，使用了主机控制接口（HCI，Host Controller Interface）。</p>
<p>L2CAP作为ACL包通过与HCI相同的UART（通用异步收发传输器，Universal Asynchronous Receiver/Transmitter）连接发送。它需要按照最大ACL数据包长度进行分割，在主机上的驱动程序进行固件初始化期间，HCI命令读取缓冲区大小，在Boardcom的芯片上这个长度是1021，主机的驱动程序在向固件发送数据包的时候需要按照这个大小限制来发送。同样的，固件也拒绝L2CAP的输入，因为这些输入没有被正确的按照大小分片。由于分片和重组都是在主机上，但是固件本身也有数据包的大小限制，所以L2CAP对于主机和蓝牙控制器的堆利用很有意思。</p>
<p>如果接收到的L2CAP数据包的长度大于缓冲区的最大长度1021，这个数据包会被重组，部分包保存在名为partial_packets的map中，使用连接句柄作为key。接着分配一个足够大的缓冲区来容纳最后的数据包，然后把接收到的数据复制到该缓冲区。最后接收到的分片的结尾保存在partial_packet-&gt;offset中。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-16-23-37.png" alt=""></p>
<p>下面的包设置了一个延续标志，表明这是一个包的分片，它是ACL头连接句柄中的第12位，如果收到这样的一个包，包内容就会被复制到之前的偏移量。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-16-24-55.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reassemble_and_dispatch</span><span class="params">(UNUSED_ATTR BT_HDR *packet)</span> </span>&#123;</span><br><span class="line">      [...]</span><br><span class="line">      packet-&gt;offset = HCI_ACL_PREAMBLE_SIZE;</span><br><span class="line">      <span class="keyword">uint16_t</span> projected_offset =</span><br><span class="line">          partial_packet-&gt;offset + (packet-&gt;len - HCI_ACL_PREAMBLE_SIZE);</span><br><span class="line">      <span class="keyword">if</span> (projected_offset &gt;</span><br><span class="line">          partial_packet-&gt;len) &#123;  <span class="comment">// len stores the expected length</span></span><br><span class="line">        LOG_WARN(LOG_TAG,</span><br><span class="line">             <span class="string">"%s got packet which would exceed expected length of %d."</span></span><br><span class="line">             <span class="string">"Truncating."</span>,</span><br><span class="line">             __func__, partial_packet-&gt;len);</span><br><span class="line">        packet-&gt;len = partial_packet-&gt;len - partial_packet-&gt;offset;</span><br><span class="line">        projected_offset = partial_packet-&gt;len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(partial_packet-&gt;data + partial_packet-&gt;offset,</span><br><span class="line">         packet-&gt;data + packet-&gt;offset, packet-&gt;len - packet-&gt;offset);</span><br><span class="line"></span><br><span class="line">      [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个步骤导致了负长度的memcpy，如上面的代码所示，在某种情况下，我们得到了一个数据包，只剩下两个字节的缓冲区来接收，如果延续比预期的长，packet-&gt;length会被截断来避免缓冲区溢出，长度设置为要复制的字节数。</p>
<p>由于我们需要跳过HCI和ACL前导码，我们使用HCI_ACL_PREAMBLE_SIZE(4)作为包的偏移量，并且从要复制的字节数中减去它，导致了memcpy的负长度为-2。</p>
<h3 id="意料之外的Leak"><a href="#意料之外的Leak" class="headerlink" title="意料之外的Leak"></a>意料之外的Leak</h3><p>上述的bug似乎无法利用，因为我们得到了一个无限循环的memcpy，但是我们偶尔会在不同的位置产生crash，比如下列崩溃位于同一线程中，但是无法通过无限循环复制来解释。因此我们希望在某个地方找到另一个bug：</p>
<pre><code>pid: 14530, tid: 14579, name: btu message loo  &gt;&gt;&gt; com.android.bluetooth &lt;&lt;&lt;
signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x7a9e0072656761
    x0  0000007ab07d72c0  x1  0000007ab0795600  x2  0000007ab0795600  x3  0000000000000012
    x4  0000000000000000  x5  0000007a9e816178  x6  fefeff7a3ac305ff  x7  7f7f7f7f7fff7f7f
    x8  007a9e0072656761  x9  0000000000000000  x10 0000000000000020  x11 0000000000002000
    x12 0000007aa00fc350  x13 0000000000002000  x14 000000000000000d  x15 0000000000000000
    x16 0000007b396f6490  x17 0000007b3bc46120  x18 0000007a9e81542a  x19 0000007ab07d72c0
    x20 0000007ab0795600  x21 0000007a9e817588  x22 0000007a9e817588  x23 000000000000350f
    x24 0000000000000000  x25 0000007ab07d7058  x26 000000000000008b  x27 0000000000000000
    x28 0000007a9e817588  x29 0000007a9e816340
    sp  0000007a9e8161e0  lr  0000007a9fde0ca0  pc  0000007a9fe1a9a4

backtrace:
    #00 pc 00000000003229a4  /system/lib64/libbluetooth.so (list_append(list_t*, void*) [clone .cfi]+52)
    #01 pc 00000000002e8c9c  /system/lib64/libbluetooth.so (l2c_link_check_send_pkts(t_l2c_linkcb*, t_l2c_ccb*, BT_HDR*) [clone .cfi]+100)
    #02 pc 00000000002ea25c  /system/lib64/libbluetooth.so (l2c_rcv_acl_data(BT_HDR*) [clone .cfi]+1236)
    [...]
</code></pre><p>我们花了几个晚上来跟踪这些崩溃，并且修改了fuzz使其可以被重放。然而，通过重发数据包来重现这些有意思的崩溃是不可能的。调试期间的主要问题是我们没有使用地址清理器来编译Android。这会检测到任何内存损坏错误，因为它在一个随机位置崩溃前发生的。所以在经历一些失败后我们决定修改一些比特位，通过保持L2PING的payload不变，我们可以用它和响应包的payload进行比对，如果数据同时发生变化，则会损坏内存，但是不会导致崩溃。运行一段时间后我们得到了这样的错误响应：</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-27-15.png" alt=""></p>
<p>通过这种检测方法，我们就可以可靠地重放。下面的数据包分组可以触发：</p>
<pre><code>1. 剩余2字节用于延续的L2CAP数据包，包含A
2. 延续比预期的2字节长的数据包，包含B
</code></pre><p>在Android的Logcat中，我们可以看到以下错误消息：</p>
<pre><code>bt_hci_packet_fragmenter: reassemble_and_dispatch got packet which would
exceed expected length of 147. Truncating.
</code></pre><p>这个触发的错误看起来与上面的BUG很相似。注意，只有最后的字节被破坏了，包的开头仍然是正确的。这个情况不能用源码和我们目前所知道的来解释。直接的缓冲区溢出保持前两个字节不变或者以这种受控的方法来覆盖指针和偏移量都是不可能的。此时，我们决定在packet_fragmenter中设置断点，以观察包中数据的修改位置。我们用GDB脚本来调试，<code>reassemble_and_dispatch+1408</code>和<code>reassemble_and_dispatch+1104</code>是之前说的<code>reassemble_and_dispatch</code>中的两个<code>memcpy</code>。</p>
<pre><code>b reassemble_and_dispatch
commands; x/32x $x0; c; end

b dispatch_reassembled
commands; x/i $lr; x/32x $x0; c; end

b *(reassemble_and_dispatch+1408)
commands; p $x0; p $x1;p $x2; c; end

b *(reassemble_and_dispatch+1104)
commands; p $x0; p $x1; p $x2; c; end
</code></pre><p>对于第一个包含A的数据包，我们观察到以下日志。它按预期接收数据，第一个memcpy的长度为0x52字节触发。这个长度在包的内部BT_HDR结构中也是可见的，并且是正确的。ACL和L2CAP头文件中包含的长度比触发包重新组装的实际payload长2个字节。HCI头中的连接句柄是0x200b，表示连接句柄0x0b的开始包</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-38-40.png" alt=""></p>
<p>第二个包也在<code>reassemble_and_dispatch</code>中正确到达，并且连接句柄改为0x100b，表示它是一个延续包。memcpy的第三个参数是上面指出的0xfffffffffffffffe，即-2，由于memcpy把第三个参数看作无符号整数，所以这个memcpy将导致崩溃。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-40-33.png" alt=""></p>
<p>但显然程序继续运行，破坏了部分包的最后66个字节，被破坏的包被传递给<code>dispatch_reassembled</code></p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-41-14.png" alt=""></p>
<h3 id="memwtf-2"><a href="#memwtf-2" class="headerlink" title="memwtf(,,-2);"></a>memwtf(,,-2);</h3><p>如果我们仔细研究一下<a href="https://android.googlesource.com/platform/bionic/+/refs/tags/android-9.0.0_r49/libc/arch-arm64/generic/bionic/memcpy_base.S">memcpy的实际实现</a>，就会发现它比上面显示的简单的字符级memcpy要复杂的多。复制整个内存字比复制单个字节要更加有效。这个实现更进一步，在将寄存器写入目标位置之前，用64字节的内存内容填充寄存器。这样实现起来更复杂，并且得考虑奇数长度和未对齐地址边缘的情况。</p>
<p>(ps.这部分可以参考<a href="https://bestwing.me/Android-8.1-memcpy-func.html">swing的博客</a>)</p>
<p>在这个memcpy实现中，存在一个对负长度的奇怪行为。当我们试图复制到目标缓冲区末尾的时候，我们用之前的第二个数据包覆盖L2Ping请求的最后66个字节。我们编写这个简短的PoC是为了测试memcpy的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"usage %s offset_dst offset_src\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *src = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">char</span> *dst = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"src=%p\n"</span>, src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dst=%p\n"</span>, dst);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++) src[i] = i;</span><br><span class="line">    <span class="built_in">memset</span>(dst, <span class="number">0x23</span>, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>( dst + <span class="number">128</span> + atoi(argv[<span class="number">1</span>]),</span><br><span class="line">            src + <span class="number">128</span> + atoi(argv[<span class="number">2</span>]),</span><br><span class="line">            <span class="number">0xfffffffffffffffe</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Hexdump</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i+=<span class="number">32</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%04x:  "</span>, i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%02x"</span>, dst[i+j] &amp; <span class="number">0xff</span>);</span><br><span class="line">            <span class="keyword">if</span> (j%<span class="number">4</span> == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-46-07.png" alt=""></p>
<p>该行为已在Unicorn中模拟aarch64 memcpy实现进行了分析。 相关代码如下所示：</p>
<pre><code>prfm    PLDL1KEEP, [src]
add srcend, src, count
add dstend, dstin, count
cmp     count, 16
b.ls    L(copy16)           //Not taken as 0xfffffffffffffffe &gt; 16
cmp count, 96
b.hi    L(copy_long)        //Taken as as 0xfffffffffffffffe &gt; 96

[...]

L(copy_long):
and tmp1, dstin, 15         //tmp1 = lower 4 bits of destination
bic dst, dstin, 15
ldp D_l, D_h, [src]
sub src, src, tmp1
add count, count, tmp1      /* Count is now 16 too large.  */
                            //It is not only too large
                            //but might also be positive!
                            //0xfffffffffffffffe + 0xe = 0xc
ldp A_l, A_h, [src, 16]
stp D_l, D_h, [dstin]
ldp B_l, B_h, [src, 32]
ldp C_l, C_h, [src, 48]
ldp D_l, D_h, [src, 64]!
subs    count, count, 128 + 16  /* Test and readjust count.  */
                                //This  will become negative again
b.ls    2f                      //So this branch is taken

[...]


/* Write the last full set of 64 bytes.  The remainder is at most 64
bytes, so it is safe to always copy 64 bytes from the end even if
there is just 1 byte left.  */
//This will finally corrupt -64...64 bytes and terminate
2:
ldp E_l, E_h, [srcend, -64]
stp A_l, A_h, [dst, 16]
ldp A_l, A_h, [srcend, -48]
stp B_l, B_h, [dst, 32]
ldp B_l, B_h, [srcend, -32]
stp C_l, C_h, [dst, 48]
ldp C_l, C_h, [srcend, -16]
stp D_l, D_h, [dst, 64]
stp E_l, E_h, [dstend, -64]
stp A_l, A_h, [dstend, -48]
stp B_l, B_h, [dstend, -32]
stp C_l, C_h, [dstend, -16]
ret
</code></pre><p>因为我们处理的是一个非常大的count值(INT_MAX-2)，它总是大于dst和src之间的距离。因此在我们的例子中，将永远不会调用_memcpy，这使得这个bug无法在Android 10上利用。</p>
<h3 id="泄露更多数据"><a href="#泄露更多数据" class="headerlink" title="泄露更多数据"></a>泄露更多数据</h3><p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-49-05.png" alt=""></p>
<p>如上所述，我们基本上可以用源地址前面的内容覆盖包的最后64个字节。源缓冲区之前的20个字节总是<code>BT_HDR</code>，<code>acl_hdr</code>，<code>l2cap_hdr</code>。因此我们可以自动泄露远程设备的连接句柄。</p>
<p>未初始化内存的内容取决于第二个包的缓冲区的位置及其大小。通过重复发送常规的L2Ping回送请求，我们可以尝试将自己的包数据放在第二个包前面。这允许我们使用任意数据控制数据包的最后44个字节。通过缩短第一个包，可以控制整个包结构，包括包头。第一个数据包是这样的：</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-52-28.png" alt=""></p>
<p>在触发bug后，损坏的包是下图中所示的。包含“X”的包就是我们放在源缓冲区前面的包。注意，除了<code>BT_HDR</code>中的长度外，包长度现在是0x280，而不是0x30。<code>packet-&gt;len</code>字段必须保持原来的长度，否则重新组装的时候需要更多的数据。</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-54-55.png" alt=""></p>
<p>这将会导致更有用的泄露。注意，这是一种只针对数据的攻击，不需要执行代码或者其他任何附加信息。<br>它还可以将任意的L2CAP流量组合注入到任何活动的连接句柄中。成功的泄露可能如下图所示：</p>
<p><img src="/images/cve-2020-0022-简单分析记录/2020-04-23-17-56-29.png" alt=""></p>
<p>为了绕过地址随机化(ASLR)，我们需要一些基本的库的地址。我们偶尔会在堆上发现来自<code>libicuuc.so</code>的对象，有如下结构：</p>
<ul>
<li>一些堆指针</li>
<li>指向<code>libicuuc.so</code>中的<code>uhash_hashUnicodeString_60</code>指针</li>
<li>指向<code>libicuuc.so</code>中的<code>uhash_compareUnicodeString_60</code>指针</li>
<li>指向<code>libicuuc.so</code>中的<code>uhash_compareLong_60</code>的指针</li>
<li>指向<code>uprv_deleteUObject_60</code>中的<code>uprv_deleteUObject_60</code>的指针</li>
</ul>
<p>我们可以使用这些函数的偏移量来检测泄露中的这些结构。</p>
<h3 id="控制执行流，Payload的位置"><a href="#控制执行流，Payload的位置" class="headerlink" title="控制执行流，Payload的位置"></a>控制执行流，Payload的位置</h3><p>有几个库，比如<code>libbluetooth.so</code>，受到了Clang的调用流完整性（CFI，Call Flow Integrity）的保护。这样可以保护边界防止我们用任意地址覆盖堆上的<code>vtables</code>函数，只有属于受影响对象的函数才是可以调用的，尽管如此，在断开连接时，我们偶尔会在破坏堆后触发以下崩溃：</p>
<pre><code>signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 0x37363534333231
    x0  3837363534333231  x1  000000750c2649e0  x2  000000751e50a338  x3  0000000000000000
    x4  0000000000000001  x5  0000000000000001  x6  00000075ab788000  x7  0000000001d8312e
    x8  00000075084106c0  x9  0000000000000001  x10 0000000000000001  x11 0000000000000000
    x12 0000000000000047  x13 0000000000002000  x14 000f5436af89ca08  x15 000024747b62062a
    x16 000000750c2f55d8  x17 000000750c21b088  x18 000000750a660066  x19 000000751e50a338
    x20 000000751e40dfb0  x21 000000751e489694  x22 0000000000000001  x23 0000000000000000
    x24 000000750be85f64  x25 000000750a661588  x26 0000000000000005  x27 00000075084106b4
    x28 000000750a661588  x29 000000750a65fd30
    sp  000000750a65fd10  lr  000000750c264bb8  pc  000000750c264c5c

backtrace:
    #00 pc 00000000000dbc5c  /system/lib64/libchrome.so (base::WaitableEvent::Signal()+200)
    #01 pc 00000000000add88  /system/lib64/libchrome.so (base::internal::IncomingTaskQueue::PostPendingTask(base::PendingTask*)+320)
    [...]
    #09 pc 00000000002dd0a8  /system/lib64/libbluetooth.so (L2CA_DisconnectRsp(unsigned short) [clone .cfi]+84)
    #10 pc 0000000000307a08  /system/lib64/libbluetooth.so (sdp_disconnect_ind(unsigned short, bool) [clone .cfi]+44)
    #11 pc 00000000002e39d4  /system/lib64/libbluetooth.so (l2c_csm_execute(t_l2c_ccb*, unsigned short, void*) [clone .cfi]+5500)
    #12 pc 00000000002eae04  /system/lib64/libbluetooth.so (l2c_rcv_acl_data(BT_HDR*) [clone .cfi]+4220)
    [...]
</code></pre><p>在泄露过程中我们不仅向反方向溢出了，而且还破坏了在受影响缓冲区之后存储的数据。<br>在本例中，我们覆盖了保存在X0中的指针。通过查看代码中的位置，我们使指令在X0控制的分支寄存器之前崩溃。</p>
<pre><code>dbc5c: f9400008 ldr x8, [x0] // We control X0
dbc60: f9400108 ldr x8, [x8]
dbc64: aa1403e1 mov x1, x20
dbc68: d63f0100 blr x8 // Brach to **X0
</code></pre><p>如果我们知道一个可以存储任意数据的地址，我们就可以控制执行流了。<code>libchrome.so</code>没有用CFI编译，我们的包数据必须保存在堆的某个地方，但是我们还需要一种方法来搜索地址进行RCE。这是通过把连接句柄作为key，把部分数据包保存在哈希Map中实现的：</p>
<pre><code>BT_HDR* partial_packet = (BT_HDR*)buffer_allocator-&gt;alloc(full_length + sizeof(BT_HDR));
[...]
memcpy(partial_packet-&gt;data, packet-&gt;data, packet-&gt;len);
[...]
partial_packets[handle] = partial_packet;
</code></pre><p>这将在堆上分配一个对象，包含key(连接句柄)和指向我们数据包的一个指针。最后我们就可以泄露这个对象，得到指向我们缓冲区的指针。这时候Key是已知的，我们就可以用它在泄露的信息中找到我们的对象。通过使用允许的最大数据包大小，我们有几百个字节来保存ROP链和payload。</p>
<p>这种方法并不完全可靠，但是在30%-50%的情况下有效。即使是蓝牙守护进程自动重启然后再开一个同样的进程。因此，地址空间在引导的时候是随机的，即使我们的守护进程崩溃，也会用相同的地址布局重新启动，因此我们可以反复尝试攻击来获得RCE。</p>
<h3 id="调用System"><a href="#调用System" class="headerlink" title="调用System()"></a>调用System()</h3><p>即使我们知道了<code>libicuuc.so</code>的绝对地址，库之间的偏移也是随机的。因此我们只能在这个库中使用gadget。<code>libicuuc.so</code>的调用中没有什么有用的函数，比如system()，在这一点上，Fabian Beterke指出，应该去库导入中找一些有用的内容。</p>
<p>我们没有直接使用<code>system()</code>或者<code>execve()</code>，但是我们有<code>disym()</code>可以用，这个函数需要一个句柄（比如空指针）和一个函数名作为参数。它解析并返回该函数的地址，可以用来获取<code>system()</code>的地址，因此，我们需要执行一个函数调用，并且控制它的返回，在ROP中，这通常不是问题，因为Gadget总是以返回结束。但是，我们没有办法在ROP中使用栈迁移，因此我们用C++的对象调用来执行相关操作，这些操作通常和X8或者X19有关系。结果就是我们的payload中有很多相对引用，为了跟踪已经使用的偏移量，我们实现了一个<code>set_ptr(payload, offset, value)</code>的函数，如果已经使用了payload中的给定偏移量则抛出错误，我们还跟踪了寄存器的值来简化整个过程。为了从<code>dlsym</code>清晰地返回，我们用了一个名为<code>u_cleanup_60</code>的解析器，它遍历一个函数列表，如果指针不是空的就调用这个地址，并清除它。这很方便，因为我们可以调用<code>dlsym</code>，并且可以控制返回后的执行，而不需要用栈迁移。</p>
<pre><code>ldr x8, [x19, #0x40]; cbz x8, #0xbc128; blr x8; str xzr, [x19, #0x40];
ldr x8, [x19, #0x48]; cbz x8, #0xbc138; blr x8; str xzr, [x19, #0x48];
ldr x8, [x19, #0x50]; cbz x8, #0xbc148; blr x8; str xzr, [x19, #0x50];
ldr x8, [x19, #0x58]; cbz x8, #0xbc158; blr x8;
</code></pre><h3 id="披露和结束语"><a href="#披露和结束语" class="headerlink" title="披露和结束语"></a>披露和结束语</h3><p>这个漏洞最初是在2019年11月3日发送给Android的安全团队的，包括一个PoC，它于2020年2月1日修复，并且得到了Android安全团队的认可。我要感谢这个团队协调这个过程并且提供了一个解决方案。同时，我也要感谢Jiska Classen和Fabian Beterke的帮助，此外，我们还想对<a href="https://bestwing.me/Android-8.1-memcpy-func.html">Swing的博客</a>发出一声欢呼，因为它是第一个对我们知识进行颠覆的博客，它颠覆了关于漏洞的关键思想。（Swing大哥牛逼！！（破音！！））</p>
<p>测试脚本可以在这里<a href="https://insinuator.net/wp-content/uploads/2020/04/cve_2020_0022_export.tar.gz">下载</a>。ROP链已从该利用脚本中删除。压缩包包括以下文件：</p>
<ul>
<li>python2 simple_leak.py target 预料之外的泄露章节的PoC</li>
<li>python2 fancy_leak.py target，泄露更多数据部分的PoC</li>
<li>python2 memcpy.py libc.so memcpy的测试脚本</li>
<li>python2 exploit.py target remote_libicuuc.so 删掉了ROP链的利用脚本</li>
</ul>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#背景"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分析记录"><span class="toc-number">2.</span> <span class="toc-text">分析记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-number">3.</span> <span class="toc-text">参考文章</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#国外的分析文章翻译"><span class="toc-number">4.</span> <span class="toc-text">国外的分析文章翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前期工作"><span class="toc-number">4.1.</span> <span class="toc-text">前期工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fuzzing-ACL"><span class="toc-number">4.2.</span> <span class="toc-text">Fuzzing ACL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L2CAP-分片"><span class="toc-number">4.3.</span> <span class="toc-text">L2CAP 分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#意料之外的Leak"><span class="toc-number">4.4.</span> <span class="toc-text">意料之外的Leak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#memwtf-2"><span class="toc-number">4.5.</span> <span class="toc-text">memwtf(,,-2);</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泄露更多数据"><span class="toc-number">4.6.</span> <span class="toc-text">泄露更多数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制执行流，Payload的位置"><span class="toc-number">4.7.</span> <span class="toc-text">控制执行流，Payload的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调用System"><span class="toc-number">4.8.</span> <span class="toc-text">调用System()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#披露和结束语"><span class="toc-number">4.9.</span> <span class="toc-text">披露和结束语</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&text=Cve-2020-0022 简单分析记录"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&is_video=false&description=Cve-2020-0022 简单分析记录"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Cve-2020-0022 简单分析记录&body=Check out this article: http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&title=Cve-2020-0022 简单分析记录"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2020/02/24/cve-2020-0022-%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95/&name=Cve-2020-0022 简单分析记录&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 1nv0k3r
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-131778492-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?da32760b25f029bfe0c4abfc646f5f7a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'blog-tw5j2p4htr';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


